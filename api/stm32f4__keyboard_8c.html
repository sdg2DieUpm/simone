<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simone: a game of visual memory and speed: port/stm32f4/src/stm32f4_keyboard.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simone: a game of visual memory and speed
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('stm32f4__keyboard_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stm32f4_keyboard.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Portable functions to interact with the keyboard FSM library. All portable functions must be implemented in this file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &quot;<a class="el" href="port__keyboard_8h.html">port_keyboard.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="port__system_8h.html">port_system.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="stm32f4__system_8h.html">stm32f4_system.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="stm32f4__keyboard_8h.html">stm32f4_keyboard.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="keyboards_8h.html">keyboards.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa3330d22a2fcd66831baa9cdef648e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstm32f4__keyboard__hw__t.html">stm32f4_keyboard_hw_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#aa3330d22a2fcd66831baa9cdef648e48">_stm32f4_keyboard_get</a> (uint8_t keyboard_id)</td></tr>
<tr class="memdesc:aa3330d22a2fcd66831baa9cdef648e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keyboard struct with the given ID.  <a href="stm32f4__keyboard_8c.html#aa3330d22a2fcd66831baa9cdef648e48">More...</a><br /></td></tr>
<tr class="separator:aa3330d22a2fcd66831baa9cdef648e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d1f396d821890ec121fde3292f3ed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a02d1f396d821890ec121fde3292f3ed4">_timer_scan_column_config</a> (void)</td></tr>
<tr class="memdesc:a02d1f396d821890ec121fde3292f3ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the timer that controls the duration of the column scanning.  <a href="stm32f4__keyboard_8c.html#a02d1f396d821890ec121fde3292f3ed4">More...</a><br /></td></tr>
<tr class="separator:a02d1f396d821890ec121fde3292f3ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d73a385387a3fc0d0a2d2ded42e5d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#ab6d73a385387a3fc0d0a2d2ded42e5d8">port_keyboard_init</a> (uint8_t keyboard_id)</td></tr>
<tr class="memdesc:ab6d73a385387a3fc0d0a2d2ded42e5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the HW specifications of a given keyboard.  <a href="stm32f4__keyboard_8c.html#ab6d73a385387a3fc0d0a2d2ded42e5d8">More...</a><br /></td></tr>
<tr class="separator:ab6d73a385387a3fc0d0a2d2ded42e5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca9463c0c87fa80c6a08c5d71d23d4f"><td class="memItemLeft" align="right" valign="top"><a id="a1ca9463c0c87fa80c6a08c5d71d23d4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>port_keyboard_excite_row</b> (uint8_t keyboard_id, uint8_t row_idx)</td></tr>
<tr class="separator:a1ca9463c0c87fa80c6a08c5d71d23d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1320216867d7f6b27a77b4a597243b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a1320216867d7f6b27a77b4a597243b95">port_keyboard_start_scan</a> (uint8_t keyboard_id)</td></tr>
<tr class="memdesc:a1320216867d7f6b27a77b4a597243b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the scanning of a keyboard.  <a href="stm32f4__keyboard_8c.html#a1320216867d7f6b27a77b4a597243b95">More...</a><br /></td></tr>
<tr class="separator:a1320216867d7f6b27a77b4a597243b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52eeaf12ebfbd2faf6c944fc4f69600"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#ad52eeaf12ebfbd2faf6c944fc4f69600">port_keyboard_stop_scan</a> (uint8_t keyboard_id)</td></tr>
<tr class="memdesc:ad52eeaf12ebfbd2faf6c944fc4f69600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the scanning of a keyboard.  <a href="stm32f4__keyboard_8c.html#ad52eeaf12ebfbd2faf6c944fc4f69600">More...</a><br /></td></tr>
<tr class="separator:ad52eeaf12ebfbd2faf6c944fc4f69600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ff0a28d6cad5c0b67c4bc2f37cc2d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a76ff0a28d6cad5c0b67c4bc2f37cc2d2">port_keyboard_excite_next_row</a> (uint8_t keyboard_id)</td></tr>
<tr class="memdesc:a76ff0a28d6cad5c0b67c4bc2f37cc2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the row to be excited.  <a href="stm32f4__keyboard_8c.html#a76ff0a28d6cad5c0b67c4bc2f37cc2d2">More...</a><br /></td></tr>
<tr class="separator:a76ff0a28d6cad5c0b67c4bc2f37cc2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d95c098d9ce87863ae191c65246830"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#ad9d95c098d9ce87863ae191c65246830">port_keyboard_get_key_pressed_status</a> (uint8_t keyboard_id)</td></tr>
<tr class="memdesc:ad9d95c098d9ce87863ae191c65246830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the keyboard (pressed or not).  <a href="stm32f4__keyboard_8c.html#ad9d95c098d9ce87863ae191c65246830">More...</a><br /></td></tr>
<tr class="separator:ad9d95c098d9ce87863ae191c65246830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f06120b963a9aeda74ee26f3595478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#ac0f06120b963a9aeda74ee26f3595478">port_keyboard_set_key_pressed_status</a> (uint8_t keyboard_id, bool status)</td></tr>
<tr class="memdesc:ac0f06120b963a9aeda74ee26f3595478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the status of the keyboard (pressed or not).  <a href="stm32f4__keyboard_8c.html#ac0f06120b963a9aeda74ee26f3595478">More...</a><br /></td></tr>
<tr class="separator:ac0f06120b963a9aeda74ee26f3595478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b195430e43df585ddebe86f06a2cdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a82b195430e43df585ddebe86f06a2cdc">port_keyboard_get_row_timeout_status</a> (uint8_t keyboard_id)</td></tr>
<tr class="memdesc:a82b195430e43df585ddebe86f06a2cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the column timeout flag.  <a href="stm32f4__keyboard_8c.html#a82b195430e43df585ddebe86f06a2cdc">More...</a><br /></td></tr>
<tr class="separator:a82b195430e43df585ddebe86f06a2cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae652d3e4324278a555817e5cdfc128a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#ae652d3e4324278a555817e5cdfc128a5">port_keyboard_set_row_timeout_status</a> (uint8_t keyboard_id, bool status)</td></tr>
<tr class="memdesc:ae652d3e4324278a555817e5cdfc128a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the status of the row timeout flag.  <a href="stm32f4__keyboard_8c.html#ae652d3e4324278a555817e5cdfc128a5">More...</a><br /></td></tr>
<tr class="separator:ae652d3e4324278a555817e5cdfc128a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e84e1f30a5de2c507f98f9a9972a8d0"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a5e84e1f30a5de2c507f98f9a9972a8d0">port_keyboard_get_key_value</a> (uint8_t keyboard_id)</td></tr>
<tr class="memdesc:a5e84e1f30a5de2c507f98f9a9972a8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the char representing the key pressed of a given keyboard based on its row that is being excited. This assumes that the matrix of chars is flattened (i.e., it is not a 2D array, but all rows are in a single array), thus it is necessary to calculate only one index.  <a href="stm32f4__keyboard_8c.html#a5e84e1f30a5de2c507f98f9a9972a8d0">More...</a><br /></td></tr>
<tr class="separator:a5e84e1f30a5de2c507f98f9a9972a8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a867391d4d1c6c3697569da3747946124"><td class="memItemLeft" align="right" valign="top">static GPIO_TypeDef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a867391d4d1c6c3697569da3747946124">keyboard_main_row_ports</a> []</td></tr>
<tr class="memdesc:a867391d4d1c6c3697569da3747946124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of GPIO ports for the rows of the main keyboard.  <a href="stm32f4__keyboard_8c.html#a867391d4d1c6c3697569da3747946124">More...</a><br /></td></tr>
<tr class="separator:a867391d4d1c6c3697569da3747946124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d090c1fbaca817b4239e812a2cb6e8f"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a6d090c1fbaca817b4239e812a2cb6e8f">keyboard_main_row_pins</a> []</td></tr>
<tr class="memdesc:a6d090c1fbaca817b4239e812a2cb6e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of GPIO pins for the rows of the main keyboard.  <a href="stm32f4__keyboard_8c.html#a6d090c1fbaca817b4239e812a2cb6e8f">More...</a><br /></td></tr>
<tr class="separator:a6d090c1fbaca817b4239e812a2cb6e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e31f51852dd555058ff9af04a7a111"><td class="memItemLeft" align="right" valign="top">static GPIO_TypeDef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a28e31f51852dd555058ff9af04a7a111">keyboard_main_col_ports</a> []</td></tr>
<tr class="memdesc:a28e31f51852dd555058ff9af04a7a111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of GPIO ports for the columns of the main keyboard.  <a href="stm32f4__keyboard_8c.html#a28e31f51852dd555058ff9af04a7a111">More...</a><br /></td></tr>
<tr class="separator:a28e31f51852dd555058ff9af04a7a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1258e7b149c14a7c7b4202a2f6a55f4d"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#a1258e7b149c14a7c7b4202a2f6a55f4d">keyboard_main_col_pins</a> []</td></tr>
<tr class="memdesc:a1258e7b149c14a7c7b4202a2f6a55f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of GPIO pins for the columns of the main keyboard.  <a href="stm32f4__keyboard_8c.html#a1258e7b149c14a7c7b4202a2f6a55f4d">More...</a><br /></td></tr>
<tr class="separator:a1258e7b149c14a7c7b4202a2f6a55f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69e26c4c86714f594c74601b4133ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstm32f4__keyboard__hw__t.html">stm32f4_keyboard_hw_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm32f4__keyboard_8c.html#ae69e26c4c86714f594c74601b4133ae8">keyboards_arr</a> []</td></tr>
<tr class="memdesc:ae69e26c4c86714f594c74601b4133ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of elements that represents the HW characteristics of the keyboards connected to the STM32F4 platform.  <a href="stm32f4__keyboard_8c.html#ae69e26c4c86714f594c74601b4133ae8">More...</a><br /></td></tr>
<tr class="separator:ae69e26c4c86714f594c74601b4133ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Portable functions to interact with the keyboard FSM library. All portable functions must be implemented in this file. </p>
<dl class="section author"><dt>Author</dt><dd>Sistemas Digitales II </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2026-01-01 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa3330d22a2fcd66831baa9cdef648e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3330d22a2fcd66831baa9cdef648e48">&#9670;&nbsp;</a></span>_stm32f4_keyboard_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstm32f4__keyboard__hw__t.html">stm32f4_keyboard_hw_t</a>* _stm32f4_keyboard_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keyboard struct with the given ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the keyboard struct. </dd>
<dd>
NULL If the keyboard ID is not valid. </dd></dl>

</div>
</div>
<a id="a02d1f396d821890ec121fde3292f3ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d1f396d821890ec121fde3292f3ed4">&#9670;&nbsp;</a></span>_timer_scan_column_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _timer_scan_column_config </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the timer that controls the duration of the column scanning. </p>
<p>This function configures the timer to generate an internal interrupt to control the duration of a column scanning. The duration of the column scanning is defined in the <code>PORT_KEYBOARD_MAIN_TIMEOUT_MS</code> macro. This function is called by the <code><a class="el" href="stm32f4__keyboard_8c.html#ab6d73a385387a3fc0d0a2d2ded42e5d8" title="Configure the HW specifications of a given keyboard.">port_keyboard_init()</a></code> public function to configure the timer that controls the column scanning.</p>
<p><b>Use the timer indicated in the <a href="index.html">main page</a>.</b></p>
<p><b>There are 2 ways to calculate the <code>ARR</code> and <code>PSC</code> values.</b> You can implement any of them to configure the timer duration according to the <code>PORT_KEYBOARD_MAIN_TIMEOUT_MS</code> macro. <b>Do not set the values directly!</b></p>
<p><b>Option 1. Efficient algorithm.</b> <br  />
This option is the most efficient way to calculate the <code>ARR</code> and <code>PSC</code> values. It is based on the fact that the <code>ARR</code> value is near or equal to its maximum value (65535.0). And only one update of the <code>PSC</code> is needed. This eliminates the need for a loop, which could be slow if <code>ARR</code> is much larger than 0xFFFF. <br  />
<br  />
<b>Option 2. Iterative algorithm.</b> <br  />
This option, on the other hand, starts with <code>PSC</code> equals <code>0</code> and re-computes in an iterative loop the values of <code>ARR</code> and <code>PSC</code>. ‚ö†Ô∏è <b>WARNING! This option is not recommended. You should consider that this option is much slower than the efficient algorithm and this option will make the <code>test_port_keyboard</code> take a long time to execute (several seconds up to few minutes).</b> <br  />
 </p><dl class="section warning"><dt>Warning</dt><dd>It is important to <b>work with double type numbers to avoid the loss of precision</b> when computing the temporary values of the <code>ARR</code> and <code>PSC</code> registers. The <code>math.h</code> library is included to use the <code>round()</code> function. <br  />
To store the temporary values of the <code>ARR</code> and <code>PSC</code> registers, <b>cast the result of the <code>round()</code> function to <code>uint32_t</code></b>. <br  />
<b>All the values must be represented as double in the formulas.</b> <br  />
An arbitrary example of C code: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line">...</div>
<div class="line">double sysclk_as_double = (double)<a class="code" href="stm32f4__system_8c.html#aa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>; <span class="comment">// Important to cast to double</span></div>
<div class="line"><span class="keywordtype">double</span> ms_as_double = (double)duration_ms; <span class="comment">// Important to cast to double</span></div>
<div class="line"><span class="keywordtype">double</span> what_ever_value = (sysclk_as_double / ms_as_double) + 1.0; <span class="comment">// Important to use 1.0 instead of 1!!! This formula is just an example!!!</span></div>
<div class="line">TIMx-&gt;ARR = (uint32_t)(round(what_ever_value)); <span class="comment">// Important to round before casting to uint32_t</span></div>
</div><!-- fragment --></dd></dl>
<blockquote class="doxtable">
<p><b>TODO alumnos:</b></p>
<p>‚úÖ 1. Enable the clock of the timer that controls the column scanning. Check the reference manual of the STM32F4 to know if the timer is connected to the APB1 or APB2 bus (i.e. <code>RCC-&gt;APB1ENR</code> or <code>RCC-&gt;APB2ENR</code>). <br  />
‚úÖ 2. Disable the counter of the timer (register <code>CR1</code> of the timer) because we want to configure it. <br  />
‚úÖ 3. Enable the autoreload preload (bit <code>ARPE</code> of the register <code>CR1</code>) to enable the autoreload register. <br  />
‚úÖ 4. Set the counter of the timer to 0 (register <code>CNT</code>) to start counting from 0. <br  />
‚úÖ 5. Compute the prescaler and the auto-reload register to set the duration of the timer interrupt. The duration is defined in the <code>PORT_KEYBOARD_MAIN_TIMEOUT_MS</code> macro. Use any of the two options to calculate the <code>ARR</code> and <code>PSC</code> values:</p>
<p><b>Option 1. Efficient algorithm.</b> <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6a</b>. Convert <code>SystemCoreClock</code> to double and store them in local variables. This is to ensure that the subsequent calculations are performed in floating-point arithmetic. <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6b</b>. Compute an initial value for the <code>PSC</code> register considering the maximum value of <code>ARR</code> (65535.0). Store it in a local variable of type <code>double</code>. <br  />
&#160;&#160;&#160;&#160;üí° Use all variable and numbers as <code>double</code> (i.e., use 1.0 instead of 1). <br  />
&#160;&#160;&#160;&#160;üí° Use the function <code>round()</code> from the <code>math.h</code> library to round the value of the <code>PSC</code>. Use round instead of casting to <code>double</code>, because casting trunks the decimal value. <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6c</b>. Re-compute the value of the <code>ARR</code> register with the previously computed <code>PSC</code> value. Store it in a local variable of type <code>double</code>. <br  />
&#160;&#160;&#160;&#160;üí° This would make <code>ARR</code> less than or equal to 65535.0, and we will adjust <code>ARR</code> and <code>PSC</code> if necessary. This eliminates the need for a loop, which could be slow if <code>ARR</code> is much larger than 0xFFFF. <br  />
&#160;&#160;&#160;&#160;üí° Use the function <code>round()</code> to round the value of the <code>ARR</code>. <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6d</b>. Check if the new value of <code>ARR</code> is greater than 0xFFFF (or 65535.0). If it is, increment <code>PSC</code> by 1.0 and recalculate <code>ARR</code>. This is to ensure that <code>ARR</code> does not exceed 0xFFFF. <br  />
&#160;&#160;&#160;&#160;üí° Because the re-computed value of <code>ARR</code> will be close to its maximum, adding 1.0 to the <code>PSC</code> is enough to ensure that the <code>ARR</code> does not exceeds it maximum value and we do not need to iterate over it, making this algorithm faster than using a <code>while(){}</code> loop. <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6e</b>. Continue in ‚úÖ 7. <br  />
<br  />
<br  />
<b>Option 2. Iterative algorithm.</b> <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6a</b>. Convert <code>SystemCoreClock</code> to double and store them in local variables. This is to ensure that the subsequent calculations are performed in floating-point arithmetic. <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6b</b>. Compute an initial value for the <code>ARR</code> register considering a minimum value of <code>PSC</code> (0.0). Store it in a local variable of type <code>double</code>. <br  />
&#160;&#160;&#160;&#160;&#160;&#160;üí° Use all variable and numbers as <code>double</code> (i.e., use 1.0 instead of 1). <br  />
&#160;&#160;&#160;&#160;&#160;&#160;üí° Use the function <code>round()</code> from the <code>math.h</code> library to round the value of the <code>ARR</code>. Use round instead of casting to <code>double</code>, because casting trunks the decimal value. <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6c</b>. If the value of <code>ARR</code> is greater than 0xFFFF (or 65535.0), increment the <code>PSC</code> by 1.0 and recalculate <code>ARR</code>. This is to ensure that <code>ARR</code> does not exceed 0xFFFF. <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6d</b>. Do this in an iterative <code>while(){}</code> loop. <br  />
&#160;&#160;&#160;&#160; ‚û°Ô∏è <b>6e</b>. Continue in ‚úÖ 7. <br  />
<br  />
‚úÖ 6. Load the values computed for <code>ARR</code> and <code>PSC</code> into the corresponding registers of the timer. <br  />
&#160;&#160;&#160;&#160;üí° Ensure that values are rounded before casting. <br  />
‚úÖ 7. The <code>PSC</code> and <code>ARR</code> values are currently in the preload registers. To load them into the active registers we need an update event. We achieve this by setting the <code>UG</code> bit of the <code>EGR</code> register. It is important to do this at the end of the configuration of the timer. <br  />
‚úÖ 8. Clear the update interrupt flag (bit <code>UIF</code> of the register <code>SR</code>) to avoid an unwanted interrupt. <br  />
‚úÖ 9. Enable the interrupts of the timer by setting the <code>UIE</code> bit of the <code>DIER</code> register. <br  />
‚úÖ 10. Set the priority of the timer interrupt in the NVIC using the <code>NVIC_SetPriority()</code> function and the <code>TIMx_IRQn</code> interrupt with the level of priority and sub-priority shown in the <a href="index.html">main page</a>. <br  />
</p>
</blockquote>
<dl class="section note"><dt>Note</dt><dd>Do not enable the timer yet. This will be done when the column scanning must start. </dd></dl>

</div>
</div>
<a id="a76ff0a28d6cad5c0b67c4bc2f37cc2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ff0a28d6cad5c0b67c4bc2f37cc2d2">&#9670;&nbsp;</a></span>port_keyboard_excite_next_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void port_keyboard_excite_next_row </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the row to be excited. </p>
<blockquote class="doxtable">
<p>‚úÖ 1. Update the <code>current_excited_row</code> to move to the next row. If the index equals or greater than the number of rows <b>indicated in the layout</b>, move to the first row. <br  />
&#160;&#160;&#160;&#160;üí° You can use the <code>%</code> (modulo) operator to get the remainder of the division <br  />
‚úÖ 2. Call the function <code>port_keyboard_excite_row()</code> to excite the new row. <br  />
</p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID. This index is used to get the correct keyboard status struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9d95c098d9ce87863ae191c65246830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d95c098d9ce87863ae191c65246830">&#9670;&nbsp;</a></span>port_keyboard_get_key_pressed_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool port_keyboard_get_key_pressed_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the keyboard (pressed or not). </p>
<blockquote class="doxtable">
<p><b>TODO alumnos:</b></p>
<p>‚úÖ 1. Return the value of the field <code>flag_key_pressed</code>. Call the function <code><a class="el" href="stm32f4__keyboard_8c.html#aa3330d22a2fcd66831baa9cdef648e48" title="Get the keyboard struct with the given ID.">_stm32f4_keyboard_get()</a></code> to get the keyboard struct. <br  />
</p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID. This index is used to get the correct keyboard status struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the keyboard has been pressed </dd>
<dd>
false If the keyboard has not been pressed </dd></dl>

</div>
</div>
<a id="a5e84e1f30a5de2c507f98f9a9972a8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e84e1f30a5de2c507f98f9a9972a8d0">&#9670;&nbsp;</a></span>port_keyboard_get_key_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char port_keyboard_get_key_value </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the char representing the key pressed of a given keyboard based on its row that is being excited. This assumes that the matrix of chars is flattened (i.e., it is not a 2D array, but all rows are in a single array), thus it is necessary to calculate only one index. </p>
<blockquote class="doxtable">
<p>‚úÖ 1. Determine the value (char) of the key pressed based on the index of the current scanned row and the index of the column that provoked the interrupt, and return it. <br  />
&#160;&#160;&#160;&#160;üí° You can calculate the key index as: <code>key index = (excited row * num columns) + column interrupting</code>. <br  />
</p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID. This index is used to get the correct keyboard status struct. </td></tr>
    <tr><td class="paramname">row_index</td><td>Index of the row being excited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char Key value of the key pressed. </dd></dl>

</div>
</div>
<a id="a82b195430e43df585ddebe86f06a2cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b195430e43df585ddebe86f06a2cdc">&#9670;&nbsp;</a></span>port_keyboard_get_row_timeout_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool port_keyboard_get_row_timeout_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the column timeout flag. </p>
<blockquote class="doxtable">
<p><b>TODO alumnos:</b></p>
<p>‚úÖ 1. Return the value of the field <code>flag_row_timeout</code>. Call the function <code><a class="el" href="stm32f4__keyboard_8c.html#aa3330d22a2fcd66831baa9cdef648e48" title="Get the keyboard struct with the given ID.">_stm32f4_keyboard_get()</a></code> to get the keyboard struct. <br  />
</p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID. This index is used to get the correct keyboard status struct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the column timeout has occurred </dd>
<dd>
false If the column timeout has not occurred </dd></dl>

</div>
</div>
<a id="ab6d73a385387a3fc0d0a2d2ded42e5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d73a385387a3fc0d0a2d2ded42e5d8">&#9670;&nbsp;</a></span>port_keyboard_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void port_keyboard_init </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the HW specifications of a given keyboard. </p>
<p>Assuming we are using an STM32F4-based platform, this function must call the following functions:</p>
<blockquote class="doxtable">
<p><b>TODO alumnos:</b></p>
<p>‚úÖ 1. Retrieve the keyboard configuration struct calling <code><a class="el" href="stm32f4__keyboard_8c.html#aa3330d22a2fcd66831baa9cdef648e48" title="Get the keyboard struct with the given ID.">_stm32f4_keyboard_get()</a></code> <br  />
‚úÖ 2. Call function <code><a class="el" href="stm32f4__system_8h.html#aca348a9998b93751c1440d62050b7d79" title="Configure the mode and pull of a GPIO.">stm32f4_system_gpio_config()</a></code> with the right arguments to configure the rows as outputs with no pull up neither pull down connections (you can get the number of rows from the keyboard's layout). <br  />
‚úÖ 3. Call function <code><a class="el" href="stm32f4__system_8h.html#aca348a9998b93751c1440d62050b7d79" title="Configure the mode and pull of a GPIO.">stm32f4_system_gpio_config()</a></code> with the right arguments to configure the columns as inputs with pull down connections. Call also function <code><a class="el" href="stm32f4__system_8h.html#a98f4105a82f32c645f0b06424af5ef22" title="Configure the external interruption or event of a GPIO.">stm32f4_system_gpio_config_exti()</a></code> with the right parameters to to configure interruption mode in rising edge and enabling the interrupt line for each column. Finally, call function <code><a class="el" href="stm32f4__system_8h.html#a03d8c69cd44964e3f1ff05a2c79626b8" title="Enable interrupts of a GPIO line (pin).">stm32f4_system_gpio_exti_enable()</a></code> with priority level to <code>1</code> and the subpriority level to <code>1</code> for all columns. All keyboards will have the same priority levels for their columns in the basic implementation. You can get the number of columns from the keyboard's layout. <br  />
‚úÖ 4. Clean/set all the fields of the keyboard struct to their initial values. Set the value of <code>current_excited_row</code> to <code>-1</code> to indicate that no row is being excited at the beginning. <br  />
‚úÖ 5. Configure the timer that controls the duration of the column scanning by calling the function <code><a class="el" href="stm32f4__keyboard_8c.html#a02d1f396d821890ec121fde3292f3ed4" title="Configure the timer that controls the duration of the column scanning.">_timer_scan_column_config()</a></code> <br  />
</p>
</blockquote>
<blockquote class="doxtable">
<p>&#160;&#160;&#160;&#160;üí° If any of the IRQs associated with the EXTI lines of the columns coincides with other IRQs in the system, the priority levels of this IRQ will be equal to the priority levels of the other peripheral. <br  />
</p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID. This index is used to select the element of the <code>keyboards_arr[]</code> array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0f06120b963a9aeda74ee26f3595478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f06120b963a9aeda74ee26f3595478">&#9670;&nbsp;</a></span>port_keyboard_set_key_pressed_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void port_keyboard_set_key_pressed_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the status of the keyboard (pressed or not). </p>
<p>This function is used to update the status of the keyboard when a key press is detected or cleared.</p>
<blockquote class="doxtable">
<p><b>TODO alumnos:</b></p>
<p>‚úÖ 1. Set the value of the field <code>flag_key_pressed</code> to the given status. Call the function <code><a class="el" href="stm32f4__keyboard_8c.html#aa3330d22a2fcd66831baa9cdef648e48" title="Get the keyboard struct with the given ID.">_stm32f4_keyboard_get()</a></code> to get the keyboard struct. <br  />
 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td></td></tr>
    <tr><td class="paramname">status</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae652d3e4324278a555817e5cdfc128a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae652d3e4324278a555817e5cdfc128a5">&#9670;&nbsp;</a></span>port_keyboard_set_row_timeout_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void port_keyboard_set_row_timeout_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the status of the row timeout flag. </p>
<p>This function is used to update the status of the row timeout flag when a timeout occurs or is cleared.</p>
<blockquote class="doxtable">
<p><b>TODO alumnos:</b></p>
<p>‚úÖ 1. Set the value of the field <code>flag_row_timeout</code> to the given status. Call the function <code><a class="el" href="stm32f4__keyboard_8c.html#aa3330d22a2fcd66831baa9cdef648e48" title="Get the keyboard struct with the given ID.">_stm32f4_keyboard_get()</a></code> to get the keyboard struct. <br  />
 </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID. This index is used to get the correct keyboard status struct. </td></tr>
    <tr><td class="paramname">status</td><td>New status of the row timeout flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1320216867d7f6b27a77b4a597243b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1320216867d7f6b27a77b4a597243b95">&#9670;&nbsp;</a></span>port_keyboard_start_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void port_keyboard_start_scan </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the scanning of a keyboard. </p>
<p>This function starts the scanning of a keyboard by enabling the timer that controls the duration of the column scanning and setting the first row to HIGH.</p>
<blockquote class="doxtable">
<p><b>TODO alumnos:</b></p>
<p>‚úÖ 1. Reset the <code>flag_row_timeout</code> to indicate that a new scan is starting. <br  />
‚úÖ 2. Reset the counter (<code>CNT</code>) of the timer. <br  />
‚úÖ 3. Set the first row to be excited to HIGH and the others to LOW. You must use the appropiate function to do it. <br  />
‚úÖ 4. Enable the timer interrupt in the NVIC using the <code>NVIC_EnableIRQ()</code> function and the <code>TIMx_IRQn</code> interrupt. ‚úÖ 5. Enable the counter of the timer (register <code>CR1</code> of the timer) to start the column scanning. <br  />
</p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID. This index is used to get the correct keyboard status struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad52eeaf12ebfbd2faf6c944fc4f69600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52eeaf12ebfbd2faf6c944fc4f69600">&#9670;&nbsp;</a></span>port_keyboard_stop_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void port_keyboard_stop_scan </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyboard_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the scanning of a keyboard. </p>
<blockquote class="doxtable">
<p><b>TODO alumnos:</b></p>
<p>‚úÖ 1. Disable the counter of the timer (register <code>CR1</code> of the timer) to stop the column scanning. <br  />
‚úÖ 2. Disable the timer interrupt in the NVIC using the <code>NVIC_DisableIRQ()</code> function and the <code>TIMx_IRQn</code> interrupt. <br  />
‚úÖ 3. Set all rows to LOW. <br  />
</p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyboard_id</td><td>Keyboard ID. This index is used to get the correct keyboard status struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1258e7b149c14a7c7b4202a2f6a55f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1258e7b149c14a7c7b4202a2f6a55f4d">&#9670;&nbsp;</a></span>keyboard_main_col_pins</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t keyboard_main_col_pins[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a470a8700cbdd9473ded8b453e125454d">STM32F4_KEYBOARD_MAIN_COL_0_PIN</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a932e8e15c376a3ecc765445ebc3c26ab">STM32F4_KEYBOARD_MAIN_COL_1_PIN</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#aac5c2666d1dc0895ccbc019e23ebaebd">STM32F4_KEYBOARD_MAIN_COL_2_PIN</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a1056c8cbb8728b7dba2416a6b2154ad3">STM32F4_KEYBOARD_MAIN_COL_3_PIN</a>}</div>
</div><!-- fragment -->
<p>Array of GPIO pins for the columns of the main keyboard. </p>

</div>
</div>
<a id="a28e31f51852dd555058ff9af04a7a111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e31f51852dd555058ff9af04a7a111">&#9670;&nbsp;</a></span>keyboard_main_col_ports</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GPIO_TypeDef* keyboard_main_col_ports[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a5fa1fb8626dde306d79c143d23c1089e">STM32F4_KEYBOARD_MAIN_COL_0_GPIO</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a055991203fdd12c2924eec68c9e27c23">STM32F4_KEYBOARD_MAIN_COL_1_GPIO</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a2c9d1e2b8b2c2cc6547e72945b2ca946">STM32F4_KEYBOARD_MAIN_COL_2_GPIO</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a2d0e96f7db06fbc300556a8a587eebae">STM32F4_KEYBOARD_MAIN_COL_3_GPIO</a>}</div>
</div><!-- fragment -->
<p>Array of GPIO ports for the columns of the main keyboard. </p>

</div>
</div>
<a id="a6d090c1fbaca817b4239e812a2cb6e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d090c1fbaca817b4239e812a2cb6e8f">&#9670;&nbsp;</a></span>keyboard_main_row_pins</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t keyboard_main_row_pins[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a84fcb94f5d767a0b7fd845c21c7216ef">STM32F4_KEYBOARD_MAIN_ROW_0_PIN</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#ab154fd20cfa77e41761799138b0c6658">STM32F4_KEYBOARD_MAIN_ROW_1_PIN</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a5ddb2b1941518216b16ab05f9ca00349">STM32F4_KEYBOARD_MAIN_ROW_2_PIN</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a2d5de9853e674201e15f1bd5271daa6a">STM32F4_KEYBOARD_MAIN_ROW_3_PIN</a>}</div>
</div><!-- fragment -->
<p>Array of GPIO pins for the rows of the main keyboard. </p>

</div>
</div>
<a id="a867391d4d1c6c3697569da3747946124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867391d4d1c6c3697569da3747946124">&#9670;&nbsp;</a></span>keyboard_main_row_ports</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GPIO_TypeDef* keyboard_main_row_ports[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#aaae86db53324491f20e653c9c5acf360">STM32F4_KEYBOARD_MAIN_ROW_0_GPIO</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#af9abbd76c67f29af39b4d73ed6521411">STM32F4_KEYBOARD_MAIN_ROW_1_GPIO</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a75431188721594178ae08f8c1f4ea653">STM32F4_KEYBOARD_MAIN_ROW_2_GPIO</a>,</div>
<div class="line">    <a class="code" href="stm32f4__keyboard_8h.html#a194c7817867399ac8a6803147da6cfec">STM32F4_KEYBOARD_MAIN_ROW_3_GPIO</a>}</div>
</div><!-- fragment -->
<p>Array of GPIO ports for the rows of the main keyboard. </p>

</div>
</div>
<a id="ae69e26c4c86714f594c74601b4133ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69e26c4c86714f594c74601b4133ae8">&#9670;&nbsp;</a></span>keyboards_arr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstm32f4__keyboard__hw__t.html">stm32f4_keyboard_hw_t</a> keyboards_arr[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of elements that represents the HW characteristics of the keyboards connected to the STM32F4 platform. </p>
<p>Array of elements that represents the HW characteristics of the keyboards.</p>
<p>This is an <b>extern</b> variable that is declared in <code><a class="el" href="stm32f4__keyboard_8h.html" title="Header for stm32f4_keyboard.c file.">stm32f4_keyboard.h</a></code>. It represents an array of hardware keyboards. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astm32f4__keyboard_8h_html_a932e8e15c376a3ecc765445ebc3c26ab"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a932e8e15c376a3ecc765445ebc3c26ab">STM32F4_KEYBOARD_MAIN_COL_1_PIN</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_COL_1_PIN</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:35</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a2d5de9853e674201e15f1bd5271daa6a"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a2d5de9853e674201e15f1bd5271daa6a">STM32F4_KEYBOARD_MAIN_ROW_3_PIN</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_ROW_3_PIN</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:29</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a055991203fdd12c2924eec68c9e27c23"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a055991203fdd12c2924eec68c9e27c23">STM32F4_KEYBOARD_MAIN_COL_1_GPIO</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_COL_1_GPIO</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:34</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_aaae86db53324491f20e653c9c5acf360"><div class="ttname"><a href="stm32f4__keyboard_8h.html#aaae86db53324491f20e653c9c5acf360">STM32F4_KEYBOARD_MAIN_ROW_0_GPIO</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_ROW_0_GPIO</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:22</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_ab154fd20cfa77e41761799138b0c6658"><div class="ttname"><a href="stm32f4__keyboard_8h.html#ab154fd20cfa77e41761799138b0c6658">STM32F4_KEYBOARD_MAIN_ROW_1_PIN</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_ROW_1_PIN</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:25</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a2c9d1e2b8b2c2cc6547e72945b2ca946"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a2c9d1e2b8b2c2cc6547e72945b2ca946">STM32F4_KEYBOARD_MAIN_COL_2_GPIO</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_COL_2_GPIO</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:36</div></div>
<div class="ttc" id="astm32f4__system_8c_html_aa3cd3e43291e81e795d642b79b6088e6"><div class="ttname"><a href="stm32f4__system_8c.html#aa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a></div><div class="ttdeci">uint32_t SystemCoreClock</div><div class="ttdef"><b>Definition:</b> stm32f4_system.c:39</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_af9abbd76c67f29af39b4d73ed6521411"><div class="ttname"><a href="stm32f4__keyboard_8h.html#af9abbd76c67f29af39b4d73ed6521411">STM32F4_KEYBOARD_MAIN_ROW_1_GPIO</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_ROW_1_GPIO</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:24</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a5fa1fb8626dde306d79c143d23c1089e"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a5fa1fb8626dde306d79c143d23c1089e">STM32F4_KEYBOARD_MAIN_COL_0_GPIO</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_COL_0_GPIO</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:32</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a84fcb94f5d767a0b7fd845c21c7216ef"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a84fcb94f5d767a0b7fd845c21c7216ef">STM32F4_KEYBOARD_MAIN_ROW_0_PIN</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_ROW_0_PIN</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:23</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a470a8700cbdd9473ded8b453e125454d"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a470a8700cbdd9473ded8b453e125454d">STM32F4_KEYBOARD_MAIN_COL_0_PIN</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_COL_0_PIN</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:33</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a5ddb2b1941518216b16ab05f9ca00349"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a5ddb2b1941518216b16ab05f9ca00349">STM32F4_KEYBOARD_MAIN_ROW_2_PIN</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_ROW_2_PIN</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:27</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a194c7817867399ac8a6803147da6cfec"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a194c7817867399ac8a6803147da6cfec">STM32F4_KEYBOARD_MAIN_ROW_3_GPIO</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_ROW_3_GPIO</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:28</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_aac5c2666d1dc0895ccbc019e23ebaebd"><div class="ttname"><a href="stm32f4__keyboard_8h.html#aac5c2666d1dc0895ccbc019e23ebaebd">STM32F4_KEYBOARD_MAIN_COL_2_PIN</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_COL_2_PIN</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:37</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a2d0e96f7db06fbc300556a8a587eebae"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a2d0e96f7db06fbc300556a8a587eebae">STM32F4_KEYBOARD_MAIN_COL_3_GPIO</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_COL_3_GPIO</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:38</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a1056c8cbb8728b7dba2416a6b2154ad3"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a1056c8cbb8728b7dba2416a6b2154ad3">STM32F4_KEYBOARD_MAIN_COL_3_PIN</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_COL_3_PIN</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:39</div></div>
<div class="ttc" id="astm32f4__keyboard_8h_html_a75431188721594178ae08f8c1f4ea653"><div class="ttname"><a href="stm32f4__keyboard_8h.html#a75431188721594178ae08f8c1f4ea653">STM32F4_KEYBOARD_MAIN_ROW_2_GPIO</a></div><div class="ttdeci">#define STM32F4_KEYBOARD_MAIN_ROW_2_GPIO</div><div class="ttdef"><b>Definition:</b> stm32f4_keyboard.h:26</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_651562d8bf6cfd3e81eff5b570d7df50.html">port</a></li><li class="navelem"><a class="el" href="dir_aff93352f483d815f4aad2ce8569e33b.html">stm32f4</a></li><li class="navelem"><a class="el" href="dir_96ea3e7ce74ccff9e7229beeb516906f.html">src</a></li><li class="navelem"><a class="el" href="stm32f4__keyboard_8c.html">stm32f4_keyboard.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
