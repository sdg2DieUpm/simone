{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Portada","text":"<p>Simone Un juego de memoria visual y velocidad Reinventando el cl\u00e1sico juego Simon</p> <p>Sistemas Digitales II Grado en Ingenier\u00eda de Tecnolog\u00edas y Servicios de Telecomunicaci\u00f3n Curso 2024-2025</p> <p>Profesores: Josu\u00e9 Pag\u00e1n Ortiz (coordinador docente) j.pagan@upm.es, Manuel Gil Mart\u00edn (coordinador administrativo) manuel.gilmartin@upm.es, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Amadeo de Gracia Herranz, Ra\u00fal Izquierdo L\u00f3pez, Juan Antonio L\u00f3pez Mart\u00edn</p> <p>Colaboradores docentes: \u00c1lvaro Basterra Garc\u00eda, Sergio Esteban Romero, Ignacio Hern\u00e1ndez Abad, Iv\u00e1n Mart\u00edn Fern\u00e1ndez</p> <p>Departamento de Ingenier\u00eda Electr\u00f3nica</p>"},{"location":"notebook/acronimos.html","title":"Acr\u00f3nimos","text":"Acr\u00f3nimo Definici\u00f3n ADC Anolog-Digital Converter (Conversor Anal\u00f3gico-Digital) AHB Advanced High-performance Bus (Bus Avanzado de Alto rendimiento) APB Advanced Peripheral Bus (Bus Avanzado de Perif\u00e9ricos) API Application Programming Interface (Interfaz de Programaci\u00f3n de Aplicaciones) ARM Advanced RISC Machine ASCII American Standard Code for Information Interchange, C\u00f3digo Estadounidense Est\u00e1ndar para el Intercambio de Informaci\u00f3n BSP Board Support Package (Paquete de Soporte de Placa) BOM Bill Of Materials (Lista De Materiales) CAN Controller Area Network CELT Circuitos Electr\u00f3nicos CISC Complex Instruction Set Computer (Computador con Conjunto de Instrucciones Complejo) CMSIS Common Microcontroller Software Interface Standard CPU Central Processing Unit (Unidad Central de Procesamiento) DAC Digital-Anolog Converter (Conversor Digital-Anal\u00f3gico) DIY Do It Yourself (Hazlo T\u00fa Mismo) DMA Direct Memory Access (Acceso Directo a Memoria) DSP Digital Signal Processor (Procesador de Se\u00f1ales Digitales) EXTI External Interrupt/~Event Controller (Controlador de Interrupciones Externas) FSM Finite State Machine (M\u00e1quina de Estados Finitos) FPU Floating Point Unit (Unidad de Punto Flotante) FW Firmware GCC GNU Compiler Collection GDB GNU Debugger GPIO General Purpose Input/Output (Entrada/Salida de Prop\u00f3sito General) HAL Hardware Abstraction Layer (Capa de Abstracci\u00f3n Hardware) HSE High Speed External clock HSI High Speed Internal clock HW Hardware IDE Integrated Development Environment (Entorno de Desarrollo Integrado) I2C Inter-Integrated Circuit IoT Internet of Things ISA Instruction Set Architecture ISEL Ingenier\u00eda de Sistemas Electr\u00f3nicos ISR Interrupt Service Routine (Rutina de Servicio/Atenci\u00f3n a la Interrupci\u00f3n) ITM Instrumentation Trace Macrocell JTAG Joint Test Action Group GDB GNU Debugger LCD Liquid-Crystal RGB light (Pantalla de Cristal L\u00edquido) LED Light-Emitting Diode (Diodo Emisor de Luz) MCU Microcontroller Unit (Unidad de Microcontrolador) NEC Nippon Electric Company NVIC Nested Vectored Interrupt Controller (Controlador de Vector de Interrupciones Anidadas) PAC Peripheral Access Controller (Controlador de Acceso a Perif\u00e9ricos) PC Personal Computer (Ordenador Personal) PCB Printed Circuit Board (Placa de Circuito Impreso) PDE Pulse Intensity Encoding (Codificaci\u00f3n por Distancia de Pulsos) PLL Phase Locked Loop PWM Pulse Width Modulation (Modulaci\u00f3n de Ancho de Pulso) RCC Reset and Clock Controller (Controlador de Reinicio y Reloj) RISC Reduced Instruction Set Computer (Computador con Conjunto de Instrucciones Reducido) RFID Radio Frequency Identification (Identificaci\u00f3n por Radiofrecuencia) RTC Real Time Clock (Reloj de Tiempo Real) RTOS Real Time Operating System (Sistema Operativo de Tiempo Real) SADQ Sistemas de Adquisici\u00f3n de Datos SDG1 Sistemas Digitales I SDG2 Sistemas Digitales II SECO Sistemas Electr\u00f3nicos de Control SEIOT Sistemas Electr\u00f3nicos para IoT SoC System on Chip SPI Serial Peripheral Interface SRAM Static Random Access Memory ST STMicroelectronics SW Software SVD System View Description SWD JTAG/serial Wire Debugging Software TBD To Be Defined, Por Definir UML Unified Modeling Language, Lenguaje Unificado de Modelado USB Universal Serial Bus XML Extensible Markup Language"},{"location":"notebook/bom.html","title":"Lista de materiales (BOM)","text":"<p>En los enlaces podr\u00e9is encontrar algunos suministradores y tener acceso a las hojas de caracter\u00edsticas (datasheets) de los componentes.</p> Materiales del proyecto Simone agrupados por partida."},{"location":"notebook/intro.html","title":"Introducci\u00f3n","text":"<p>En este cap\u00edtulo se presenta una introducci\u00f3n a la asignatura de laboratorio SDG2, y la descripci\u00f3n general del proyecto de la asignatura y la organizaci\u00f3n de este. Aqu\u00ed se podr\u00e1 encontrar informaci\u00f3n sobre la evaluaci\u00f3n y el calendario que se seguir\u00e1.</p>"},{"location":"notebook/intro.html#sistemas-digitales-ii","title":"Sistemas Digitales II","text":"<p>La asignatura se imparte con una metodolog\u00eda de Aprendizaje Basado en Proyectos <sup>2</sup>. Los alumnos tienen como objetivo realizar el desarrollo de un sistema electr\u00f3nico empotrado complejo basado en un microcontrolador de bajas prestaciones partiendo de una descripci\u00f3n y unas especificaciones b\u00e1sicas. Este aprendizaje requiere por tu parte el manejo de distintas fuentes de informaci\u00f3n y disciplinas necesarias para resolver problemas. Tu papel ha de ser activo, con un compromiso y responsabilidad por tu propio aprendizaje. Trabajar\u00e1s en parejas desde el principio y desarrollar\u00e1s un proyecto planificando la actuaci\u00f3n, distribuyendo las tareas, evaluando las posibles consecuencias, y previendo los \u00e9xitos.</p> <p>Como indica la Gu\u00eda de Aprendizaje Basado en Proyectos del Servicio de Innovaci\u00f3n Educativa-UPM\u00a0<sup>2</sup>, y a modo de resumen, las caracter\u00edsticas m\u00e1s relevantes a las que debe atender son (recuperado de la Gu\u00eda de Aprendizaje de la asignatura):</p> <ul> <li> <p>No existe una \u00fanica soluci\u00f3n correcta.</p> </li> <li> <p>Se presenta la situaci\u00f3n y los alumnos tienen que ampliar la informaci\u00f3n para avanzar en el proyecto.</p> </li> <li> <p>El papel del profesor es supervisar y revisar el plan de trabajo y evoluci\u00f3n de cada pareja, utilizando las clases de laboratorio y las tutor\u00edas para ayudar a resolver dudas. El profesor tiene tambi\u00e9n el papel de evaluar el progreso y trabajo final.</p> </li> <li> <p>La interacci\u00f3n con el alumno se da en las sesiones de laboratorio: orientaci\u00f3n a las dudas y problemas encontrados para seguir el progreso de los estudiantes para evitar equivocaciones, corregir errores conceptuales y orientar el aprendizaje. Se realiza un seguimiento de cada pareja. Tambi\u00e9n en las tutor\u00edas.</p> </li> <li> <p>El lugar de trabajo es el laboratorio y fuera de este.</p> </li> </ul> <p>Note</p> <p>El proyecto no se puede completar solo con las sesiones de laboratorio sin un trabajo de b\u00fasqueda de informaci\u00f3n previa y de trabajo fuera del horario de clase. 3 ECTS son unas 81 horas de esfuerzo. El laboratorio son solo \\(28\\) (un \\(35\\%\\)), por lo que en casa ha de trabajar tanto o m\u00e1s que las horas de laboratorio <sup>3</sup>.</p> <p>Las sesiones de laboratorio plantean al alumno ir consiguiendo hitos que corresponder\u00e1n a ciertos niveles de desarrollo (funcionalidad) del proyecto. El proyecto propuesto se divide en 4 versiones b\u00e1sicas m\u00e1s una versi\u00f3n final de libre elecci\u00f3n. Las versiones b\u00e1sicas son requisitos de funcionalidad obligatorios, pero para completar el proyecto y conseguir la m\u00e1xima nota las parejas deber\u00e1n implementar la versi\u00f3n final de libre elecci\u00f3n.</p> <p>IMPORTANTE</p> <p>Las sesiones de laboratorio NO SON COMO LAS DE OTRAS ASIGNATURAS DE LABORATORIO en las que cada d\u00eda es una pr\u00e1ctica tem\u00e1tica. En SDG2 t\u00fa gestionas tu tiempo dentro y fuera del laboratorio. Existe un objetivo final organizado por fases y, siendo proactivo, debes prever y prepararte para el trabajo que va a hacer cada d\u00eda en el laboratorio. Aunque existe un calendario orientativo, cada pareja avanzar\u00e1 a un ritmo. Los profesores estar\u00e1n para ayudar a resolver dudas que la pareja plantee sobre el problema al que se est\u00e1n enfrentando.</p> <p>Har\u00e1s frente a un caso real de dise\u00f1o e implementaci\u00f3n de un sistema electr\u00f3nico basado en microcontrolador de bajas prestaciones, empleando los medios disponibles en el laboratorio B-043 y componentes electr\u00f3nicos \u2014alguno de los cuales deber\u00e1 adquirir\u2014 (ver materiales en ).</p> <p>Como has venido trabajando en CELT, el laboratorio estar\u00e1 abierto durante \\(2h30'\\). Si se quiere hacer una analog\u00eda con las clases te\u00f3ricas, las horas con profesor son \\(2h\\) de supervisi\u00f3n puramente dicha. El resto del tiempo es para que inicies las m\u00e1quinas, prepares los montajes, y recojas ordenadamente al finalizar. El acceso al laboratorio est\u00e1 controlado por los maestros de laboratorio.</p> <p>Por las ma\u00f1anas habr\u00e1 acceso libre siempre que haya un maestro de laboratorio o persona responsable que abra el laboratorio y vigile. Se recomienda que lleves tu propio material, pues no se garantiza que la persona responsable pueda hacerse cargo de los pr\u00e9stamos.</p>"},{"location":"notebook/intro.html#el-proyecto-simone","title":"El proyecto Simone","text":"<p>El objetivo es desarrollar un sistema b\u00e1sico completamente funcional de una versi\u00f3n del cl\u00e1sico juego de memoria visual, Sim\u00f3n utilizando un teclado matricial y un LED RGB que permita al jugador identificar cada color que se represente por el LED con una tecla del teclado. A este sistema le vamos a llamar Simone. El sistema se basa en (i) una placa Nucleo-STM32F446RE\u00a0que har\u00e1 las veces de sistema central, (ii) un teclado matricial alfanum\u00e9rico de membrana, y (iii) un LED RGB\u00a0que cambia de color de forma aleatoria con cada secuencia de colores que crea el juego. Puede ver el video demostrativo en Demostraci\u00f3n del sistema Simone. Al sistema b\u00e1sico posteriormente el alumno debe a\u00f1adir m\u00e1s funcionalidades de su elecci\u00f3n.</p> <p>Para entender lo que vamos a construir, debemos viajar atr\u00e1s en el tiempo, hasta 1978, cuando el ingeniero Ralph Baer (conocido como el padre de los videojuegos) y Howard J. Morrison presentaron al mundo el juego Simon. Este dispositivo con forma de platillo volante se convirti\u00f3 en un icono de la cultura pop de los 80. Su funcionamiento era  simple: un juego de memoria visual y auditiva donde la m\u00e1quina generaba una secuencia progresiva de luces y sonidos aleatorios que el jugador deb\u00eda repetir.</p> Juego Simon original. <p>La mec\u00e1nica original consist\u00eda en cuatro grandes botones de colores (rojo, verde, azul y amarillo), cada uno asociado a un tono musical espec\u00edfico. El juego comenzaba con una secuencia de un solo paso. Si el usuario acertaba, la m\u00e1quina repet\u00eda la secuencia y a\u00f1ad\u00eda un nuevo paso al final. El juego terminaba cuando el usuario fallaba o tardaba demasiado en responder.</p> <p>En esta pr\u00e1ctica vamos a rendir homenaje a este cl\u00e1sico, pero elevando la complejidad t\u00e9cnica para adaptarla a un sistema embebido moderno basado en el STM32F446RE. Nuestro sistema, bautizado como Simone, mantiene la esencia del juego de memoria visual pero introduce diferencias significativas respecto al juguete original:</p> <ol> <li>Interfaz de entrada: En lugar de cuatro botones grandes dedicados, utilizaremos un teclado matricial (desarrollado en la Versi\u00f3n 2). Esto nos obliga a mapear teclas espec\u00edficas (<code>'1'</code>, <code>'2'</code>, ...) a colores.</li> <li>Interfaz de salida: Sustituimos las cuatro bombillas independientes por un \u00fanico LED RGB (desarrollado en la Versi\u00f3n 3). Esto implica que la secuencia no es espacial (luces en distintas posiciones), sino puramente crom\u00e1tica (el mismo punto de luz cambia de color).</li> <li>Complejidad crom\u00e1tica: El juego original usaba 4 colores. Simone gestiona una paleta de 6 colores (rojo, verde, azul y amarillo, turquesa y blanco), aumentando la dificultad de memorizaci\u00f3n.</li> <li>Niveles de dificultad din\u00e1micos: Implementaremos un sistema de niveles (<code>EASY</code>, <code>MEDIUM</code>, <code>HARD</code>) que no solo afecta a la velocidad de reproducci\u00f3n, sino tambi\u00e9n a la intensidad lum\u00ednica (PWM). En los niveles dif\u00edciles, los colores se mostrar\u00e1n m\u00e1s tenues y r\u00e1pidos, poniendo a prueba tanto la memoria como la agudeza visual del jugador.</li> <li>Feedback textual: Al carecer de altavoz en esta versi\u00f3n, utilizaremos la terminal de VSCode para enviar mensajes de estado, victoria o derrota, lo que nos servir\u00e1 como herramienta de realimentaci\u00f3n visual en tiempo real.</li> </ol> <p>El reto de este proyecto no es solo programar la l\u00f3gica del juego, sino orquestar los perif\u00e9ricos que construir\u00e9is a lo largo de las sesiones (bot\u00f3n, teclado, LED RGB) para que funcionen al un\u00edsono bajo el control de una m\u00e1quina de estados finitos (FSM) central.</p> <p>El alumno tiene la libertad de imaginar e implementar a trav\u00e9s de la Versi\u00f3n 5 del proyecto cualquier sistema que desee. Por ejemplo: a\u00f1adir un sistema de sonido, m\u00e1s teclados y LEDs, botones, un buzzer para generar sonidos, un LCD u otro RGB light,\u00a0\u2026\u00a0o incluso a\u00f1adir un sistema de comunicaci\u00f3n inal\u00e1mbrica para enviar la informaci\u00f3n a un dispositivo m\u00f3vil.</p> <p>El sistema correr\u00e1 sobre la plataforma Nucleo-STM32F446RE\u00a0(ver libro de fundamentos te\u00f3rico-pr\u00e1cticos de la asignatura\u00a0<sup>4</sup>). Ser\u00eda posible emplear otros modelos de placa Nucleo-STM32\u00a0si el modelo basado en el microcontrolador STM32F446RE\u00a0no est\u00e1 disponible (*e.g.*, el modelo STM32F411RE). En dicho caso deber\u00e1 realizar los pasos para adaptarse a la asignatura. Se deber\u00e1 comprar una placa por pareja o una por cada miembro, si lo desea (les dar\u00e1 m\u00e1s posibilidades de hacer pruebas y nuevas implementaciones m\u00e1s interesantes). Los componentes electr\u00f3nicos b\u00e1sicos se les prestan, pero se aconseja que consig\u00e1is los vuestros, sobre todo para la Versi\u00f3n 5 del proyecto. Para los primeros d\u00edas o en caso de olvido, habr\u00e1 placas de pr\u00e9stamo durante las sesiones de laboratorio.</p> <p>Para poder trabajar en tu ordenador personal deber\u00e1s tener instalado el entorno de compilaci\u00f3n cruzada siguiendo los pasos de instalaci\u00f3n del cap\u00edtulo de la \u201cGu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n cruzada en C\u201d <sup>5</sup>. Durante las sesiones de laboratorio no se resolver\u00e1n problemas de instalaci\u00f3n del entorno para no entorpecer al resto de compa\u00f1eros que tengan dudas del proyecto. Si se tienen problemas en la instalaci\u00f3n, se concertar\u00e1 una tutor\u00eda.</p>"},{"location":"notebook/intro.html#subsec:materiales","title":"Materiales","text":"<p>La lista de materiales que se usan se muestra en la BOM del anexo. En la puede verlos agrupados por cada una de las \"partidas\" del proyecto: los b\u00e1sicos, los de la sensorizaci\u00f3n, y los de actuaci\u00f3n.</p> <p>Lo m\u00e1s urgente de adquirir es la placa Nucleo-STM32F446RE\u00a0y el cable USB necesarios para la V1 y siguientes. El resto de HW se usar\u00e1 en las siguientes versiones. Durante las primeras sesiones podr\u00e1s trabajar con las placas que se prestan en el laboratorio, pero no podr\u00e1s llev\u00e1rtela. Cuando adquieras la tuya para trabajar en casa, ser\u00e1 la que debes traer.</p> <p>En el anexo se proporciona informaci\u00f3n de los componentes y un enlace para que tengas una orientaci\u00f3n de cu\u00e1l es. Puedes conseguirlos t\u00fa mismo. Muchos de dichos componentes quiz\u00e1s ya los tengas, como la protoboard, o los cables para la misma. El resto puedse conseguirlo en alguna tienda f\u00edsica de la ciudad, u online. F\u00edjate que algunos de los componentes no se venden por unidad en las tiendas online (quiz\u00e1s le convenga comprar con otros compa\u00f1eros o ir a una tienda f\u00edsica y comprarlos unitarios). Un miembro de la pareja se responsabilizar\u00e1 del material prestado, que ha de devolver en la fecha del examen.</p>"},{"location":"notebook/intro.html#organizacion-versiones","title":"Organizaci\u00f3n (versiones)","text":"<p>El desarrollo del sistema Simone est\u00e1 guiado como un tutorial, por puntos. El proyecto b\u00e1sico son los requisitos m\u00ednimos obligatorios, y suponen el \\(50\\%\\) del total de la calificaci\u00f3n de la asignatura. Un \\(20\\%\\) de la nota es la V5 (ver\u00a0Evaluaci\u00f3n y calendario).</p> <p>El proyecto b\u00e1sico lo podemos dividir en versiones o fases, a modo de gu\u00eda. Todos los c\u00f3digos deber\u00e1n estar documentados con Doxygen. Cada versi\u00f3n tiene un c\u00f3digo de test unitarios HW y SW que se les proporcionar\u00e1. Los c\u00f3digos corren sobre la placa y nos da una indicaci\u00f3n de si el sistema funciona correctamente.</p> <p>Las caracter\u00edsticas m\u00e1s importantes de cada versi\u00f3n son:</p> <ul> <li> <p>Versi\u00f3n 1: desarrollo de la base del sistema con (i) FSM, (ii) interrupci\u00f3n de bot\u00f3n para interactuar con el juego y (iii) temporizaci\u00f3n de la pulsaci\u00f3n con <code>SysTick</code> para poder iniciar y detener el juego. (iv) Por \u00faltimo, test unitarios y la documentaci\u00f3n del c\u00f3digo. (Estimado 2 semanas)</p> </li> <li> <p>Versi\u00f3n 2: desarrollo del subsistema de detecci\u00f3n de teclas del teclado matricial con (i) FSM, (ii) excitaci\u00f3n de las filas de manera alterna mediante interrupci\u00f3n de un temporizador, (iii) captura de entrada (input capture) de las columnas para detecci\u00f3n de tecla, (iii) montaje HW del teclado, y (iv) test unitarios y documentaci\u00f3n del c\u00f3digo. (Estimado 3 semanas)</p> </li> <li> <p>Versi\u00f3n 3: desarrollo del subsistema de visualizaci\u00f3n (i) FSM, (ii) interrupciones de temporizadores para generaci\u00f3n de PWM, (iii) montaje HW del LED RGB, y (iv) test unitarios y documentaci\u00f3n del c\u00f3digo. (Estimado 2-3 semanas)</p> </li> <li> <p>Versi\u00f3n 4: (i) implementaci\u00f3n de modos de bajo consumo, (ii) integraci\u00f3n de la FSM final del sistema y (iii) prueba y documentaci\u00f3n del c\u00f3digo. (Estimado 1-2 semanas)</p> </li> <li> <p>Versi\u00f3n 5: funcionalidades de libre elecci\u00f3n del alumno. (Estimado 3 semanas)</p> </li> </ul>"},{"location":"notebook/intro.html#sec:profes","title":"Profesorado y turnos de laboratorio","text":"<p>El turno que elijas para asistir al laboratorio no tiene por qu\u00e9 coincidir con el grupo de matriculaci\u00f3n. Puedes elegir el que mejor se ajuste a tu horario. El turno se elige por orden de inscripci\u00f3n en la p\u00e1gina de Moodle de la asignatura. T\u00edpicamente habr\u00e1 2-3 profesores por turno y tambi\u00e9n podremos contar con la ayuda inestimable de los colaboradores docentes que te ayudar\u00e1n en todo lo posible, aunque no tienen competencias de evaluaci\u00f3n, i.e., para consultas de gesti\u00f3n de la asignatura, mejor pregunta a un profesor del turno.</p> <p>Tradicionalmente un profesor se encarga de \"un pasillo\" del laboratorio y tiene seguimiento detallado de los alumnos de esos puestos. No obstante, siempre que sea posible se le atender\u00e1 por cualquier profesor que est\u00e9 libre.</p> <p>IMPORTANTE</p> <p>/ironic mode on/</p> <p>Ya se ha mencionado que la metodolog\u00eda es \"de Aprendizaje Basado en Proyectos\" y que el profesor est\u00e1 para resolver dudas y guiar. Sabemos que este mensaje a estas alturas de la carrera y de la vida est\u00e1 de m\u00e1s, y que t\u00fa no lo haces nunca, pero: levantar la mano y quedarse de brazos cruzados cual cliente en un bar esperando ser servido \u2014en el mejor de los casos, sino es que no se est\u00e1 viendo el \u00faltimo viral de TikTok\u2014 no es la actitud que se espera. Se lee, se prueba, se escribe, se hacen dibujos\u2026, se sacan conclusiones y, cuando se ha cavilado, si no se entiende, se pregunta con fundamento.</p> <p>/ironic mode off/</p>"},{"location":"notebook/intro.html#turnos","title":"Turnos","text":""},{"location":"notebook/intro.html#profesores-y-colaboradores-docentes","title":"Profesores y colaboradores docentes","text":"<p>Profesores</p> <ul> <li> <p>AGH, Amadeo de Gracia Herranz (C-229) e-mail: amadeo.degracia@upm.es</p> </li> <li> <p>JPO, Josu\u00e9 Pag\u00e1n Ortiz (coordinador) (C-221) e-mail: j.pagan@upm.es</p> </li> <li> <p>MGM, Manuel Gil Mart\u00edn (coord. administrativo) (B-111) e-mail: manuel.gilmartin@upm.es</p> </li> <li> <p>JALM, Juan Antonio L\u00f3pez Mart\u00edn (B-111) e-mail: juanantonio.lopez@upm.es</p> </li> <li> <p>RCR, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez (B-305) e-mail: r.cardenas@upm.es</p> </li> <li> <p>RIL, Ra\u00fal Izquierdo L\u00f3pez (C-206) e-mail: raul.izquierdo@upm.es</p> </li> </ul> <p>Colaboradores docentes</p> <ul> <li>ABG, \u00c1lvaro Basterra Garc\u00eda</li> <li>SER, Sergio Esteban Romero</li> <li>IHA, Ignacio Hern\u00e1ndez Abad</li> <li>IMF, Iv\u00e1n Mart\u00edn Fern\u00e1ndez</li> </ul> <p>Note</p> <p>El laboratorio se organiza por parejas por temas de espacio y gesti\u00f3n de recursos. Que pueda elegir un turno distinto del grupo de matriculaci\u00f3n es lo que permite que pueda elegir pareja. Si no tiene pareja, se le asignar\u00e1 una y un turno. No obstante, si el trabajo con la pareja asignada no funciona por x motivo, h\u00e1gaselo saber antes de la evaluaci\u00f3n parcial a un profesor. No queremos que el no-trabajo de un alumno afecte al rendimiento de otro. No se permiten tr\u00edos. Podr\u00e1 hacer el trabajo de forma individual. Le requerir\u00e1 m\u00e1s disciplina, pero es perfectamente abordable. Los requisitos del proyecto seguir\u00e1n siendo los mismos.</p>"},{"location":"notebook/intro.html#sec:eval","title":"Evaluaci\u00f3n y calendario","text":"<p>La asignatura tiene una componente pr\u00e1ctica muy importante. No obstante, en esta asignatura no solo se aplican conceptos aprendidos, sino que tambi\u00e9n se adquieren otros nuevos. La asignatura tiene 2 grandes bloques de evaluaci\u00f3n que se pueden liberar hasta la evaluaci\u00f3n extraordinaria del mismo curso:</p> <ol> <li> <p>Un proyecto por parejas que tiene 2 partes:</p> <ol> <li> <p>requisitos b\u00e1sicos obligatorios: versiones V1-V4. Es guiada. Supone un \\(50\\%\\) de la nota total. Las especificaciones b\u00e1sicas del proyecto son requisitos impuestos por la asignatura</p> </li> <li> <p>funcionalidades de libre elecci\u00f3n: V5. Desarrollo libre. Supone un \\(20\\%\\) de la nota total.</p> </li> </ol> <p>Las dos entregas de c\u00f3digo (y documentaci\u00f3n de la versi\u00f3n V5) se realizar\u00e1n en buzones de Moodle que se abrir\u00e1n cerca de la fecha de entrega. Solo un miembro de la pareja tiene que subir los ficheros fuente del proyecto. Si realiza implementaciones en V5 que incorporen HW nuevo, deber\u00e1 mostrar su funcionamiento el d\u00eda del examen pr\u00e1ctico individual o cuando se convenga con su profesor asignado. En todo caso, se grabar\u00e1 un v\u00eddeo breve demostrativo de las funcionalidades implementadas en V5.</p> <p>Dispone de una r\u00fabrica orientativa de evaluaci\u00f3n del proyecto en la .</p> </li> <li> <p>Un examen pr\u00e1ctico individual que tiene el fin de diferenciar el trabajo de cada uno de los miembros de la pareja. Supone el \\(30\\%\\) restante de la nota total.</p> <p>El examen consta t\u00edpicamente de 2 ejercicios. Se proporciona un proyecto adaptado del trabajado durante el curso pero m\u00e1s sencillo. Este proyecto no compila y se pide que (i) se depure y corrija, y (ii) se hagan modificaciones. Se realiza en el laboratorio con los ordenadores del mismo. Se dispone de 1 hora para realizarlo. Se puede consultar la documentaci\u00f3n que se proporciona. No se puede consultar internet. Se eval\u00faa la capacidad de depuraci\u00f3n de c\u00f3digo, la capacidad de an\u00e1lisis y resoluci\u00f3n de problemas, y la capacidad de implementaci\u00f3n de soluciones. Puede ver c\u00f3mo abordar esta prueba en estos v\u00eddeos de correcci\u00f3n de examen pr\u00e1ctico de 2023, de 2024, y de 2025.</p> </li> </ol> <p>Se recomienda el uso de repositorios privados de c\u00f3digo como GitHub o BitBucket para guardar el avance del proyecto cada semana. Tambi\u00e9n puedes usar una memoria USB. Es responsabilidad exclusiva del alumno conservar copias de las distintas versiones del proyecto y de tus avances parciales. Los ordenadores del laboratorio se borran diariamente. No obstante, estar\u00e1 abierto continuamente un buz\u00f3n en Moodle para que puedas subir copias de sus c\u00f3digos cuando quieras. Este buz\u00f3n no tiene copia de seguridad.</p> <p>Es responsabilidad de la pareja protegerse de copiar o ser copiados. Los c\u00f3digos pasan el anti-copy. Si se detecta una copia, la nota de los proyectos copia y copiado ser\u00e1 0. Sean honestos, insp\u00edrense, pregunten, pero nunca copien.</p> <p>Conviene recordar que, como indica la Gu\u00eda de Aprendizaje, cualquier evaluaci\u00f3n o entrega realizada podr\u00e1 requerir una evaluaci\u00f3n oral complementaria por parte del profesor para validar que se ha realizado por el alumno sin ayuda de sistemas de Inteligencia Artificial.</p> <p>Como sabr\u00e1, la normativa de la UPM\u00a0<sup>6</sup> distingue entre evaluaci\u00f3n progresiva y global. A continuaci\u00f3n se presentan los criterios de evaluaci\u00f3n en ambas modalidades.</p>"},{"location":"notebook/intro.html#evaluacion-progresiva","title":"Evaluaci\u00f3n progresiva","text":"<p>En esta modalidad hay dos periodos de evaluaci\u00f3n: uno a mitad de semestre y otro al final.</p> Distribuci\u00f3n de las calificaciones de la asignatura. <p>Puede ver el desglose de las calificaciones en la y el detalle de fechas de evaluaci\u00f3n en el calendario de la . En particular:</p> <ul> <li>La semana de ex\u00e1menes del GITST: L\u00cdMITE de entrega por parejas versiones V1 y V2 (\\(25\\%\\)). Solo se entrega un proyecto QUE COMPILE, hasta donde haya llegado. SI NO COMPILA, NO SE CORRIGE, Y LA NOTA ES 0. El profesor corrige con un HW id\u00e9ntico al tuyo y en la siguiente sesi\u00f3n habr\u00e1 realimentaci\u00f3n de los problemas encontrados. El c\u00f3digo debe compilar y cargar en la placa Nucleo-STM32F446RE. Esta fecha es el plazo l\u00edmite de entrega en Moodle, y establecida dentro del periodo de evaluaciones intermedias de la ETSIT. .</li> </ul> <p>ATENCI\u00d3N</p> <p>El montaje HW no es en s\u00ed mismo objeto de evaluaci\u00f3n, pero es indispensable que monte bien para que el sistema funcione seg\u00fan las especificaciones. Si sigues las pautas dadas no deber\u00eda existir ning\u00fan problema con el montaje usado por el profesor para la evaluaci\u00f3n. En caso de que detectes alg\u00fan problema o hagas alguna modificaci\u00f3n relevante, comun\u00edcaselo a tu profesor durante las sesiones de laboratorio (Los d\u0131\u0301as pr\u00f3ximos a la entrega no son una sesi\u00f3n de laboratorio. Salvo causas de fuerza mayor, claro \ud83d\ude42.).</p> <ul> <li> <p>\u00daltimo d\u00eda lectivo: L\u00cdMITE de entrega por parejas versiones V3 y V4 (\\(25\\%\\)), y V5 (\\(\\geq20\\%\\)). El profesor corrige con un HW id\u00e9ntico al tuyo. El c\u00f3digo debe compilar y cargar en la placa Nucleo-STM32F446RE. Esta fecha es el plazo l\u00edmite de entrega en Moodle.</p> <p>Hay que hacer 2 entregas separadas. Una para la parte obligatoria de requisitos m\u00ednimos V1-V4, y otra para V1-V5.</p> <p>Las funcionalidades de la V5 son de libre elecci\u00f3n por el alumno, pueden ser SW, FW, o HW. Las parejas que realicen alguna implementaci\u00f3n deber\u00e1n documentarlas y explicarlas con Doxygen y Markdown utilizando una plantilla proporcionada. Con estas modificaciones SW o montajes alternativos a\u00f1adidos al proyecto b\u00e1sico \u2014y dependiendo de su dificultad y realizaci\u00f3n\u2014 se podr\u00e1n sumar puntos hasta alcanzar la m\u00e1xima nota: 10 puntos (ver ).</p> </li> </ul> <p>Note</p> <p>Los alumnos pueden hacer tantas modificaciones como deseen y la suma de puntos podr\u0131\u0301a exceder el 10. No obstante, la calificaci\u00f3n m\u00e1xima en actas es 10, y el exceso se considera a efectos de poder otorgar Matr\u0131\u0301culas de Honor.</p> <p>ATENCI\u00d3N</p> <p>La evaluaci\u00f3n de las versiones V1-V2 no tiene nota m\u00ednima. Tampoco la tienen V3-V4, ni V5. No obstante, la suma de la nota de ambas evaluaciones del proyecto V1-V2\u00a0+\u00a0V3-V4-V5 ha de ser mayor de 5/10 para liberar el bloque \u201cproyecto\u201d, sino, quedar\u00e1 pendiente esta parte para extraordinaria.</p> <ul> <li> <p>En la fecha estipulada de ex\u00e1menes de la ETSIT: examen pr\u00e1ctico individual en el laboratorio (\\(30\\%\\)). De 1 hora de duraci\u00f3n aproximada. Se dividir\u00e1 a los alumnos en varios horarios de evaluaci\u00f3n que se har\u00e1n disponibles cuando se acerque la fecha.</p> <p>El examen consiste en depurar un c\u00f3digo dado, hacer que compile, y hacer modificaciones o peque\u00f1os desarrollos de c\u00f3digo. Se har\u00e1 con los ordenadores del laboratorio y no tendr\u00e1 acceso a internet. Se le proporcionar\u00e1 la documentaci\u00f3n de consulta necesaria. Puede ver c\u00f3mo abordar esta prueba en estos v\u00eddeos de correcci\u00f3n de examen pr\u00e1ctico de 2023, de 2024, y de 2025.</p> <p>La nota del examen ha de ser mayor de 5/10 y liberar el bloque \"examen pr\u00e1ctico\"\u201d\", sino, quedar\u00e1 pendiente esta parte para la convocatoria extraordinaria.</p> <p>En alg\u00fan momento de la jornada de evaluaci\u00f3n, este d\u00eda tambi\u00e9n (o cuando se convenga con el profesor), se realizar\u00e1 la demostraci\u00f3n de las funcionalidades HW a\u00f1adidas en V5, si las hay.</p> </li> </ul> <p>La gesti\u00f3n de los plazos tambi\u00e9n es parte del proyecto. No se aceptan proyectos despu\u00e9s de la fecha l\u00edmite. La fecha es no es la \u00fanica fecha de entrega, sino la fecha l\u00edmite. Si no es entrega en plazo, se va a convocatoria extraordinaria.</p>"},{"location":"notebook/intro.html#evaluacion-mediante-proyecto-innovador","title":"Evaluaci\u00f3n mediante proyecto innovador","text":"<p>Dentro de la evaluaci\u00f3n progresiva, aquellos alumnos que deseen realizar un proyecto innovador alternativo que se base en un problema o dise\u00f1o propio (o propuesto por un profesor), pueden hacerlo. Deber\u00e1n hablar con alguno de los profesores de la asignatura y presentarle durante la primera y segunda semana de curso una propuesta de proyecto donde describan, en 2 o 3 p\u00e1ginas:</p> <ul> <li> <p>Objetivos del sistema propuesto.</p> </li> <li> <p>Recursos necesarios para llevarlo a cabo.</p> </li> <li> <p>Arquitecturas HW y SW propuestas para abordar el problema.</p> </li> </ul> <p>Para poder abordar el proyecto ser\u00e1 necesario contar con la aprobaci\u00f3n de dicho profesor. No ser\u00e1 admitido ning\u00fan proyecto (por muy complejo o perfecto que sea) que no se ajuste a estas normas. En el canal de YouTube<sup>1</sup> de la asignatura puede ver v\u00eddeos de proyectos de alumnos en cursos pasados.</p> <p>Solo se aceptar\u00e1n 10 proyectos innovadores. Para poder evaluar las propuestas y que las parejas puedan comenzar a trabajar lo antes posible, disponen de no m\u00e1s de la segunda semana de clase para presentar la propuesta.</p> <p>El proyecto es libre, no obstante ha de cubrir los conceptos b\u00e1sicos de la asignatura con los que se eval\u00faa al resto de compa\u00f1eros:</p> <ul> <li> <p>Deber\u00e1 trabajar con</p> </li> <li> <p>una base del sistema programada en C,</p> </li> <li> <p>donde se demuestre el manejo de registros b\u00e1sicos (parte del programa escrito a bajo nivel: bare-metal),</p> </li> <li> <p>que contenga una o varias FSM, interrupciones, y temporizaci\u00f3n.</p> </li> <li> <p>Metodolog\u00eda de proyecto como la propuesta (divisi\u00f3n de c\u00f3digo en <code>COMMON</code> y <code>PORT</code>).</p> </li> <li> <p>Documentaci\u00f3n del c\u00f3digo con Doxygen.</p> </li> <li> <p>El lenguaje tipo Arduino no est\u00e1 permitido como base del sistema, aunque s\u00ed sobre elementos a\u00f1adidos (otros microcontroladores). Cubierto lo b\u00e1sico en C, puede trabajar sobre el lenguaje que quiera, sea de alto nivel, o no.</p> </li> <li> <p>Cubierto lo anterior, s\u00ed puede hacer uso de la HAL del fabricante.</p> </li> </ul> <p>Note</p> <p>Qui\u00e9n realice un proyecto innovador NO hace la evaluaci\u00f3n individual. En cambio, ha de hacer una entrega intermedia y final del c\u00f3digo y documentaci\u00f3n (mismas fechas que el proyecto est\u00e1ndar), y una demostraci\u00f3n del proyecto en una fecha a convenir a los profesores de la asignatura. En cualquier momento se pueden abandonar y engancharse a la evaluaci\u00f3n global.</p>"},{"location":"notebook/intro.html#evaluacion-global","title":"Evaluaci\u00f3n global","text":"<p>En la modalidad de evaluaci\u00f3n global se han de superar las mismas actividades que en la evaluaci\u00f3n progresiva y tienen los mismos pesos y criterios.</p> <p>El estudiante que no han hecho la entrega de V1-V2 puede optar a un \\(7.5\\), incluyendo V5, siempre que se cumplan los criterios de m\u00ednimos mencionados anteriormente.</p>"},{"location":"notebook/intro.html#insignias","title":"Insignias","text":"<p>En general, las insignias, o badges en ingl\u00e9s, se usan como reconocimiento digital cuando se realiza un curso o una actividad. Constan de una imagen y una descripci\u00f3n con el nombre y los criterios que hay que cumplir para obtenerla, como se muestra en la\u00a0. Sirven para reconocer logros a lo largo del curso. Est\u00e1n firmadas por un profesor y permite al alumno anexarla a su Curriculum Vitae, o almacenarlas en mochilas virtuales como Badgr, u OpenBadges. Puede conocer m\u00e1s sobre las insignias de Moodle UPM en el CanalTIC: Badges o insignias digitales. Puede leer m\u00e1s sobre insignias digitales en el manual \u201cInsignias digitales como acreditaci\u00f3n de competencias en la Universidad\u201d <sup>7</sup>.</p> Contenido de una insignia (\u201cOpen Badges Peeled\u201d de Bryan Mathers, con licencia CC-BY-ND License). <p>Los profesores, bajo criterio consensuado, podr\u00e1n otorgar insignias para reconocer alg\u00fan m\u00e9rito destacable en la asignatura. En concreto, se contemplan las siguientes insignias (ver\u00a0#TO-DO):</p> <ul> <li> <p>Para la evaluaci\u00f3n progresiva y global:</p> </li> <li> <p>Mejor dise\u00f1o HW: electr\u00f3nica adicional, dise\u00f1o de PCB, integraci\u00f3n con otras placas, etc.</p> </li> <li> <p>Mejor dise\u00f1o SW: funcionalidades FW o SW extras que sean significativas.</p> </li> <li> <p>Mejor dise\u00f1o de producto: entendido como un todo, se valorar\u00e1 la experiencia de usuario, acabado con impresi\u00f3n 3D, etc.</p> </li> <li> <p>Proyecto destacado: proyecto que cumple funcionalidades, tiene mejoras considerables, etc.\u00a0y a juicio de los profesores es un proyecto destacable.</p> </li> <li> <p>Para los proyecto innovadores:</p> </li> <li> <p>Todo proyecto innovador que lo merezca.</p> </li> <li> <p>El mejor proyecto innovador.</p> </li> </ul> Insignias del curso."},{"location":"notebook/intro.html#subsec:rubrica","title":"R\u00fabrica de evaluaci\u00f3n","text":"<p>Una r\u00fabrica \u201ces una herramienta de puntuaciones en la que se valora la calidad de un producto (proyecto, tarea, etc.) en base a los criterios establecidos, iguales para todos los estudiantes. Dichos criterios se presentan en distintos grados y se completan seg\u00fan sea el producto evaluado\u201d\u00a0<sup>2</sup>. No espere ver una nota detallada de cada aspecto, sino un grado de consecuci\u00f3n.</p> <p>Para cada \u201cNivel de calidad\u201d de la r\u00fabrica existen procesos intermedios que han de ser superados aunque no queden descritos como tal en la misma. No obstante es una gu\u00eda para que tenga siempre presente los objetivos de grano grueso del proyecto. El profesor puede tener mayor granularidad para evaluar parcialmente un criterio de la r\u00fabrica que no se haya logrado en su completitud. El muestra la r\u00fabrica del proyecto Simone.</p> Nivel de calidad Criterio Malo Regular Excelente V1 - Bot\u00f3n Solo FSM.                 El sistema no hace lo requerido.                               No funciona completamente. No cambia de modo. No gestiona bien los rebotes. No gestiona bien el <code>SysTick</code>.                               Pasa los test, funciona correctamente y est\u00e1 bien documentado.              V2 - Teclado Solo FSM.                 El sistema no hace lo requerido.                               No funciona completamente. No gestiona bien la excitaci\u00f3n de filas. No gestiona bien el input capture de columnas. No recoge bien las teclas.                               Pasa los test, funciona correctamente y est\u00e1 bien documentado.                               V3 - LED RGB Solo FSM.                 El sistema no hace lo requerido.                               No funciona correctamente. No gestiona bien el PWM para mostrar los colores. No se detiene cuando se le indica.                               Pasa los test, funciona correctamente y est\u00e1 bien documentado.              V4 - Bajo consumo Solo FSM completa.                 El sistema no hace lo requerido.                               No se gestionan comandos ON/OFF. No detiene <code>SysTick</code>. Solo duerme una vez o no duerme en todas las situaciones.                               Funciona correctamente y est\u00e1 bien documentado.              Cuadro 1. R\u00fabrica de evaluaci\u00f3n."},{"location":"notebook/intro.html#sec:cal","title":"Calendario","text":"<p>En la\u00a0se muestra el calendario de la asignatura. A la izquierda, los d\u00edas de la semana, se\u00f1alando los eventos m\u00e1s importantes, como las evaluaciones. A la derecha un gr\u00e1fico de colores para ver f\u00e1cilmente qu\u00e9 d\u00edas tiene clase cada turno. Orientativamente, se indica por qu\u00e9 versi\u00f3n del proyecto se deber\u00eda ir cada semana. Aj\u00fastate lo m\u00e1s que puedas, no te conf\u00edes.</p> Calendario de la asignatura. <p>F\u00edjate que, debido a c\u00f3mo es el calendario acad\u00e9mico, hay alteraciones de los turnos que, en algunos casos nos llevan a estar varias semanas sin clase, no te distraigas durante ese tiempo para que no te cueste retomar las sesiones de laboratorio. Todos los turnos tienen el mismo n\u00famero de horas de laboratorio. Las fechas de evaluaci\u00f3n son iguales para todos los turnos.</p> <p>En el curso 2025-26 se ha reducido una semana el semestre. Para mantener el n\u00famero de horas de laboratorio, las 2 sesiones previas a la entrega intermedia y final ser\u00e1n de \\(2h30'\\) en lugar de \\(2h\\).</p> <ol> <li> <p>Canal Youtube de la asignatura: https://www.youtube.com/channel/UCYIw_gl745WMJ1n0MamDzQw/ \u21a9</p> </li> <li> <p>Servicio de Innovaci\u00f3n Educativa de la UPM. Aprendizaje orientado a proyectos. Technical Report, Servicio de Innovaci\u00f3n Educativa de la UPM, 2008.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Comisi\u00f3n del Plan de Estudios. Memoria del t\u00edtulo de graduado en ingenier\u00eda de tecnolog\u00edas y servicios de telecomunicaci\u00f3n. Technical Report, Escuela T\u00e9cnica Superior de Ingenieros de Telecomunicaci\u00f3n, 2014.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Daniel Capell\u00e1n Mart\u00edn, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Amadeo de Gracia Herranz. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9</p> </li> <li> <p>Consejo de Gobierno. Normativa de evaluaci\u00f3n del aprendizaje en las titulaciones oficiales de grado y m\u00e1ster universitario de la universidad polit\u00e9cnica de madrid. Technical Report, Universidad Polit\u00e9cnica de Madrid, 2022.\u00a0\u21a9</p> </li> <li> <p>Oriol Borr\u00e1s Gen\u00e9. Insignias digitales como acreditaci\u00f3n de competencias en la universidad. \\url https://oa.upm.es/47460/1/Insignias%20digitales%20como%20acreditacion%20de%20competencias%20en%20la%20Universidad.pdf, 2017.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/proyecto_base.html","title":"Proyecto base y funciones de sistema","text":"<p>Antes de arrancar con la versi\u00f3n <code>V1</code> del sistema, tenemos que manejarnos con el proyecto base. En esta configuraci\u00f3n inicial vamos a programar una serie de funciones gen\u00e9ricas que se usar\u00e1n a lo largo de todo el proyecto. Esta parte, junto con la versi\u00f3n <code>V1</code> tiene un desarrollo estimado en unas 2-3 semanas. El inicio del proyecto tiene una curva de aprendizaje mayor; por eso, se te va a guiar en los pasos y la explicaci\u00f3n ser\u00e1 m\u00e1s extensa. Al acabar este cap\u00edtulo tendr\u00e1s listas algunas de las funciones base del proyecto Simone.</p> <p>Debes tener a mano en todo momento los documentos referenciados y ver los v\u00eddeos sugeridos a fin de entender mejor c\u00f3mo tiene que escribir el c\u00f3digo o realizar montajes.</p> <p>Bibliograf\u00eda</p> <ol> <li> <p>Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32 <sup>4</sup></p> </li> <li> <p>Datasheet \u201cSTM32F446xC/E\u201d <sup>5</sup></p> </li> <li> <p>Reference manual \u201cRM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>6</sup></p> </li> <li> <p>SISTEMAS DIGITALES I: Pr\u00e1ctica de programaci\u00f3n en C</p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>[MatrixMCU - examples] Blink LED y manejo de proyecto</p> </li> <li> <p>[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen</p> </li> </ul>"},{"location":"notebook/proyecto_base.html#proyecto-base-simone","title":"Proyecto base: Simone","text":"<p>En esta secci\u00f3n se muestra el esquema general del sistema, y se presenta c\u00f3mo has de configurar el proyecto en VSCode.</p> Diagrama de elementos del sistema. <p>Nuestro sistema base versiona el cl\u00e1sico juego de los 80's, Simon. Cuando se presiona el bot\u00f3n de usuario (el azul) durante un tiempo indica que se quiere encender, o apagar, el juego. En ese instante el sistema central encender\u00e1 el RGB light (LED RGB) con la primera secuencia del juego en en nivel f\u00e1cil (<code>LEVEL_EASY</code>). Cuando acaba de reproducirse (playback) la secuencia, se activa la excitaci\u00f3n de las filas del teclado matricial (4x4) de forma iterativa, y se duerme para esperar una interrupci\u00f3n en alguna de las columnas. Cuando se detecta una pulsaci\u00f3n, se comprueba si es la correcta. Si lo es, se vuelve a reproducir la secuencia con un nuevo paso a\u00f1adido. Si no lo es, se enciende el RGB light en rojo para indicar el fallo, y se vuelve a empezar desde el principio. Si se pulsa el bot\u00f3n de usuario durante un tiempo largo, el sistema se apaga. Ve el video demostrativo en Demostraci\u00f3n del sistema Simone. La figura del diagrama muestra los 4 bloques que conforman el sistema:</p> <ol> <li> <p>El sistema central con la placa Nucleo-STM32 aloja el microcontrolador STM32F446RE. Se encarga de gestionar, el encendido y apagado del sistema Simone, de interpretar las pulsaciones del usuario.</p> </li> <li> <p>La placa Nucleo-STM32\u00a0tambi\u00e9n tiene el bot\u00f3n de usuario <code>B1</code>, y el LED de usuario <code>LD2</code>. Estos conforman el sub-sistema de control b\u00e1sico. El bot\u00f3n se usar\u00e1 para detectar pulsaciones que el sistema central interpretar\u00e1 para cambiar encender/\u00a0apagar, u otras implementaciones que el quieras hacer en Versi\u00f3n 5. El LED de la placa podr\u00e1 usarse para saber si hemos realizado correctamente una operaci\u00f3n, a modo de feedback.</p> </li> <li> <p>El teclado matricial. Representa a un dispositivo HW que permite al usuario interactuar con el sistema. En este caso, el teclado matricial es de \\(4\\times4\\) teclas, y se usar\u00e1 para que el usuario introduzca la secuencia que el sistema le va indicando. Se trata de un teclado matricial de membrana en el que se excitan las filas y se ir\u00e1n leyendo las columnas para identificar qu\u00e9 tecla se ha pulsado.</p> </li> <li> <p>El m\u00f3dulo de actuaci\u00f3n. El RGB light est\u00e1 compuesto por un LED RGB que se encender\u00e1 en funci\u00f3n de la secuencia que toque reproducir en el juego, y para dar feedback al jugador de la tecla que ha pulsado.</p> </li> </ol>"},{"location":"notebook/proyecto_base.html#proyecto-simone-en-vscode","title":"Proyecto Simone en VSCode","text":"<p>Vamos a ir construyendo el proyecto poco a poco. En esta primera fase/versi\u00f3n V1 construiremos parte del sistema central y el sub-sistema de control de encendido/\u00a0apagado. Se proporciona la estructura del proyecto sobre el que: desarrollaremos (i) las funciones b\u00e1sicas del sistema para gesti\u00f3n de las GPIO, (ii) la FSM del bot\u00f3n y para el cambio de encendido/ apagado, (iii) testearemos su funcionamiento y, en todo momento documentaremos el c\u00f3digo. Para empezar a trabajar con el proyecto:</p> <ol> <li> <p>Se asume que has hecho la primera sesi\u00f3n de introducci\u00f3n y tienes ya montada la estructura para programaci\u00f3n multiplataforma con el proyecto project_template.</p> <p>Si est\u00e1s trabajando en su ordenador, sigue los pasos para tener el entorno como indica la Gu\u00eda de instalaci\u00f3n\u00a0<sup>7</sup>.</p> </li> <li> <p>Si ya tenemos todo configurado es suficiente con descargar \u2014o clonar, si vas a trabajar con Git\u2014 del repositorio GitHub de la asignatura el proyecto base Simone: https://github.com/sdg2DieUpm/simone, y dejarlo en la carpeta \u201cprojects\u201d de la estructura de directorios MatrixMCU.</p> <p>Deber\u00e1 tener una estructura de directorios como la de la figura de \u00e1rbol de directorios:</p> </li> </ol> \u00c1rbol de directorios tras descargar el proyecto Simone. <p>Note</p> <p>Los puestos del laboratorio utilizan Windows 10. A priori no deber\u0131\u0301a haber conflicto con la configuraci\u00f3n del proyecto en VSCode entre m\u00e1quinas. No obstante, puedes trabajar con tu port\u00e1til en el laboratorio si te es m\u00e1s c\u00f3modo que llevar y traer el c\u00f3digo cada d\u0131\u0301a. S\u0131\u0301 es obligatorio que traigas tu placa Nucleo-STM32 y el HW necesario.</p> <ol> <li> <p>Abre <code>VSCode</code> y abre el proyecto <code>Simone</code> que est\u00e1 en la carpeta <code>projects</code>. Es muy importante que solo abras esa carpeta, \u00a1no toda la carpeta <code>projects</code>!. Tiene que ver en <code>VSCode</code> algo como lo que se muestra en la figura del proyecto en VSCode.</p> </li> <li> <p>Conviene que, si no lo has hecho ya, leas el cap\u00edtulo \u201cDesarrollando para Nucleo-STM32\u201d <sup>4</sup> y te familiarices con la estructura de proyecto y los conceptos.</p> </li> </ol> Proyecto Simone en VSCode. <p>Ver\u00e1s que el proyecto ya tiene algunos ficheros de partida. Los ficheros de cabecera (<code>.h</code>) definen nuevos tipos de variable, contienen <code>#define</code>, hacen <code>#include</code> de otros ficheros, y declaran variables. Si abres los ficheros <code>port_system.h</code> (ver figura) o <code>stm32f4_system.h</code> ver\u00e1s que son muy verbosos; casi todo son l\u00edneas de comentario. La gran mayor\u00eda son l\u00edneas de comentario interpretables por el generador de documentaci\u00f3n Doxygen. Esto se ha hecho as\u00ed para que puedas desarrollar el c\u00f3digo bas\u00e1ndote en la API disponible en la p\u00e1gina de GitHub Pages: https://sdg2dieupm.github.io/simone/. Tendr\u00e1s que tener esta p\u00e1gina siempre a mano<sup>1</sup>. Solo tiene algunos ficheros con ejemplo de documentaci\u00f3n Doxygen; t\u00fa tendr\u00e1s que completar el de cada funci\u00f3n que desarrolles fij\u00e1ndote en los <code>TO-DO alumnos</code> de las descripciones de funci\u00f3n. M\u00e1s adelante se te indicar\u00e1 c\u00f3mo utilizarla.</p> <p>En la carpeta <code>common</code> ver\u00e1s que hay dos ficheros <code>header.h</code> y <code>source.c</code> que indican que han de ser borrados. Est\u00e1n ah\u00ed para que veas c\u00f3mo se estructura del proyecto completo. B\u00f3rralos cuando a\u00f1adas los ficheros de la Versi\u00f3n V1.</p> Documentaci\u00f3n de una funci\u00f3n con Doxygen para generar la API. <p>Podemos empezar ahora con la gesti\u00f3n de las funciones b\u00e1sicas del sistema y las de acceso a las GPIO. En las siguientes secciones vamos a ver (i) un conjunto de funciones gen\u00e9ricas de sistema, (ii) a desarrollar alguna funci\u00f3n relacionada con la temporizaci\u00f3n del sistema, y (iii) funciones de configuraci\u00f3n y manejo de las GPIO. F\u00edjate que dividimos por puntos enumerados las acciones a realizar. Ten esto en cuenta para llevar un orden y no perderse.</p>"},{"location":"notebook/proyecto_base.html#funciones-de-inicializacion-del-sistema","title":"Funciones de inicializaci\u00f3n del sistema","text":"<p>Como se comenta en el cap\u00edtulo \u201cArranque del sistema\u201d del libro de \u201cFundamentos pr\u00e1cticos\u201d <sup>4</sup>, antes de ir a la funci\u00f3n <code>main()</code> el microcontrolador debe realizar el boot del sistema. En dicho cap\u00edtulo se indica que una de las cosas que hace antes es llamar a la funci\u00f3n <code>SystemInit()</code>. Lea dicho cap\u00edtulo del libro.</p> <p>Las funciones de inicializaci\u00f3n no son evidentes y realizan muchas configuraciones de bajo nivel. Se te proporcionan ya codificadas. Todas se encuentran en el fichero <code>stm32f4_system.c</code>. Estas son:</p> <ul> <li> <p><code>SystemInit()</code>: es llamada directamente por <code>Reset_Handler</code> del fichero <code>startup_stm32f446xx.s</code>. En nuestra implementaci\u00f3n, inicializa la FPU (si se usa), configura la memoria externa (si la hay), re-coloca la tabla de vectores de interrupci\u00f3n (si es que la modificamos). En nuestro caso, ninguna de estas tres configuraciones se da.</p> </li> <li> <p><code>port_system_init()</code>: IMPORTANTE esta llamada debemos hacerla nosotros al inicio del programa antes de configurar cualquier perif\u00e9rico. Si no la hacemos, no funcionar\u00e1 nada que tenga que ver con el HW. Esta funci\u00f3n inicializa los perif\u00e9ricos, la memoria flash y llama a la funci\u00f3n de configuraci\u00f3n del reloj <code>system_clock_config()</code>.</p> </li> <li> <p><code>system_clock_config()</code>: IMPORTANTE esta funci\u00f3n, por seguridad, no puede ser accedida desde el exterior por lo que su declaraci\u00f3n no est\u00e1 en <code>port_system.h</code>, para que no la pueda encontrar nadie. Esta funci\u00f3n inicializa el oscilador interno <code>HSI</code> a \\(16 MHz\\) (valor puesto en el <code>#define HSI_VALUE</code>). Esta funci\u00f3n tambi\u00e9n gestiona la alimentaci\u00f3n y configura el temporizador de sistema <code>SysTick</code> a \\(1 ms\\).</p> </li> </ul>"},{"location":"notebook/proyecto_base.html#referencia-temporal-del-sistema-systick","title":"Referencia temporal del sistema: SysTick","text":"<p>En esta secci\u00f3n vamos a hablar de las funciones:</p> <ul> <li> <p><code>port_system_delay_ms()</code></p> </li> <li> <p><code>port_system_delay_until_ms()</code></p> </li> <li> <p><code>port_system_get_millis()</code></p> </li> <li> <p><code>port_system_set_millis()</code></p> </li> </ul> <p>Y de la ISR del temporizador del sistema o <code>SysTick</code>:</p> <ul> <li><code>SysTick_Handler()</code></li> </ul> <p>El <code>SysTick</code> es el temporizador de referencia del sistema. Como se ha mencionado, est\u00e1 ya configurado para que genere una interrupci\u00f3n interna cada \\(1 ms\\). Nosotros debemos decidir qu\u00e9 hacer cada vez que se genere dicha interrupci\u00f3n. En nuestro caso queremos tener una variable que lleve la cuenta de las veces que se ha interrumpido cada \\(1 ms\\). Es lo que vamos a ver en esta secci\u00f3n.</p> <p>Conforme est\u00e1 el proyecto Simone descargado, si lo compilamos, no te dar\u00e1 errores, pero no funciona. Posteriormente, completaremos algunos detalles que faltan, aunque intercalaremos con la explicaci\u00f3n del c\u00f3digo en este cap\u00edtulo.</p> <ol> <li> <p>Compila el c\u00f3digo. Lo podemos hacer de varias maneras. T\u00edpicamente, lo haremos en depuraci\u00f3n, con la placa conectada, pero por ahora, podemos construir los binarios sin necesidad de la placa. En este orden:</p> <ol> <li> <p>Primero generamos las reglas de compilaci\u00f3n con <code>CMake</code>: Men\u00fa <code>Terminal\u2192 Run Task... \u2192 Run CMake \u2192 stm32f446re (Default) \u2192 Release (Default)</code></p> <p>Esto generar\u00e1 las carpetas <code>build/Release/</code> con todas las reglas de compilaci\u00f3n.</p> <p>Si no vas a trabajar en modo depuraci\u00f3n, es necesario que generes las reglas de compilaci\u00f3n en modo <code>Release</code> cada vez que a\u00f1adas un fichero al proyecto. Si trabajas en modo depuraci\u00f3n, no es necesario, se hace autom\u00e1ticamente tras el Clean.</p> </li> <li> <p>Seguidamente, compilamos el c\u00f3digo: Men\u00fa <code>Terminal\u2192 Run Task... \u2192 Build \u2192 stm32f446re (Default) \u2192 Release (Default) \u2192 main</code></p> </li> </ol> </li> </ol> <p>Note</p> <p>El modo <code>Release</code> se usa cuando queremos generar los ficheros binarios que se ejecutar\u00e1n en el dispositivo, pero no queremos depurar. Se usa t\u00edpicamente cuando no tenemos la placa o cuando se genera el c\u00f3digo final de un proyecto que pasa a producci\u00f3n. </p> <p>El modo <code>Debug</code> se usa cuando queremos depurar el c\u00f3digo, y necesitamos tener el dispositivo conectado. En este caso, el compilador a\u00f1ade informaci\u00f3n extra al c\u00f3digo para que el depurador pueda seguir el c\u00f3digo l\u00ednea a l\u00ednea. Esto hace que el c\u00f3digo sea m\u00e1s lento y ocupe m\u00e1s memoria. En el modo <code>Release</code> no se a\u00f1ade esta informaci\u00f3n extra. Normalmente trabajar\u00e1s en modo <code>Debug</code>.</p> <p>En el fichero <code>stm32f4_system.c</code>, tenemos la variable global <code>msTicks</code>. <code>msTicks</code> es una variable muy importante que hemos definido para llevar la cuenta (ticks) en milisegundos del sistema, y est\u00e1 controlado por <code>SysTick</code> (ver cap\u00edtulo de \u201cCircuito de reloj\u201d del libro de Fundamentos Te\u00f3ricos\u00a0<sup>4</sup>). El valor guardado en <code>msTicks</code> se actualiza cada vez que el reloj de sistema <code>SysTick</code> genera una interrupci\u00f3n. Puesto que las interrupciones podemos deshabilitarlas \u2014como en los modos de bajo consumo\u2014, el valor almacenado NO ser\u00e1 un valor absoluto desde que se inici\u00f3 el sistema, sino un valor que podremos tener en cuenta de forma relativa para contar lapsos de tiempo. Trabajaremos con esta variable en las siguientes secciones.</p>"},{"location":"notebook/proyecto_base.html#par:system_delay_ms","title":"Funci\u00f3n <code>port_system_delay_ms</code>","text":"<p>La funci\u00f3n <code>port_system_delay_ms</code> nos podr\u00eda ser de ayuda en alg\u00fan momento. Como dice la API, esta funci\u00f3n hace una espera activa durante <code>ms</code> milisegundos, i.e., el programa se bloquea en el <code>while\\(\\{\\}\\)</code> que no hace nada durante un tiempo dado. Esta funci\u00f3n, para saber cu\u00e1ntos milisegundos han pasado, necesita hacer la resta entre el instante actual y la referencia que coge al inicio <code>tickstart</code>.</p> <p>\u00bfC\u00f3mo sabemos cu\u00e1l es el instante actual? Pues con el valor de la variable global <code>msTicks</code>. Esta variable es global y est\u00e1tica (<code>static uint32_t msTicks</code>), por lo que es accesible por todas las funciones de este fichero solo<sup>2</sup>. Esta \"librer\u00eda\" de sistema <code>stm32f4_system.c</code> ha de proporcionar al resto del c\u00f3digo diversas funcionalidades, y una de ellas es la de dar informaci\u00f3n del tiempo de sistema <code>msTicks</code>. Para ello \u2014y puesto que la variable no es accesible desde el exterior por ser est\u00e1tica\u2014, nos proporciona la funci\u00f3n <code>port_system_get_millis()</code>.</p>"},{"location":"notebook/proyecto_base.html#par:system_delay_until","title":"Funci\u00f3n <code>port_system_delay_until_ms</code>","text":"<p>La funci\u00f3n <code>port_system_delay_until_ms()</code> recibe la referencia del tiempo actual y hace una espera activa hasta <code>ms</code> despu\u00e9s. Nos puede ser tambi\u00e9n de utilidad durante el proyecto. Esta funci\u00f3n toma la referencia de tiempos llamando a <code>port_system_get_millis()</code>.</p>"},{"location":"notebook/proyecto_base.html#par:system_get_millis","title":"Funci\u00f3n <code>port_system_get_millis</code>","text":"<p>La funci\u00f3n <code>port_system_get_millis()</code> est\u00e1 declarada en <code>port_system.h</code> y, aunque est\u00e1 implementada, no hace nada. Seg\u00fan la API, dicha funci\u00f3n simplemente devuelve la cuenta del sistema en milisegundos. Sabemos que ha de devolver un entero de 32 bits sin signo (<code>uint32_t</code>), es decir, tenemos que devolver el valor de la variable <code>msTicks</code>. As\u00ed pues, modifique la funci\u00f3n para que quede como:</p> <pre><code>uint32_t port_system_get_millis()\n{\n    return msTicks; /* ms */\n}    \n</code></pre> <p>y como ya est\u00e1 documentada la funci\u00f3n en el <code>.h</code>, no tenemos que poner la documentaci\u00f3n Doxygen aqu\u00ed.</p>"},{"location":"notebook/proyecto_base.html#par:system_set_millis","title":"Funci\u00f3n <code>port_system_set_millis</code>","text":"<p>En casi todos los lenguajes de programaci\u00f3n, cuando una librer\u00eda nos proporcione una funci\u00f3n get que devuelve un par\u00e1metro encontraremos, t\u00edpicamente, un set, para poder modificar dicho par\u00e1metro. As\u00ed pues, encontramos la funci\u00f3n <code>port_system_set_millis()</code>.</p> <p>Esta funci\u00f3n tambi\u00e9n est\u00e1 declarada en <code>port_system.h</code> e implementada, pero sin desarrollar. Seg\u00fan la API, dicha funci\u00f3n simplemente recibe la cuenta del sistema en milisegundos que queremos poner. \u00bfPor qu\u00e9 \u00edbamos a querer modificar la cuenta de tiempos del sistema? Bueno, nuestra aplicaci\u00f3n podr\u00eda tener alg\u00fan criterio relacionado con ello, pero esta funci\u00f3n existe porque es la que la ISR usa para modificar el contador <code>msTicks</code>. Ya que la ISR est\u00e1 en otro fichero (el fichero <code>interr.c</code>) y no tiene acceso al contador, ha de hacerlo llamado a una funci\u00f3n de <code>stm32f4_system.c</code> que s\u00ed pueda acceder; esta es nuestra funci\u00f3n <code>port_system_set_millis()</code>.</p> <p>Vamos a completarla:</p> <pre><code>void port_system_set_millis(uint32_t ms)\n{\n    msTicks = ms;\n}\n</code></pre> <p>Note</p> <p>En este punto te habr\u00e1s dado cuenta que hay funciones que empiezan por \"<code>port_system_</code>\u201d. Esto es una convenci\u00f3n de nomenclatura, un estilo. Si seguimos un criterio, nos puede ser f\u00e1cil identificar de d\u00f3nde vienen las funciones y qu\u00e9 hacen solo con su nombre. Estas en particular, nos indican que las funciones son \"portables\" (<code>port_</code>) \u2014por lo que estar\u00e1n en el directorio <code>port</code>, y no en el <code>common</code>\u2014, y que son funciones centrales del sistema (<code>system</code>, por abreviar). </p> <p>Como reciben y/\u00a0o devuelven variables est\u00e1ndar (<code>uint32_t</code>, <code>void</code>, \u2026), no tienen nada que ver con el microcontrolador en particular, est\u00e1n en declaradas en los ficheros <code>.h</code> de <code>port/include</code>, pero su implementaci\u00f3n est\u00e1 en <code>stm32f4_system.c</code> en <code>stm32f4/src</code>. Si tuvi\u00e9semos otro microcontrolador, podr\u00edamos reutilizar estas funciones sin modificar el prototipo y solo cambiando la implementaci\u00f3n. </p> <p>Se seguir\u00e1 un cierto estilo a la hora de programar. Se recomienda ojear el libro de estilo \u201cEmbedded C Coding Standard\u201d <sup>8</sup>. El libro es distribuido gratuitamente por los autores en https://barrgroup.com/sites/default/files/barr_c_coding_standard_2018.pdf. Accedido: 2026-01-18.</p>"},{"location":"notebook/proyecto_base.html#par:systick_handler","title":"Funci\u00f3n <code>SysTick_Handler</code>","text":"<p><code>msTicks</code> est\u00e1 definida y se usa cuando se llama a las funciones <code>port_system_set_millis()</code> para darle un valor, y <code>port_system_get_millis()</code> para leerlo, pero \u00bfqui\u00e9n llama a estas funciones para actualizar el valor de <code>msTicks</code>? Bueno, estrictamente nadie las llama, saltan ah\u00ed por hardware, pues es la ISR del <code>SysTick</code>. Vamos a ver c\u00f3mo funciona y a completarla.</p> <p>En el documento <code>interr.c</code> encontrar\u00e1s la ISR del <code>SysTick</code>, <code>SysTick_Handler</code>. Recuerda que este nombre no lo elegimos nosotros, sino que est\u00e1 definido en el fichero de ensamblador de cada dispositivo; <code>startup_stm32f446xx.s</code> para el microcontrolador STM32F446RE. Dentro de la ISR vamos a usar las funciones <code>port_system_get_millis()</code> y <code>port_system_set_millis()</code> para leer y escribir el valor de <code>msTicks</code>.</p> <ol> <li> <p>Llama a la funci\u00f3n <code>port_system_get_millis()</code> en la ISR <code>SysTick_Handler()</code> para leer el valor actual de <code>msTicks</code> y gu\u00e1rdalo en una variable local. No olvides declarar la variable.</p> </li> <li> <p>Llama a la funci\u00f3n <code>port_system_set_millis()</code> en la ISR <code>SysTick_Handler()</code> para escribir el valor de <code>msTicks</code> con el valor anterior incrementado en 1.</p> </li> </ol> <p>Ya tenemos hecho el punto <code>1</code> de la ISR <code>SysTick_Handler()</code> (ver figura de la API), y que estaba pendiente de hacer (<code>TO-DO alumnos</code>).</p> Vista de la API para la ISR <code>SysTick_Handler</code>. <p>Podemos comprobar que el programa sigue compilando correctamente y viendo que se ha generado el fichero ejecutable <code>.elf</code> en la carpeta <code>bin</code>, donde se guardan los binarios generados a ejecutar por el microcontrolador. Tendremos un mensaje en la terminal similar al que se muestra en la figura de compilaci\u00f3n.</p> Compilaci\u00f3n exitosa generando el ejecutable <code>.elf</code>."},{"location":"notebook/proyecto_base.html#sec:sys_gpio","title":"Configuraci\u00f3n y manejo de GPIOs","text":"<p>En esta secci\u00f3n vamos a comprender el c\u00f3digo de las funciones de configuraci\u00f3n y manejo de las GPIOs y a completar algunas de ellas. Con estas funciones conseguiremos inicializar el modo (i.e., entrada, salida, o alternativo) de cada pin de la GPIO, configurar interrupciones, y leer y escribir en los puertos.</p> <p>Es muy importante que tengas a mano el cap\u00edtulo \u201cConfiguraci\u00f3n de GPIOs\u201d del libro de \u201cFundamentos te\u00f3ricos\u201d <sup>4</sup>. En esta secci\u00f3n vamos a trabajar con registros. Todo lo que vamos a ver es un repaso de lo que tiene ya en los ejemplos del libro, pero debes asegurarte de entender lo que hace y saber leer las tablas que en \u00e9l se muestran. No se te va a pedir manejar el reference manual ni el datasheet del microcontrolador, aunque tambi\u00e9n puedes mirar en ellos si quieres m\u00e1s detalle sobre los registros.</p> <p>A lo largo del proyecto vamos a configurar varias GPIOs, como las del bot\u00f3n, el teclado, o los LED. As\u00ed, para no hacer el c\u00f3digo repetitivo, se proporcionan funciones gen\u00e9ricas que reciben como entrada, al menos, el puerto y el pin que quieren configurar. Para ver las funciones sit\u00faate en el fichero <code>stm32f4_system.c</code>, bajo el comentario <code>// GPIO RELATED FUNCTIONS</code>. La lista de funciones que se proporcionan y que vamos a ver es:</p> <ul> <li> <p><code>stm32f4_system_gpio_config()</code></p> </li> <li> <p><code>stm32f4_system_gpio_config_alternate()</code></p> </li> <li> <p><code>stm32f4_system_gpio_config_exti()</code></p> </li> <li> <p><code>stm32f4_system_gpio_config_exti_enable()</code></p> </li> <li> <p><code>stm32f4_system_gpio_config_exti_disable()</code></p> </li> </ul> <p>Adem\u00e1s, por otro lado vas a tener que implementar las funciones de lectura, escritura y toggle de las GPIOs**. Son:</p> <ul> <li> <p><code>stm32f4_system_gpio_read()</code></p> </li> <li> <p><code>stm32f4_system_gpio_write()</code></p> </li> <li> <p><code>stm32f4_system_gpio_toggle()</code></p> </li> </ul> <p>Note</p> <p>\u00bfPor qu\u00e9 las funciones ahora se llaman <code>stm32f4_system_gpio_...</code> y no <code>port_system_gpio_...</code>? Porque estas funciones reciben y devuelven tipos de datos (estructuras, punteros, \u2026) que son espec\u00edficas del microcontrolador STM32F446RE, y no son portables a otros microcontroladores. Por eso, est\u00e1n declaradas en el fichero <code>stm32f4/include/stm32f4_system.h</code> y no en <code>port/include/port_system.h</code>. Si tuvi\u00e9semos otro microcontrolador, tendr\u00edamos que incluirla en su carpeta correspondiente y adaptar el prototipo de la funci\u00f3n.</p>"},{"location":"notebook/proyecto_base.html#par:gpio_config","title":"Funci\u00f3n <code>stm32f4_system_gpio_config</code>","text":"<p>Esta funci\u00f3n configura el modo de la GPIO: entrada, salida o funci\u00f3n alternativa, y el tipo de conexi\u00f3n a la que est\u00e1 el pin (conectada a resistencias de pull-up, o de pull-down). Sirva este primer punto para establecer las bases de c\u00f3mo se codifican las funciones. Tengamos a mano la entrada de la API. La figura muestra la descripci\u00f3n de la anatom\u00eda de una entrada de la API.</p> Vista de la API para la funci\u00f3n <code>stm32f4_system_gpio_config</code>. <p>Como dice el punto <code>1</code> de la API, lo primero que se hace es habilitar el reloj de las GPIO. Esto se indica en los ejemplos del cap\u00edtulo \u201cConfiguraci\u00f3n de GPIOs\u201d del libro como:</p> <pre><code>RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; /* GPIOA clock enable */\n</code></pre> <p>Esta l\u00ednea de c\u00f3digo activa el bit <code>RCC_AHB1ENR_GPIOAEN</code> (GPIOA) del registro <code>RCC_AHB1ENR</code>. Vamos por partes:</p> <ul> <li> <p>El RCC es el controlador de relojes. En el fichero <code>stm32f4xx.h</code><sup>3</sup>, CMSIS lo define como un puntero a una estructura de tipo <code>RCC_TypeDef</code>: . Esta estructura tambi\u00e9n la define CMSIS en el mismo fichero. Tiene muchos campos. Cada campo es un registro del controlador. Bien, pues uno de esos registros es el <code>RCC_AHB1ENR</code>.</p> </li> <li> <p>Recuerda de los v\u00eddeos de SDG1 que para acceder a los campos de una estructura tenemos el punto (<code>.</code>), y la flecha (<code>-&gt;</code>). Usamos punto (<code>.</code>) cuando tenemos acceso directo a la estructura, y usamos flecha (<code>-&gt;</code>) cuando lo que tenemos es un acceso indirecto, un puntero. Esta es nuestra situaci\u00f3n, porque <code>RCC</code> est\u00e1 definido como puntero, y por eso, para acceder al campo que representa al registro hacemos: <code>RCC-&gt;AHB1ENR</code>.</p> <p>Aplica toda esta l\u00f3gica para cualquier registro. Todos est\u00e1n definidos por CMSIS en el fichero <code>stm32f4xx.h</code>, y todos son punteros, por lo que siempre accederemos a los registros de los perif\u00e9ricos con <code>-&gt;</code> (flecha).</p> </li> <li> <p>El fabricante nos indica en el manual de referencia que el acceso a los registros se hace, generalmente, de 32 en 32 bits por lo que no se pueden seleccionar bits particulares de un registro \u2014como indica el libro en un ejemplo\u2014, por eso usamos m\u00e1scaras, en este caso con el operador <code>|</code> (<code>OR</code>) sobre todo el registro para activar el/los bit/s deseado/s.</p> </li> <li> <p>El <code>RCC_AHB1ENR_GPIOAEN</code> es una m\u00e1scara que est\u00e1 definida en <code>stm32f4xx.h</code>, y vale <code>0x01</code>. Gran parte de los bits de los registros, si no todos, est\u00e1n definidos en este fichero. Para cualquier registro, t\u00fa puedes decidir usarlos, o definirte tus propias m\u00e1scaras si te es m\u00e1s c\u00f3modo.</p> </li> </ul> <p>Ya estamos preparados para ver qu\u00e9 hacen las funciones. Conviene que prestes atenci\u00f3n al c\u00f3digo y a las explicaciones aqu\u00ed dadas, pues te ayudar\u00e1 en las pr\u00f3ximas versiones del proyecto. De igual modo, no dejes de leer el cap\u00edtulo \u201cConfiguraci\u00f3n de GPIOs\u201d del libro de \u201cFundamentos te\u00f3ricos\u201d <sup>4</sup>, ni de ver el v\u00eddeo [MatrixMCU - examples] Blink LED y manejo de proyecto.</p> <ol> <li> <p>En el fichero <code>stm32f4_system.h</code> encontramos el prototipo de la funci\u00f3n. En el fichero <code>stm32f4_system.c</code> encontramos su implementaci\u00f3n.</p> </li> <li> <p>Dentro de la funci\u00f3n vemos que el c\u00f3digo activa el bit <code>RCC_AHB1ENR_GPIOAEN</code>, <code>RCC_AHB1ENR_GPIOBEN</code>, o <code>RCC_AHB1ENR_GPIOCEN</code>, en funci\u00f3n de si el valor de <code>port</code> es <code>GPIOA</code>, <code>GPIOB</code>, o <code>GPIOC</code>, respectivamente. Esto completa el primer punto de la API.</p> <p>El pinout de Arduino no da acceso a ning\u00fan pin que no sea de estos tres puertos. El pinout de Morpho s\u00ed da acceso a algunos del <code>GPIOH</code>, y uno del <code>GPIOD</code>. Si en tus implementaciones de la Versi\u00f3n 5 vas a utilizar alguno de estos pines, necesitar\u00e1s incluirlos en esta funci\u00f3n de configuraci\u00f3n. Mira la secci\u00f3n \u201cConectores y z\u00f3calos de la placa\u201d para confirmarlo.</p> </li> <li> <p>Se configura el modo del puerto (registro <code>MODER</code>) como se hace en la secci\u00f3n \u201cGPIO port mode register (GPIOx_ MODER)\u201d del libro.</p> <ul> <li> <p>Limpia lo que hubiese escrito en las posiciones del registro <code>MODER</code> con la m\u00e1scara creada.</p> <p>Se usa la m\u00e1scara base <code>GPIO_MODER_MODER0</code> definida por CMSIS en el fichero <code>stm32f446xx.h</code>. Esta m\u00e1scara vale <code>0x03UL</code>, i.e., <code>0b11</code> en binario, unsigned (<code>U</code>, no tiene signo), long (<code>L</code>, de 32 bits). Es muy \u00fatil usar estas m\u00e1scaras base para limpiar los bits de los registros.</p> <p>Para limpiar los bits de un registro o variable, se hace una <code>AND</code> (&amp;) con la m\u00e1scara negada.</p> </li> <li> <p>Escribe en el registro de modo el valor de la variable <code>mode</code> \u2014que es el argumento recibido y podr\u00e1 tomar valores <code>STM32F4_GPIO_MODE_IN</code>\u2014 <code>STM32F4_GPIO_MODE_OUT</code>, <code>STM32F4_GPIO_MODE_AF</code>, o <code>STM32F4_GPIO_MODE_AN</code>. Estos son los valores que se han definido en el fichero <code>stm32f4_system.h</code>, y que valen <code>0x00</code>, <code>0x01</code>, <code>0x02</code>, y <code>0x03</code>, respectivamente.</p> <p>Para escribir en las posiciones correctas del registro, se usa el desplazamiento con la variable <code>pin</code>. La variable <code>pin</code> se multiplica por <code>2U</code> para asegurar que el desplazamiento es de 2 en 2 bits.</p> <p>Para poner a 1 los bits de un registro o variable, se hace una <code>OR</code> (<code>|</code>) con el valor deseado.</p> </li> </ul> <p>Ya se ha hecho el segundo punto de la API de esta funci\u00f3n.</p> </li> <li> <p>De la misma forma, se configura el tipo de conexi\u00f3n pull-up/\u00a0down del pin. El c\u00f3digo es m\u00e1s gen\u00e9rico que el que se explica en la secci\u00f3n \u201cGPIO port pull-up/pull-down register (GPIOx_PUPDR)\u201d del libro. Simplemente, se repite los pasos anteriores pero esta vez sobre el registro <code>PUPDR</code>: crea la m\u00e1scara, limpia y escribe en el registro.</p> <p>Ya se ha hecho el \u00faltimo punto de la API de esta funci\u00f3n.</p> </li> </ol>"},{"location":"notebook/proyecto_base.html#par:gpio_config_alternate","title":"Funci\u00f3n <code>stm32f4_system_gpio_config_alternate</code>","text":"<p>Esta funci\u00f3n configura el modo de la GPIO como funci\u00f3n alternativa. Para ello sigue las indicaciones de la API. A saber, lo que hace es:</p> <ul> <li> <p>Define una m\u00e1scara base de 4 bits (<code>0x0F</code>) para seleccionar los bits del registro <code>AFR</code> que se van a modificar.</p> <p>Esta m\u00e1scara se desplaza 4 por el valor de la variable <code>pin</code> m\u00f3dulo 8. 4 es el ancho de cada campo del registro <code>AFR</code>. El m\u00f3dulo 8 hace que el valor de <code>pin</code> se mantenga entre 0 y 7, y as\u00ed, no nos salgamos del ancho del registro, que tiene 32 bits.</p> </li> <li> <p>Se limpian los bits del registro <code>AFR</code> con la m\u00e1scara creada.</p> <p>Se selecciona el registro <code>AFRL</code> (low) o <code>AFRH</code> (high) en funci\u00f3n de: el valor de la variable <code>pin</code> dividido entre 8. Como <code>pin</code> solo puede tomar valores entre 0 y 15, la divisi\u00f3n entre 8 nos da 0 o 1. Esto hace que el valor resultante seleccione el registro <code>AFRL</code> o <code>AFRH</code>, respectivamente.</p> </li> <li> <p>Se escribe en el registro <code>AFR</code> el valor de la variable <code>alternate</code>.</p> </li> </ul>"},{"location":"notebook/proyecto_base.html#par:gpio_config_exti","title":"Funci\u00f3n <code>stm32f4_system_gpio_config_exti</code>","text":"<p>Vamos a ver ahora esta funci\u00f3n que configura el pin dado para generar interrupciones externas. Lee y ten a mano el cap\u00edtulo \u201cInterrupciones\u201d del libro. El ejemplo te servir\u00e1 de mucho. Esta funci\u00f3n nos servir\u00e1 para enterarnos cuando pulsemos el bot\u00f3n y realizar alguna acci\u00f3n en nuestro sistema.</p> <p>Vamos a seguir los cuatro puntos de la API de esta funci\u00f3n.</p> <ol> <li> <p>Lo primero que hace es habilitar el controlador de configuraci\u00f3n del sistema que, como nos indica la API, sirve para controlar la l\u00ednea de interrupciones externas hacia las GPIO. Para ello, se activa el bit <code>SYSCFGEN</code> del registro <code>APB2ENR</code> del RCC. De nuevo, podemos definir nuestra propia m\u00e1scara para dicho bit mirando el registro, o usar la <code>RCC_APB2ENR_SYSCFGEN</code> de CMSIS que nos indica la API.</p> </li> <li> <p>Lo siguiente que hace es asociar la interrupci\u00f3n externa al puerto. Este c\u00f3digo puede hacerse de muchas maneras, unas m\u00e1s eficientes que otras, aunque no nos preocupamos de eso ahora.</p> <p>Como se indica en el libro, dependiendo del pin y el puerto, tendremos que elegir un registro u otro para realizar la asociaci\u00f3n. Como se trata de una funci\u00f3n gen\u00e9rica y no sabemos qu\u00e9 valores nos van a llegar, se hace la implementaci\u00f3n para cada pin y puerto seg\u00fan sea el valor de la variable <code>pin</code> y <code>port</code>. As\u00ed pues:</p> <ul> <li> <p>si el valor de <code>pin</code> est\u00e1 entre <code>0</code> y <code>3</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR1</code> (<code>SYSCFG-&gt;EXTICR[0]</code>),</p> </li> <li> <p>si el valor de <code>pin</code> est\u00e1 entre <code>4</code> y <code>7</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR2</code> (<code>SYSCFG-&gt;EXTICR[1]</code>),</p> </li> <li> <p>si el valor de <code>pin</code> est\u00e1 entre <code>8</code> y <code>11</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR3</code> (<code>SYSCFG-&gt;EXTICR[2]</code>), y</p> </li> <li> <p>si el valor de <code>pin</code> est\u00e1 entre <code>12</code> y <code>15</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR4</code> (<code>SYSCFG-&gt;EXTICR[3]</code>).</p> </li> </ul> <p>Se define una m\u00e1scara base de 4 bits (<code>0x0F</code>) para seleccionar los bits del registro <code>EXTICRx</code> que se van a modificar.</p> <p>Esta m\u00e1scara se desplaza 4 por el valor de la variable <code>pin</code> m\u00f3dulo 4. 4 es el ancho de cada campo del registro <code>EXTICRx</code>. El m\u00f3dulo 4 hace que el valor de <code>pin</code> se mantenga entre 0 y 3 y, as\u00ed, no nos salgamos del ancho del registro, del que se usan 16 bits.</p> <p>Se limpian los bits del registro <code>EXTICRx</code> con la m\u00e1scara creada.</p> <p>Se selecciona el registro <code>EXTICR1</code>, <code>EXTICR2</code>, <code>EXTICR3</code>, o <code>EXTICR4</code> en funci\u00f3n de el valor de la variable <code>pin</code> dividido entre 4. Como <code>pin</code> solo puede tomar valores entre 0 y 15, la divisi\u00f3n entre 4 nos da 0, 1, 2 o 3. Esto hace que el valor resultante seleccione el registro <code>EXTICR1</code>, <code>EXTICR2</code>, <code>EXTICR3</code> o <code>EXTICR4</code>, respectivamente.</p> <p>Se escribe en el registro <code>EXTICRx</code> el valor que corresponda para cada puerto. Si <code>port</code> es <code>GPIOA</code>, escribimos el valor <code>0</code>, si es <code>GPIOB</code>, escribimos el valor <code>1</code>\u2026, como indica la \u201cFigura\u201d del libro.</p> </li> <li> <p>A continuaci\u00f3n se selecciona la direcci\u00f3n de disparo de la interrupci\u00f3n: en flanco de subida, de bajada, o ambos.</p> <ul> <li> <p>Se activa el bit del pin correspondiente en el registro <code>RTSR</code> (rising) si el valor de la variable <code>mode</code> es <code>0x01</code>, indicando que la interrupci\u00f3n ha de notificarse cuando ocurra un flanco de subida.</p> <p>El n\u00famero del pin, <code>pin</code>, act\u00faa como \u00edndice de una m\u00e1scara de 1 solo bit, para lo que se usa la macro dada <code>BIT_POS_TO_MASK(pin)</code> para actuar sobre los registros.</p> </li> <li> <p>Se hace lo propio con el registro <code>FTSR</code> (falling) si el valor de la variable <code>mode</code> es <code>0x02</code>, indicando que la interrupci\u00f3n ha de notificarse cuando ocurra un flanco de bajada.</p> </li> <li> <p>Si el valor es <code>0x03</code> escribe en ambos registros: subida y bajada.</p> <p>\u00bfPor qu\u00e9 estos valores? Porque as\u00ed lo hemos decidido, podr\u00edan ser otros cualquiera. \u00bfY c\u00f3mo sabemos que son dichos valores? Porque la API nos dice los valores que podemos darle a la variable <code>mode</code>:</p> <p>Distintos valores que podemos darle a la variable <code>mode</code>.</p> <p>Es un consenso con nosotros mismos. Se ha a\u00f1adido en <code>stm32f4_system.h</code> un conjunto de <code>#define</code> para estos valores a fin de que el c\u00f3digo sea m\u00e1s inteligible y no haya valores \u201ca pincho\u201d. Se usan nombres representativos como:</p> <ul> <li> <p><code>#define STM32F4_TRIGGER_RISING_EDGE</code></p> </li> <li> <p><code>#define STM32F4_TRIGGER_FALLING_EDGE</code></p> </li> <li> <p><code>#define STM32F4_TRIGGER_BOTH_EDGE</code></p> </li> </ul> </li> </ul> </li> <li> <p>Por \u00faltimo, de nuevo codificado en el valor de <code>mode</code>, se act\u00faa sobre los registros <code>EXTI_EMR</code> o <code>EXTI_IMR</code> activando el bit correspondiente seg\u00fan si el valor de <code>mode</code> es <code>0x04</code> o <code>0x08</code>, respectivamente. Tambi\u00e9n puede darse el caso de que se quieran activar ambos a la vez. No son excluyentes. En este caso, como en el anterior, activar\u00edamos ambos (se puede a\u00f1adir un tercer <code>#define</code> h\u00edbrido, o realizar dos llamadas a la funci\u00f3n).</p> <p>Se a\u00f1ade en <code>stm32f4_system.h</code> un conjunto de <code>#define</code> con nombres representativos como:</p> <ul> <li> <p><code>#define STM32F4_TRIGGER_ENABLE_EVENT_REQ</code></p> </li> <li> <p><code>#define STM32F4_TRIGGER_ENABLE_INTERR_REQ</code></p> </li> </ul> </li> </ol> <p>Ya hemos visto c\u00f3mo est\u00e1 programada la funci\u00f3n. Esta ha sido m\u00e1s compleja, pero esperemos que ya vaya cogiendo soltura con los registros.</p>"},{"location":"notebook/proyecto_base.html#par:gpio_config_exti_enable","title":"Funci\u00f3n <code>stm32f4_system_gpio_config_exti_enable</code>","text":"<p>El objetivo de esta funci\u00f3n es establecer el nivel de prioridad y subprioridad, y a la vez habilitar la interrupci\u00f3n de una l\u00ednea externa dada. La llamaremos cuando queramos configurar un pin como entrada y que genere interrupciones. Internamente llama a una macro de CMSIS que controla los registros de interrupci\u00f3n. Estos registros no aparecen en el reference manual porque son del core de Cortex-M4. Es muy importante habilitar la interrupci\u00f3n o nunca saltar\u00e1 la ISR.</p>"},{"location":"notebook/proyecto_base.html#par:gpio_config_exti_disable","title":"Funci\u00f3n <code>stm32f4_system_gpio_config_exti_disable</code>","text":"<p>El objetivo de esta funci\u00f3n es deshabilitar la interrupci\u00f3n de una l\u00ednea externa dada. La usaremos cuando no queramos que nos interrumpa un pin/\u00a0l\u00ednea configurado como entrada y previamente habilitado. Mientras est\u00e1 desactivada, no saltar\u00e1 la ISR asociada a dicha l\u00ednea.</p>"},{"location":"notebook/proyecto_base.html#par:gpio_read","title":"Funci\u00f3n <code>stm32f4_system_gpio_read</code>","text":"<p>Esta funci\u00f3n ser\u00e1 llamada cuando queramos leer el valor digital de un pin. Leeremos un <code>\u20181\u2019</code> o un <code>\u20180\u2019</code> l\u00f3gico, por eso, la funci\u00f3n devuelve <code>bool</code>. Vamos a seguir los dos puntos de la API de esta funci\u00f3n para que la implementes t\u00fa mismo/a.</p> <ol> <li> <p>En <code>stm32f4_system.h</code> declara el prototipo de la funci\u00f3n seg\u00fan indica la API. De esta forma la funci\u00f3n se hace p\u00fablica y podr\u00e1 ser llamada desde cualquier otro fichero.</p> </li> <li> <p>En <code>stm32f4_system.c</code> escribe el prototipo de la funci\u00f3n y abre llaves. Vamos a seguir los pasos que se indican en la API.</p> </li> <li> <p>Lee el valor del registro <code>IDR</code> de la GPIO como se muestra en la secci\u00f3n \u201cGPIO port input data register (GPIOx_IDR)\u201d del libro.</p> <ul> <li> <p>El puerto es el <code>port</code> dado.</p> </li> <li> <p>Usa la macro <code>BIT_POS_TO_MASK(pin)</code> para crear la m\u00e1scara seg\u00fan el pin dado.</p> </li> <li> <p>Tenemos que devolver una variable de tipo <code>bool</code>, por lo que tendremos que hacer un cast del resultado le\u00eddo del registro, ya que el registro es una variable de 32 bits. Puedes utilizar una variable intermedia para cargar el valor del registro, o hacerlo como en el ejemplo.</p> <p>Para leer el valor de un bit en un registro hacemos el producto bit a bit (<code>&amp;</code>).</p> </li> </ul> </li> <li> <p>Devuelve el valor le\u00eddo.</p> </li> <li> <p>En <code>stm32f4_system.h</code> documenta la funci\u00f3n con <code>Doxygen</code> ayud\u00e1ndose con la API. Recuerda que tienes el v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d con las bases para documentar y generar tu propia API.</p> </li> </ol> <p>Ya tenemos la funci\u00f3n que nos permite leer valores digitales del exterior dado un puerto y un pin. Comprueba que compila sin errores: Men\u00fa <code>Terminal\u2192 Run Task... \u2192 Build \u2192 stm32f446re (Default) \u2192 Release (Default) \u2192 main</code>.</p>"},{"location":"notebook/proyecto_base.html#par:gpio_write","title":"Funci\u00f3n <code>stm32f4_system_gpio_write</code>","text":"<p>A continuaci\u00f3n vamos a desarrollar la funci\u00f3n que ser\u00e1 llamada cuando queramos escribir un valor digital en un pin. Escribiremos <code>\u20181\u2019</code> o <code>\u20180\u2019</code> l\u00f3gicos. Vamos a seguir los dos puntos de la API de esta funci\u00f3n.</p> <ol> <li> <p>En <code>stm32f4_system.h</code> declara el prototipo de la funci\u00f3n seg\u00fan indica la API.</p> </li> <li> <p>En <code>stm32f4_system.c</code> escribe el prototipo de la funci\u00f3n y abre llaves.</p> </li> <li> <p>Escribe el valor correspondiente en el registro <code>BSRR</code> de la GPIO como se muestra en la secci\u00f3n \u201cGPIO port bit set/reset register (GPIOx_BSRR)\u201d del libro.</p> <ul> <li> <p>El puerto es el <code>port</code> dado.</p> </li> <li> <p>Si el valor de la variable <code>value</code> es <code>true</code> activamos el bit correspondiente. Puedes usar la macro <code>BIT_POS_TO_MASK(pin)</code> para crear la m\u00e1scara seg\u00fan el pin dado. Para evitar posibles condiciones de carrera, utilizamos el registro <code>GPIOx_BSRR</code> y no el <code>GPIOx_ODR</code>.</p> </li> <li> <p>Si el valor de la variable <code>value</code> es <code>false</code> limpiamos el bit correspondiente. Lo limpiamos poniendo a uno el bit correspondiente en el registro <code>GPIOx_BSRR</code>; as\u00ed funciona este registro .</p> </li> </ul> </li> <li> <p>En <code>stm32f4_system.h</code> documenta la funci\u00f3n con <code>Doxygen</code> ayud\u00e1ndote con la API.</p> </li> </ol> <p>Ya tenemos la funci\u00f3n que nos permite escribir valores digitales dado un puerto y un pin. Comprueba que compila sin errores.</p>"},{"location":"notebook/proyecto_base.html#par:gpio_toggle","title":"Funci\u00f3n <code>stm32f4_system_gpio_toggle</code>","text":"<p>Esta funci\u00f3n es muy c\u00f3moda cuando queremos invertir el valor de un pin. Si estaba en alto (<code>\u20181\u2019</code> l\u00f3gico), que pase a bajo (<code>\u20180\u2019</code> l\u00f3gico), y viceversa. Esta funci\u00f3n usa las dos anteriores; lee el valor del pin y escribe el opuesto. Seguimos la API.</p> <ol> <li> <p>En <code>stm32f4_system.h</code> declara el prototipo de la funci\u00f3n seg\u00fan indica la API.</p> </li> <li> <p>En <code>stm32f4_system.c</code> escribe el prototipo de la funci\u00f3n y abre llaves.</p> </li> <li> <p>Lee el valor del pin y el puerto. Puedes servirte de la funci\u00f3n anteriormente implementada.</p> </li> <li> <p>Escribe en el pin y el puerto el valor contrario al le\u00eddo. Puedes servirte de la funci\u00f3n anteriormente implementada.</p> <p>Puedes definir utilizar las macros <code>HIGH</code> y <code>LOW</code> si te resulta m\u00e1s c\u00f3modo de interpretar que <code>true</code> y <code>false</code>.</p> </li> <li> <p>En <code>stm32f4_system.h</code> documenta la funci\u00f3n con <code>Doxygen</code> ayud\u00e1ndote con la API.</p> </li> </ol> <p>Ya hemos tenemos la funci\u00f3n que nos permite alternar el valor de un pin. Comprueba que compila sin errores. Podr\u00e1s probar estas funciones junto con el test unitario del PORT de la versi\u00f3n 1.</p> <p>Tambi\u00e9n hemos acabado con las funciones b\u00e1sicas del sistema. Estas funciones se usar\u00e1n en las distintas versiones del proyecto, por eso es tan importante que las hici\u00e9semos lo primero y que las entienda. Adem\u00e1s, nos ha servido para calentar en esto de la programaci\u00f3n de bajo nivel (baremetal). A continuaci\u00f3n seguiremos con la implementaci\u00f3n HW del bot\u00f3n y su m\u00e1quina de estados.</p> <ol> <li> <p>Aunque t\u00fa mismo puedes re-generar dicha API localmente como se explica en la gu\u00eda\u00a0<sup>7</sup>.\u00a0\u21a9</p> </li> <li> <p>La funci\u00f3n <code>port_system_delay_ms()</code> s\u00ed podr\u00eda acceder a la variable <code>msTicks</code> directamente, aunque con llamada a <code>port_system_get_millis()</code> es m\u00e1s ortodoxo y as\u00ed es como lo har\u00edan, inevitablemente, funciones de otros ficheros.\u00a0\u21a9</p> </li> <li> <p>El fichero <code>stm32f4xx.h</code> se encuentra en el \u00e1rbol de directorios de la toolkit MatrixMCU en: MatrixMCU/drivers/stm32f4xx/CMSIS/Device/ST/STM32F4xx/Include/stm32f446xx.h \u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Daniel Capell\u00e1n Mart\u00edn, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Amadeo de Gracia Herranz. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9</p> </li> <li> <p>Michael Barr. Embedded C Coding Standard. Netrino, 2009.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/sesion_introduccion.html","title":"Sesi\u00f3n de introducci\u00f3n","text":"<p>Bibliograf\u00eda</p> <ul> <li> <p>\"Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>1</sup></p> </li> <li> <p>\"Tutoriales sobre los fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>2</sup></p> </li> <li> <p>\"Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C\u201d <sup>3</sup></p> </li> <li> <p>Datasheet \"STM32F446xC/E\u201d <sup>4</sup></p> </li> <li> <p>Reference manual \"RM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>5</sup></p> </li> <li> <p>\"SISTEMAS DIGITALES I: Pr\u00e1ctica de programaci\u00f3n en C\u201d</p> </li> </ul> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Clase inicial de parpadeo de un LED y manejo de proyecto con MatrixMCU</p> </li> <li> <p>Conceptos b\u00e1sicos de C (canal SDG1)</p> </li> </ul> <p>En tu primera sesi\u00f3n de laboratorio vas a trabajar con los cap\u00edtulos de ejemplo de los tutoriales del libro de la asignatura  \"Tutoriales sobre los fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>2</sup>.</p> <p>Empezar\u00e1s por el proyecto Blink donde aprender\u00e1s a configurar un proyecto para compilaci\u00f3n cruzada sobre la placa Nucleo-STM32F446RE. Luego contin\u00faa con los otros tutoriales para familiarizarte con las m\u00e1quinas de estado. Si no te da tiempo, ac\u00e1balos en casa, porque gran parte del c\u00f3digo que ah\u00ed realices te servir\u00e1 para el desarrollo del proyecto. De hecho, constituyen casi en su completitud (aunque no en forma), la versi\u00f3n 1 del sistema. Adem\u00e1s, te servir\u00e1 para familiarizarte con el entorno.</p> <p>Posteriormente, en casa, te vendr\u00e1 bien ver los v\u00eddeos recomendados de SDG1. Tanto los documentos como los v\u00eddeos es importante que los tengas siempre a mano, pues tratan de conceptos fundamentales.</p> <p>IMPORTANTE</p> <p>Ve este v\u0131\u0301deo-tutorial donde se explica c\u00f3mo manejar el LED de la placa y a\u00f1adir uno nuevo. En \u00e9l se explica en detalle c\u00f3mo elegir y configurar las GPIO bas\u00e1ndose en la documentaci\u00f3n disponible MatrixMCU Blink LED y manejo de proyecto.</p> <p>El libro de Fundamentos te\u00f3ricos <sup>1</sup> no es precisamente un libro de cabecera, pero lea los cap\u00edtulos, y aquellas partes m\u00e1s densas en las que se habla de especificidades de registros, oj\u00e9alas, para tenerlas ubicadas cuando las necesites. Esos tiempos muertos en el transporte p\u00fablico son buenos momentos para leerlo y entender qu\u00e9 partes forman la placa Nucleo-STM32, repasar de SDG1 qu\u00e9 son los modos de bajo consumo, qu\u00e9 es un reloj\u2026 \ud83d\ude00</p> <p>Para trabajar en casa sigue el Cap\u00edtulo \"Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n cruzada en C\u201d de la gu\u00eda\u00a0<sup>3</sup> o ve el v\u00eddeo [MatrixMCU] Gu\u00eda de instalaci\u00f3n toolkit MatrixMCU en YouTube. No obstante, alguno de los pasos del v\u00eddeo puede que los tengas completados de la instalaci\u00f3n de SDG1. Rep\u00e1salo igualmente.</p> <p>Esperemos que disfrutes y aprendas.</p> <p>\u00a1Adelante!</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9</p> </li> <li> <p>Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Josu\u00e9 Pag\u00e1n Ortiz, and Alberto Bosc\u00e1 Mojena. Tutoriales sobre los fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Daniel Capell\u00e1n Mart\u00edn, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Amadeo de Gracia Herranz. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_1.html","title":"Versi\u00f3n 1: bot\u00f3n de usuario","text":"<p>Ya estamos en disposici\u00f3n de programar el bloque que controla la pulsaci\u00f3n del bot\u00f3n para encender y apagar el sistema Simone, y para pausarlo. Debes tener a mano en todo momento los documentos referenciados y ver los v\u00eddeos sugeridos a fin de entender mejor c\u00f3mo tienes que escribir el c\u00f3digo o realizar montajes.</p> <p>Bibliograf\u00eda</p> <ol> <li> <p>\u201cFundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>3</sup></p> </li> <li> <p>Datasheet \u201cSTM32F446xC/E\u201d <sup>4</sup></p> </li> <li> <p>Reference manual \u201cRM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>5</sup></p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Demostraci\u00f3n Simone</p> </li> <li> <p>Blink LED y manejo de proyecto</p> </li> <li> <p>Conceptos b\u00e1sicos de C (canal SDG1)</p> </li> <li> <p>[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen</p> </li> </ul> <p>Vamos a desarrollar el bot\u00f3n de control del sistema Simone. Vamos a trabajar con el timer del sistema y m\u00e1quinas de estado. En esta secci\u00f3n explicaremos los fundamentos de esta librer\u00eda y posteriormente seguiremos los pasos para desarrollarla. Para desarrollar esta librer\u00eda vamos a contar con la API.</p> <p>En esta versi\u00f3n 1, el sistema solo trabaja con el bot\u00f3n de usuario. Las caracter\u00edsticas a destacar de este montaje se muestran en el\u00a0. El bot\u00f3n de usuario est\u00e1 conectado al pin <code>PC13</code>, por lo que usaremos la interrupci\u00f3n externa <code>EXTI13</code> para detectar cuando pulsamos y soltamos el bot\u00f3n. La prioridad de la interrupci\u00f3n ser\u00e1 1, la m\u00e1s alta, para poder parar el sistema en cualquier momento.</p> Par\u00e1metro Valor Pin <code>PC13</code> Modo Entrada Pull up/ down No push no pull EXTI <code>EXTI13</code> ISR <code>EXTI15_10_IRQHandler()</code> Prioridad 1 Subprioridad 0 Tiempo anti-rebotes \\(100-200 ms\\) <p>Caracter\u00edsticas del bot\u00f3n de usuario en Versi\u00f3n 1.</p> <p>Estudia y practica con las m\u00e1quinas de estado. Entiende c\u00f3mo se definen los estados, las tablas de transiciones, y qu\u00e9 son las funciones de entrada/\u00a0comprobaci\u00f3n y salida/\u00a0actuaci\u00f3n. Para ello vuelve a leer  el cap\u00edtulo \u201c2. Introducci\u00f3n a las m\u00e1quinas de estados en C\u201d <sup>6</sup>.</p> <p>Si tienes la oportunidad de abrir un bot\u00f3n pulsador<sup>1</sup>, seguramente encuentres un dise\u00f1o mec\u00e1nico como el de la figura. Se trata de una chapa met\u00e1lica pegada a un aislante (donde toca el usuario) y colocada sobre un muelle. En la parte inferior, los pines del bot\u00f3n est\u00e1n tambi\u00e9n en contacto con una chapa met\u00e1lica. Al presionar, la chapa superior entra en contacto con la inferior y cierra el circuito (cortocircuito), circulando la corriente a trav\u00e9s del bot\u00f3n. Cuando se suelta, la corriente deja de pasar (circuito abierto).</p> Representaci\u00f3n mec\u00e1nica de un bot\u00f3n. <p>En la figura del esquema vemos el esquem\u00e1tico del bot\u00f3n de usuario <code>B1</code> en la placa Nucleo-STM32. Cuando pulsamos el bot\u00f3n, este hace cortocircuito con <code>GND</code>, por lo que la tensi\u00f3n en el puerto <code>PC13</code> del microcontrolador pasa de alto a bajo (flanco de bajada).</p> Esquema del circuito del bot\u00f3n en la placa Nucleo-STM32F446RE. <p>Como habr\u00e1s podido intuir, el muelle genera inestabilidades cuando se pulsa, esto es a lo que llamamos rebotes (bounces en ingl\u00e9s). Estos rebotes son molestos porque se pueden interpretar como m\u00faltiples pulsaciones del usuario, por lo que hay que poner alg\u00fan mecanismo para filtrarlos. Se pueden hacer mecanismos HW como un filtro paso bajo o, como en nuestro caso, se pueden implementar mecanismos SW.</p> <p>En SW hay varias formas de implementar dicho mecanismo. En nuestra propuesta lo haremos a trav\u00e9s de la definici\u00f3n de un tiempo de guarda que obliga a ignorar todo lo que pasa en ese intervalo. F\u00edjate en el supuesto de la\u00a0figura de rebotes. Para el proyecto vamos a considerar que la pulsaci\u00f3n empieza cuando la ISR detecta el flanco de bajada, y hasta que se detecta un flanco de subida v\u00e1lido. En la figura, hay una pulsaci\u00f3n de usuario, y la mec\u00e1nica del bot\u00f3n hace que haya 2 rebotes bien definidos. El primer rebote no se detecta porque est\u00e1 dentro del tiempo de guarda. No obstante, este tiempo no es lo suficiente grande y se nos cuela el segundo rebote. Esta figura nos servir\u00e1 como ejemplo para entender el desarrollo de la FSM.</p> Ejemplo de 2 rebotes en una pulsaci\u00f3n con tiempo de anti-rebotes bajo. <p>Salvo que tengamos mucha experiencia jugando a videojuegos\u00a0\ud83d\ude05, no seremos muy r\u00e1pidos pulsando el bot\u00f3n. Dejando un tiempo de guarda entre \\(100-200 ms\\) deber\u00eda ser suficiente, pero depende del deterioro de nuestro bot\u00f3n y quiz\u00e1s debamos ajustarlo haciendo pruebas en el laboratorio con el osciloscopio. Ya estamos preparados para implementar la FSM.</p> <p>Tenemos que entender que estamos desarrollando una librer\u00eda. As\u00ed lo vamos a hacer con todos los bloques del sistema. \u00bfQu\u00e9 quiere decir esto? Tenemos que pensar que una librer\u00eda es una entidad superior que me proporciona \u201ccosas\u201d. Pueden ser funciones, o elementos (estructuras). Me puede proporcionar tantos como necesite. El desarrollo de la librer\u00eda es ajeno al bot\u00f3n que vamos a usar (ir\u00e1 en el <code>COMMON</code>, es una l\u00f3gica com\u00fan, gen\u00e9rica, independiente del HW). Puedo tener \\(1\\) bot\u00f3n, o \\(N\\) botones. Cada vez que quiera usar un bot\u00f3n, a este le asociar\u00e9 una FSM de bot\u00f3n. Las particularidades de d\u00f3nde est\u00e1 conectado este nuevo bot\u00f3n, sus caracter\u00edsticas f\u00edsicas (tiempo de rebote), etc., son cosas espec\u00edficas del HW, por lo que estar\u00e1n en <code>PORT</code>. La l\u00f3gica la vamos a hacer, siempre que se pueda, con m\u00e1quinas de estado. El bot\u00f3n implementa su propia m\u00e1quina de estados. Esta filosof\u00eda es la que mantendremos a lo largo de todo el proyecto.</p> <p>Note</p> <p>Vamos a empezar por la parte portable <code>PORT</code> de control y acceso al HW. Empezaremos con las cabeceras <code>.h</code>y seguiremos con la implementaci\u00f3n de las funciones de los ficheros fuente <code>.c</code>. Para comprobar que todo funciona correctamente, pasaremos el test unitario de la parte <code>PORT</code>. Luego, pasaremos a la parte <code>COMMON</code> de la librer\u00eda, que es la l\u00f3gica com\u00fan a todos los sistemas. Empezaremos con las cabeceras y seguiremos con la implementaci\u00f3n de las funciones de los ficheros fuente. Para comprobar que todo funciona correctamente, pasaremos el test unitario de la parte <code>COMMON</code>, y finalizaremos con el ejemplo de uso de la librer\u00eda. </p> <p>Las cabeceras <code>.h</code> van a se nuestro \u201ccontrato con el usuario\u201d, y en los ficheros fuente <code>.c</code> implementaremos las funciones. Este es el ciclo de desarrollo que vamos a seguir en todo el proyecto.</p> Estructura del HW del bot\u00f3n en PORT. Estructura de la FSM del bot\u00f3n en COMMON. <p>Las figuras de estructuras HW y SW muestran las estructuras que vamos a necesitar para el bot\u00f3n. La estructura del HW del bot\u00f3n en <code>PORT</code>. El <code>PORT</code> de otro microcontrolador podr\u00eda implementar internamente una estructura diferente, por eso est\u00e1 dentro de la carpeta <code>stm32f4</code>. Por ejemplo, al portar el c\u00f3digo para PC no tendr\u00eda sentido definir la estructura de una GPIO. La estructura de la FSM del bot\u00f3n en <code>COMMON</code> se muestra en la figura de la FSM.</p> <p>Ahora s\u00ed, comencemos. Preparemos el proyecto para poder a\u00f1adir el bot\u00f3n:</p> <ol> <li> <p>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT de la librer\u00eda del bot\u00f3n correspondientes a la versi\u00f3n <code>V1</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v1. Solo descarga por ahora: <code>port_button.h</code>, <code>stm32f4_button.h</code> y <code>stm32f4_button.c</code> y col\u00f3calos en las carpetas correspondientes de tu proyecto. No a\u00f1adas los ficheros de la parte COMMON.</p> </li> <li> <p>Coloca cada uno donde corresponde: <code>PORT</code> o <code>COMMON</code>, en <code>include</code>, o <code>src</code>. Ten en cuenta que algunos ficheros de <code>PORT</code> est\u00e1n en la carpeta <code>stm32f4</code> porque sus funciones reciben o devuelven estructuras espec\u00edficas de la Nucleo-STM32F446RE.</p> <p>Ver\u00e1s que no compila, y es que solo se te proporciona cierta parte del c\u00f3digo. Los prototipos de gran parte de las funciones p\u00fablicas no est\u00e1n definidos.</p> </li> </ol>"},{"location":"notebook/version_1.html#sec:headers_button","title":"<code>PORT</code>: cabeceras de la librer\u00eda del bot\u00f3n","text":"<p>Vamos a implementar el contrato con el usuario de la parte dependiente del HW de librer\u00eda del bot\u00f3n. Esto es, qu\u00e9 interfaz vamos a proporcionar al usuario para que pueda usar la librer\u00eda y crear tantos botones como necesite. Lo haremos, c\u00f3mo no, para la placa Nucleo-STM32F446RE.</p> <p>Durante todo el desarrollo del proyecto, si detectas que falta alg\u00fan <code>#define</code>, o <code>#include</code>, o declaraci\u00f3n de variable que sea necesaria o que necesite, hazlo. Lo que aqu\u00ed se expone no es algo inmutable, aunque sigue unas buenas pr\u00e1cticas.</p> <p>La figura de plantilla representa las secciones de una plantilla gen\u00e9rica de cabecera que puede utilizar a lo largo del proyecto. El orden no es un est\u00e1ndar, ni las secciones que ah\u00ed aparecen. No obstante, s\u00ed es muy conveniente ser ordenado y met\u00f3dico en programaci\u00f3n. S\u00ed es importante el orden en los siguientes casos:</p> <ul> <li> <p>La inclusi\u00f3n de cabeceras ha de ser lo primero. Es importante el orden en caso de existir dependencias entre ellas.</p> </li> <li> <p>Es aconsejable definir las etiquetas, macros, enumerados\u2026\u00a0justo despu\u00e9s para que puedan ser utilizados en la declaraci\u00f3n y definici\u00f3n de variables. Solo pondremos en el <code>.h</code> aqu\u00e9llas que queramos que sean visibles y utilizadas por otros ficheros. En caso contrario, lo colocaremos en el <code>.c</code>.</p> </li> <li> <p>Si se declara alg\u00fan tipo nuevo de variable, hay que hacerlo antes de que se use en el prototipo de alguna funci\u00f3n. Las funciones que no queramos que sean accesibles por otros ficheros no tendr\u00e1n prototipo, y escribiremos y documentaremos directamente en el <code>.c</code>, adem\u00e1s, se definir\u00e1n como <code>static</code>.</p> </li> </ul> Sugerencia de plantilla gen\u00e9rica de una cabecera. <p>Nuestro bot\u00f3n es el bot\u00f3n de usuario <code>B1</code> de la placa (el azul) ser\u00e1 el bot\u00f3n para arranque y parada del juego. Est\u00e1 conectado a la GPIO PC13. Si lo queremos ver en el osciloscopio, tendremos que pinchar en el pin indicado en el header-Morpho izquierdo, como marca la figura \u201cPinout y funciones header -Morpho izquierdo.\u201d del libro de fundamentos te\u00f3ricos\u00a0<sup>3</sup>. El esquem\u00e1tico del circuito del bot\u00f3n es el que se mostr\u00f3 en la figura del esquem\u00e1tico.</p>"},{"location":"notebook/version_1.html#cabecera-port_buttonh","title":"Cabecera port_button.h","text":"<p>Esta cabecera depende del HW pero no de las particularidades del microcontrolador STM32F446RE. En ella vamos a definir las funciones que el usuario podr\u00e1 usar para gestionar el bot\u00f3n. F\u00edjate que todas las funciones reciben el identificador del bot\u00f3n y solo pueden recibir o devolver variables que NO dependan del microcontrolador. Vamos a seguir los siguientes pasos:</p> <ul> <li> <p>Vamos a definir (<code>#define</code>) dos valores que nombraremos en un consenso con nosotros mismos. Puede cambiarlos si lo desea, pero deber\u00e1n ser los mismos que luego use en el resto del proyecto \u00a1y en los test, si los cambias, tendr\u00e1s que tocar los ficheros de test tambi\u00e9n! Los valores son:</p> </li> <li> <p><code>PORT_USER_BUTTON_ID</code>: valor num\u00e9rico natural que ser\u00e1 el identificador del bot\u00f3n para indicar arranque y parada del juego Simone. Si es nuestro primer y/\u00a0o \u00fanico bot\u00f3n del sistema, le asignaremos el <code>0</code>.</p> </li> <li> <p><code>PORT_USER_BUTTON_DEBOUNCE_TIME_MS</code>: tiempo del anti-rebotes del bot\u00f3n en \\(ms\\).</p> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_button.h</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen. Para que aparezca en la API el campo y su definici\u00f3n, hay que poner <code>/*!\\&lt; aqui_la_definicion */</code> junto al nombre del campo como muestra la figura de ejemplo de Doxygen en enumerados.</p> <p>Comentario de Doxygen en las claves de un enumerado.</p> <p>Puedes partir de los ejemplos dados en el fichero <code>port_system.h</code> y ayudarse con extensa documentaci\u00f3n online. Puede hacerlo en espa\u00f1ol o ingl\u00e9s<sup>2</sup>.</p> </li> </ul> <p>Note</p> <p>Podemos tener ayuda para autocomentar parcialmente el c\u00f3digo con Doxygen. Compruea si tienes instalada la extensi\u00f3n llamada Doxygen Documentation Generator \u2014a veces se instala junto con otras extensiones\u2014; si no la tienes, puedes instalarla. Con esta extensi\u00f3n, si te colocas justo en la l\u0131\u0301nea encima del nombre de la funci\u00f3n y escribes: barra, asterisco, asterisco, enter , colocando el cursor en la tercera posici\u00f3n, como en la imagen, para darle a enter, se genera autom\u00e1ticamente un esqueleto para poder completarlo. Tambi\u00e9n se puede hacer si, colocados justo encima de la funci\u00f3n, damos bot\u00f3n derecho \u2192 Generate Doxygen Comment.</p> <p>Ya hemos acabado con el encabezado que interact\u00faa con el HW del bot\u00f3n y que no depende del microcontrolador. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a programar la cabecera que s\u00ed depende del microcontrolador <code>stm32f4_button.h</code>.</p>"},{"location":"notebook/version_1.html#cabecera-stm32f4_buttonh","title":"Cabecera stm32f4_button.h","text":"<p>Esta cabecera depende del HW y del microcontrolador STM32F446RE. En ella vamos a definir la funci\u00f3n que permitir\u00e1 al usuario asignar una GPIO al bot\u00f3n. En la versi\u00f3n V5, si lo necesitas, puedes a\u00f1adir m\u00e1s funciones que dependan del microcontrolador. Vamos a seguir los siguientes pasos:</p> <ul> <li> <p>Como vamos a hacer uso de funciones de control de las GPIO, vamos a incluir <code>stm32f4xx.h</code>, que nos da acceso a los registros.</p> </li> <li> <p>Vamos a definir (<code>#define</code>) los valores de la GPIO y el pin al que est\u00e1 conectado el bot\u00f3n, y que se indican en la tabla resumen del bot\u00f3n:</p> </li> <li> <p><code>STM32F4_USER_BUTTON_GPIO</code>: GPIO a la que est\u00e1 conectada el bot\u00f3n de usuario en la placa. Pon el nombre de la GPIO. Por ejemplo: <code>GPIOH</code>, si estuviese conectado a la GPIO H. Este nombre, es el de la estructura de <code>CMSIS</code> y se define en <code>stm32f4xx.h</code>. Puedes hacer <code>CTRL + click</code> sobre el nombre de la GPIO para ir a su definici\u00f3n.</p> </li> <li> <p><code>STM32F4_USER_BUTTON_PIN</code>: pin/\u00a0l\u00ednea de la GPIO del bot\u00f3n. Es un n\u00famero entero que va de 0 a 15.</p> </li> <li> <p>En el fichero tenemos que declarar tambi\u00e9n una estructura llamada <code>stm32f4_button_hw_t</code> (ver la [figura del struct]{#fig:stm32f4_button_hw_t}). Esta estructura se pone en el \\ttt{.h} y se hace p\u00fablica para que pueda ser usada por la ISR del bot\u00f3n en el fichero <code>interr.c</code>. Esto es as\u00ed porque a las ISR no se les puede pasar argumentos. En ella se definen los campos que se muestran en la figura.</p> <p>Esta estructura es gen\u00e9rica para cualquier bot\u00f3n que vayamos a usar, no solo el de usuario <code>B1</code>, sino cualquiera que desee a\u00f1adir m\u00e1s tarde.</p> <p>El campo <code>flag_pressed</code> nos indica si el bot\u00f3n se ha pulsado, o no. Ya vimos que cuando pulsamos nuestro bot\u00f3n se produce un flanco de bajada por c\u00f3mo est\u00e1n conectados sus pines (ver figura de rebotes). Son las ISR las que hacen esta interpretaci\u00f3n.</p> </li> <li> <p>Vamos declarar un array de estructuras de tipo <code>stm32f4_button_hw_t</code> como <code>extern</code> que se definir\u00e1 en el fichero fuente <code>stm32f4_button.c</code>. Este array contendr\u00e1 las caracter\u00edsticas de todos los botones que tengamos en el sistema.</p> </li> </ul> <pre><code>extern stm32f4_button_hw_t buttons_arr[];\n</code></pre> <ul> <li>Puede ser buen momento ahora para documentar la funci\u00f3n, la estructura y sus campos, y los <code>#define</code> con Doxygen.</li> </ul> <p>Ya hemos acabado con el encabezado (header) que interact\u00faa con el HW del bot\u00f3n y depende del microcontrolador. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a implementar todas las funciones prototipadas aqu\u00ed y en <code>port_button.h</code>.</p>"},{"location":"notebook/version_1.html#sec:port_button","title":"<code>PORT</code>: fuente de la librer\u00eda del bot\u00f3n","text":"<p>Si observas la API, ver\u00e1s que la FSM del bot\u00f3n hace llamadas a funciones que empiezan por <code>port_</code>. Estas son funciones portables, y el usuario que quiera usar la librer\u00eda de la FSM del bot\u00f3n debe programarlas y adaptarlas a su HW.</p> <p>Vamos a portar las funciones necesarias para usar la librer\u00eda bot\u00f3n y comprobar que la parte HW est\u00e1 bien programada. Lo haremos, c\u00f3mo no, para la placa Nucleo-STM32F446RE. Ya tenemos las cabeceras HW del bot\u00f3n: las que no dependen del microcontrolador (<code>port_button.h</code>) y las que s\u00ed (<code>stm32f4_button.h</code>). Vamos a programar los ficheros fuente de la parte <code>PORT</code>, que todos estar\u00e1n en el fichero <code>stm32f4_button.c</code>. Deber\u00e1s implementar o completar todas las funciones p\u00fablicas de las que ya has declarado el prototipo en el encabezado. Posteriormente completar\u00e1s la ISR asociada al pin del bot\u00f3n que aparece en la API del fichero <code>interr.c</code>.</p>"},{"location":"notebook/version_1.html#fuentes-stm32f4_buttonc","title":"Fuentes stm32f4_button.c","text":"<ol> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Vamos a definir la variable global <code>stm32f4_button_hw_t buttons_arr[]</code> que se declar\u00f3 en el <code>.h</code>. Se trata de un array que no especifica el n\u00famero de elementos que tiene, pero cada uno ser\u00e1 de tipo <code>stm32f4_button_hw_t</code>, que representa al HW de cada bot\u00f3n que tengamos en nuestro sistema.</p> <p>La declaraci\u00f3n e inicializaci\u00f3n de este array podemos hacerla a la vez, que ser\u00e1 lo m\u00e1s aconsejable. Tambi\u00e9n podr\u00edamos hacer solo la declaraci\u00f3n e inicializar los valores de cada bot\u00f3n en una funci\u00f3n aparte \u2014que ahora mismo no tenemos definida\u2014. Convendr\u00eda recordar las secciones correspondientes de los v\u00eddeos de SDG1: inicializaci\u00f3n de arrays y arrays de estructuras.</p> <p>Asigna los valores del bot\u00f3n <code>PORT_USER_BUTTON_ID</code> utilizando los <code>#define</code> de <code>stm32f4_button.h</code>. Deber\u00e1 quedarte algo como lo de la figura de arrays. Si tienes m\u00e1s botones en el sistema, simplemente a\u00f1adir\u00edas una fila para cada bot\u00f3n con sus caracter\u00edsticas correspondientes.</p> <p>Array de botones con las caracter\u00edsticas del bot\u00f3n de usuario.</p> </li> <li> <p>Se os proporciona ya codificada la funci\u00f3n <code>_stm32f4_button_get()</code>. Se trata de una funci\u00f3n privada que devuelve un puntero a la estructura del bot\u00f3n que se le pasa como argumento. Esta funci\u00f3n, aunque prescindible, es \u00fatil para poder hacer un c\u00f3digo m\u00e1s legible y acceder a los campos de la estructura del bot\u00f3n de forma m\u00e1s sencilla desde otras funciones del fichero <code>stm32f4_button.c</code>. \u00a1Recuerda que esta funci\u00f3n es privada y por tanto debe aparecer codificada antes de cualquier funci\u00f3n que la utilice!</p> <p>Si el bot\u00f3n no existe, la funci\u00f3n devuelve <code>NULL</code>. Esto es habitual en funciones que devuelven punteros y es muy \u00fatil para detectar errores en la programaci\u00f3n.</p> </li> <li> <p>Completa la funci\u00f3n <code>port_button_init()</code> como se indica en la API. F\u00edjate c\u00f3mo la parte de c\u00f3digo proporcionada define la variable local <code>*p_button</code> que nos permite acceder al bot\u00f3n. Tambi\u00e9n podr\u00eda haberse hecho con acceso directo al elemento del array de botones <code>buttons_arr[button_id]</code>, pero es m\u00e1s elegante, seguro, y legible hacerlo con la funci\u00f3n <code>_stm32f4_button_get()</code>.</p> <p>Recuerda que es muy importante indicar en el modo de la interrupci\u00f3n del bot\u00f3n que, adem\u00e1s de detectar ambos flancos (subida y bajada), debe habilitar la petici\u00f3n de interrupci\u00f3n (registro <code>EXTI_IMR</code>).</p> </li> <li> <p>Codifica la funci\u00f3n p\u00fablica declarada en el fichero <code>port_button.h</code> siguiendo la API: <code>port_button_get_pressed()</code>.</p> <p>\u00a1Ya hemos acabado con la implementaci\u00f3n de la parte HW <code>stm32f_button.c</code>! Ahora solo queda la ISR asociada al pin del bot\u00f3n para poder probarlo. Vamos a ello.</p> </li> <li> <p>Copia este esqueleto en el documento:</p> <pre><code>void EXTI15_10_IRQHandler(void)\n{\n    /* ISR user button */\n    if (EXTI-&gt;PR &amp; BIT_POS_TO_MASK(buttons_arr[PORT_USER_BUTTON_ID].pin))\n    {\n\n\n    }\n}\n</code></pre> </li> <li> <p>Completa la ISR <code>EXTI15_10_IRQHandler</code> como se indica en la API.</p> <p>Esta ISR es la misma para cualquier elemento que se conecte en las l\u00edneas <code>10-15</code>, y por ello debe identificar cu\u00e1l de ellas ha sido. Es por eso que tenemos la l\u00ednea <code>EXTI-&gt;PR &amp; BIT_POS_TO_MASK(buttons_arr[PORT_USER_BUTTON_ID].pin)</code>, para asegurar que es el bot\u00f3n de usuario.</p> <p>Esta l\u00ednea comprueba si el bit de la posici\u00f3n del pin del bot\u00f3n est\u00e1 activo en el registro Pending Register <code>EXTI_PR</code>. Si es as\u00ed, es porque se ha producido una interrupci\u00f3n en el pin del bot\u00f3n. Es muy importante que borremos el flag de interrupci\u00f3n escribiendo un 1 en el bit correspondiente del registro <code>EXTI_PR</code>.</p> <p>Debemos identificar si el flanco que ha producido la interrupci\u00f3n es de subida o bajada, pues el montaje HW de cada bot\u00f3n puede ser distinto.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>Si ahora compila, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado del bot\u00f3n!. Vamos a probarlo con el test unitario de la parte <code>PORT</code>.</p>"},{"location":"notebook/version_1.html#interrc","title":"interr.c","text":"<p>Abre el fichero <code>interr.c</code> e implementa la ISR <code>EXTI15_10_IRQHandler</code>.</p>"},{"location":"notebook/version_1.html#sec:test_port_v1","title":"<code>PORT</code>: Test unitario del bot\u00f3n","text":"<p>Veremos que la l\u00f3gica de las m\u00e1quinas de estado hacen uso de las funciones portables que acceden al HW del dispositivo. Es por ello que es importante comprobar primero que la parte <code>PORT</code> funciona correctamente. Vamos a hacer el test de HW del c\u00f3digo que hemos desarrollado de la librer\u00eda del bot\u00f3n y probar que funciona antes de continuar con la implementaci\u00f3n de la l\u00f3gica de la parte de la FSM.</p> <p>\u00a1Importante! Los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente. \u00a0Ten a mano y revisa el cap\u00edtulo \u201cTest unitarios y ejemplos de integraci\u00f3n\u201d del libro de fundamentos te\u00f3ricos\u00a0<sup>3</sup>.</p> <p>En esta secci\u00f3n vamos a practicar con el concepto de depuraci\u00f3n (debugging) ( recordar ejercicio de clase en SDG1 y las pruebas de la Gu\u00eda de instalaci\u00f3n con blink <sup>7</sup>).</p> <p>La herramienta m\u00e1s importante y c\u00f3moda que tenemos para depurar es el IDE que usemos. En nuestro caso, como VSCode no es un IDE en s\u00ed mismo, sino un editor de texto vitaminado, tenemos que usar extensiones. La extensi\u00f3n Cortex-Debug para VSCode es la que nos ayudar\u00e1 a depurar.</p> <p>A veces no nos queda otra forma para depurar que imprimir texto por pantalla (cuando esta existe). Recuerde de la Gu\u00eda de instalaci\u00f3n <sup>7</sup> que algunos dispositivos basados en ARM proporcionan una consola de ITM. ITM es una aplicaci\u00f3n de ARM que permite, entre otras cosas, el uso de la funci\u00f3n <code>printf()</code> en depuraci\u00f3n con la placa. Tambi\u00e9n existen alternativas como el semihosting, que env\u00eda mensajes a trav\u00e9s de la pesta\u00f1a de Debug Console de VSCode. Esta es la opci\u00f3n que tenemos configurada en nuestro proyecto. No hay que abusar de ellas, porque no vale para todo. Tendremos que acudir inevitablemente a ver los valores de los registros en alg\u00fan momento. Bien es cierto que, una vez el proyecto est\u00e1 funcionando en producci\u00f3n, puede ser \u00fatil tener trazas (impresas, LEDs, ficheros de log\u2026) para saber qu\u00e9 est\u00e1 pasando en caso de fallo.</p> <p>Descarga el fichero de test HW del bot\u00f3n <code>test_port_button.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v1_test. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto. Puedes eliminar el fichero plantilla <code>test_template.c</code></p> <ol> <li> <p>Conecta la placa Nucleo-STM32\u00a0al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_port_button</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Inmediatamente se habr\u00e1 parado en la primera l\u00ednea del test. Contin\u00faa la depuraci\u00f3n () para ejecutar el test por completo, o pon puntos de parada si deseas ir paso a paso.</p> </li> <li> <p>Se habr\u00e1 impreso por la terminal del <code>gdb-server</code> el resultado de las pruebas de los tests. Deber\u00eda haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu c\u00f3digo hasta que pasen todas las pruebas. Si no pasan las pruebas, no contin\u00faes.</p> </li> <li> <p>La depuraci\u00f3n se queda en bucle en la instrucci\u00f3n <code>exit(UNITY_END())</code>. Para terminar la depuraci\u00f3n pulsa () y repite el proceso hasta que pasen todos los test.</p> <p>Si alg\u00fan test genera una situaci\u00f3n de comportamiento inesperado, puede ser que no termine de ejecutarse. Comprueba d\u00f3nde se queda pausando la depuraci\u00f3n, y lee los mensajes de error que te proporciona el test.</p> </li> </ol> <p>Un ejemplo de ejecuci\u00f3n del test se muestra en la ejecuci\u00f3n de test de la figura. En este caso, la segunda comprobaci\u00f3n ha fallado indic\u00e1ndonos que la GPIO elegida para el bot\u00f3n no es la correcta. Luego aparecen m\u00e1s errores, pero son derivados de este. Corrigi\u00e9ndolo, pasan todos los test correctamente. Por eso, se recomienda arreglar los errores en el orden en que aparecen.</p> Ejecuci\u00f3n de los test unitarios de la parte <code>PORT</code> del bot\u00f3n. <p>\u00a1Ya hemos acabado con la parte <code>PORT</code> del bot\u00f3n! Vamos ahora a implementar la parte <code>COMMON</code> de la librer\u00eda del bot\u00f3n.</p>"},{"location":"notebook/version_1.html#common-cabecera-de-la-fsm-del-boton","title":"<code>COMMON</code>: cabecera de la FSM del bot\u00f3n","text":""},{"location":"notebook/version_1.html#consideraciones-de-la-fsm-del-boton","title":"Consideraciones de la FSM del bot\u00f3n","text":"<p>Antes de empezar vamos a partir de una serie de consideraciones.</p> <ul> <li> <p>La FSM almacena la duraci\u00f3n de la \u00faltima pulsaci\u00f3n de bot\u00f3n.</p> </li> <li> <p>El usuario debe solicitar/\u00a0comprobar la duraci\u00f3n mediante la funci\u00f3n <code>fsm_button_get_duration()</code>.</p> </li> <li> <p>El valor de inicio de duraci\u00f3n al arrancar la FSM, y el de reinicio, debe ser \\(0 ms\\).</p> </li> <li> <p>Un valor de \\(0 ms\\) significa que no ha habido una nueva pulsaci\u00f3n del bot\u00f3n.</p> </li> <li> <p>El usuario debe reiniciar el valor de duraci\u00f3n una vez le\u00eddo, de lo contrario, este valor puede ser malinterpretado por el usuario si se realizan sucesivas comprobaciones sin haber pulsado el bot\u00f3n. En tal caso estar\u00edamos leyendo informaci\u00f3n del pasado. Para reiniciar el valor se debe llamar a la funci\u00f3n <code>fsm_button_reset_duration()</code>.</p> <p>Visto de otro modo, el \u201cflag\u201d de estado de esta FSM es la variable duraci\u00f3n. Una duraci\u00f3n de 0 significa que no ha habido ninguna nueva pulsaci\u00f3n de bot\u00f3n. Un valor distinto de 0 representa que ha sido pulsado y el valor es su duraci\u00f3n. Es por tanto responsabilidad del usuario borrar este \u201cflag\u201d de estado.</p> </li> <li> <p>La FSM contiene informaci\u00f3n del identificador (<code>ID</code>) del bot\u00f3n. Este <code>ID</code> es \u00fanico y gestionado por el usuario en el <code>PORT</code>. Ah\u00ed es donde el usuario proporciona identificadores e informaci\u00f3n HW (GPIO a la que est\u00e1 conectado y tiempo de anti-rebotes) para todos los botones de su sistema.</p> </li> </ul> M\u00e1quina de estados del bot\u00f3n. <p>Nuestra librer\u00eda implementa la l\u00f3gica de la FSM mostrada en la FSM de la figura y que llamaremos <code>fsm_button</code> (en los ficheros <code>.c</code> y <code>.h</code>). Tiene 4 estados porque implementa un mecanismo anti-rebotes SW. Los rebotes de bot\u00f3n o pulsaciones muy r\u00e1pidas que duren menos que el tiempo de anti-rebote (<code>debounce_time</code>), se filtran. Los estados, como muestran la figura, son:</p> <ul> <li> <p><code>BUTTON_RELEASED</code>: es el estado inicial de la FSM. En este estado la FSM est\u00e1 comprobando constantemente si se ha producido un flanco de bajada, i.e., si se ha pulsado el bot\u00f3n. Cuando este se produce, guarda el instante actual y calcula el timeout del tiempo de guarda.</p> </li> <li> <p><code>BUTTON_PRESSED_WAIT</code>: se queda esperando en este estado hasta que ha pasado el tiempo de guarda de anti-rebotes, i.e., hasta que el instante actual es mayor que el timeout. Este es el anti-rebote de bajada. Al salir, no hace nada (funci\u00f3n, <code>NULL</code>).</p> </li> <li> <p><code>BUTTON_PRESSED</code>: en este estado se queda mientras no se suelte el bot\u00f3n. Saldr\u00e1 de \u00e9l cuando se haya detectado un flanco de subida. Ya ha pasado el tiempo de guarda, por lo que si es un rebote, se detectar\u00e1 como falso (ver ). Cuando el flanco de subida se produce, se calcula la duraci\u00f3n de la pulsaci\u00f3n.</p> </li> <li> <p><code>BUTTON_RELEASED_WAIT</code>: se queda esperando en este estado hasta que ha pasado el tiempo de guarda de anti-rebotes, i.e., hasta que el instante actual es mayor que el timeout. Este es el anti-rebote de subida. Al salir, no hace nada (funci\u00f3n, <code>NULL</code>).</p> </li> </ul> <p>La parte <code>COMMON</code> de nuestra librer\u00eda trabaja con la estructura (<code>struct</code>) p\u00fablica que se muestra en la . Con p\u00fablica queremos decir que est\u00e1 declarada en el fichero <code>.h</code> y no el el <code>.c</code>, por lo que otros ficheros pueden declarar variables de este tipo. No obstante, los campos de la estructura son privados y no deben ser accesibles desde fuera de la librer\u00eda.</p> <ol> <li>Lo primero, descarga del repositorio de la asignatura los ficheros correspondientes a la parte COMMON de la librer\u00eda del bot\u00f3n correspondientes a la versi\u00f3n <code>V1</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v1. Solo descarga lo que faltaba por implementar, es decir, los ficheros <code>fsm_button.h</code> y <code>fsm_button.c</code> y ponlos en las carpetas correspondientes de tu proyecto.</li> </ol> <p>Ahora, vamos a completar la cabecera de la FSM del bot\u00f3n, <code>fsm_button.h</code>.</p> <ol> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Ahora vamos a definir el enumerado con los nombres de los 4 estados de la FSM. Escribe un <code>enum</code> <code>FSM_BUTTON</code> con los nombres de los estados del diagrama de la separados por <code>,</code>. No olvides poner un <code>;</code> al final del <code>enum</code>.</p> </li> <li> <p>Seguidamente declararemos la estructura <code>fsm_button_t</code> para hacerla p\u00fablica como indica la figura de la estructura de la FSM.</p> </li> <li> <p>Es buen momento para aprovechar a documentar la estructura, del mismo modo que se hizo anteriormente y se muestra en la figura de comentario.</p> <p>Comentario de Doxygen en un campo de una estructura.</p> <p>Continuamos con las declaraciones de funciones p\u00fablicas de la librer\u00eda. Procedamos:</p> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>fsm_button.h</code>.</p> <p>Como puedes intuir, estas no son todas las funciones de la librer\u00eda, sino solo aquellas que podr\u00e1n ser llamadas desde el exterior. Hemos establecido un criterio general por el que diremos que, si una funci\u00f3n va a ser accesible desde el exterior, el nombre de la funci\u00f3n debe empezar por <code>fsm_</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen. En este caso, la documentaci\u00f3n va encima del nombre de cada funci\u00f3n.</p> </li> </ol> <p>Ya hemos acabado con el encabezado. Quiz\u00e1s de errores al compilar. Vamos ahora a programar el fichero fuente <code>fsm_button.c</code>.</p>"},{"location":"notebook/version_1.html#common-fuente-de-la-fsm-del-boton","title":"<code>COMMON</code>: fuente de la FSM del bot\u00f3n","text":"<p>Vamos a proceder con la implementaci\u00f3n de las funciones del bot\u00f3n. Deber\u00e1s implementar todas las funciones p\u00fablicas de las que ya has declarado el prototipo en el encabezado, y el resto de funciones privadas que aparecen en la API del fichero <code>fsm_button.c</code>. Tambi\u00e9n definiremos las variables globales y estructuras que sean necesarias. \u00a1Recuerda que las funciones privadas no se declaran en el <code>.h</code>!</p> <ol> <li> <p>Lo primero que debe aparecer es la inclusi\u00f3n de cabeceras; en nuestro caso <code>fsm_button.h</code>, <code>port_button.h</code>, y <code>port_system.h</code> como indica la API.</p> <p>Ahora empezamos a codificar las funciones privadas de la FSM. Empezaremos con las funciones de entrada o comprobaci\u00f3n de la FSM. Hemos establecido un criterio general por el que, si una funci\u00f3n es de entrada o comprobaci\u00f3n, ser\u00e1 privada y est\u00e1tica, y el nombre de la funci\u00f3n va empezar por <code>check_</code> (porque comprueba la condici\u00f3n de salto de la m\u00e1quina de estados). Es muy importante aqu\u00ed que hayas entendido bien los ejemplos con FSM de los tutoriales  \u201cCap\u00edtulo 2. Introducci\u00f3n a las m\u00e1quinas de estados en C\u201d y \u201cCap\u00edtulo 3. M\u00e1quinas de Estados Combinadas\u201d.</p> <p>IMPORTANTE</p> <p>Si te fijas en la API, todas las funciones de la m\u00e1quina de estados reciben el mismo argumento: <code>fsm_t*</code>, un puntero a una m\u00e1quina de estados. </p> <p><code>fsm_button_t *p_fsm = (fsm_button_t *)(p_this);</code></p> <p>Esto es as\u0131\u0301 porque la librer\u0131\u0301a <code>fsm.c</code> no sabe qu\u00e9 tipo de m\u00e1quina de estados es. Nosotros sabemos que esta m\u00e1quina de estados es una m\u00e1quina con esteroides porque incluye, adem\u00e1s, la estructura del bot\u00f3n. En realidad es tipo <code>fsm_button_t*</code>, un puntero a una m\u00e1quina de estados de la estructura del bot\u00f3n, que por tener en su primer campo una <code>fsm_t*</code>, podemos hacer un cast y convertirla. As\u0131\u0301 pues, en las funciones de la m\u00e1quina de estados, siempre tendremos que recuperar nuestro tipo haciendo este cast como nos dice la API y hace, por ejemplo, la funci\u00f3n <code>fsm_button_init()</code>. En el resto de funciones que no se pasen a la librer\u0131\u0301a <code>fsm.c</code>, trabajaremos directamente con el tipo <code>fsm_button_t*</code> que hemos creado.</p> </li> <li> <p>Codifica la funci\u00f3n <code>check_button_pressed()</code> como se indica en la API.</p> </li> <li> <p>Codifica la funci\u00f3n <code>check_button_released()</code> como se indica en la API.</p> </li> <li> <p>Codifica la funci\u00f3n <code>check_timeout()</code> como se indica en la API.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen. En este caso, como las funciones no est\u00e1n declaradas en el encabezado, la documentaci\u00f3n ir\u00e1 en el <code>.c</code>, encima del nombre de cada funci\u00f3n.</p> <p>Seguiremos con las funciones de salida o actualizaci\u00f3n de la FSM. Hemos establecido el criterio de que, una funci\u00f3n de salida o actualizaci\u00f3n ser\u00e1 privada y est\u00e1tica, y el nombre de la funci\u00f3n empezar\u00e1 por <code>do_</code> (porque va a hacer algo). Hay veces que no hay que hacer nada, por lo que para la librer\u00eda <code>fsm.c</code> ser\u00e1 suficiente que apunte a <code>NULL</code>. Esto en el diagrama de la se ha representado como <code>n/a</code>.</p> </li> <li> <p>Codifica la funci\u00f3n <code>do_store_tick_pressed()</code> como se indica en la API.</p> </li> <li> <p>Codifica la funci\u00f3n <code>do_set_duration()</code> como se indica en la API.</p> </li> <li> <p>Documenta las funciones con Doxygen. En este caso, igual que antes, la documentaci\u00f3n ir\u00e1 en el <code>.c</code>, encima del nombre de cada funci\u00f3n.</p> <p>Error de compilaci\u00f3n durante el desarrollo de <code>fsm_button.c</code>.</p> <p>Todav\u00eda no hemos acabado con el desarrollo, pero vamos a compilar para ir depurando errores. Compile el programa. Ver\u00e1 errores parecidos a los que se muestran en la figura de error. El compilador a veces nos da alguna sugerencia de correcci\u00f3n, pero no tienen por qu\u00e9 ser correctas. Nos dice que:</p> <ul> <li> <p>Hay una variable que no est\u00e1 declarada y que se llama <code>fsm_trans_button</code>. Se trata de la tabla de transiciones. A\u00fan tenemos que escribirla.</p> </li> <li> <p>Todas nuestras funciones <code>check_</code> y <code>do_</code> est\u00e1n declaradas pero no se usan.</p> <p>\u00bfPor qu\u00e9 no dice lo mismo de las funciones p\u00fablicas que est\u00e1n declaradas en el <code>.h</code> y tampoco se usan? Pues porque son p\u00fablicas. El compilador no sabe qui\u00e9n las podr\u00e1 usar y ah\u00ed est\u00e1n declaradas para qui\u00e9n la pueda llamar. \u00bfPor qu\u00e9 en el <code>.c</code> da error? Porque en el <code>Makefile</code> \u2014donde est\u00e1n las reglas de compilaci\u00f3n\u2014, igual que tenemos el flag para que nos d\u00e9 error si la variable no se usa, lo mismo pasa con las funciones. Esto es \u00fatil para evitar generar c\u00f3digos sucios con funciones que no sirven.</p> <p>\u00bfQui\u00e9n va a usar las funciones de la m\u00e1quina de estados? Pues las va a usar, mediante indirecci\u00f3n, la librer\u00eda <code>fsm.c</code>. \u00bfC\u00f3mo? Porque le vamos a pasar a la funci\u00f3n <code>fsm_fire()</code> la tabla de transiciones. Y es ah\u00ed, donde vamos a \u201cusar\u201d estas funciones. \u00bfY d\u00f3nde se llama a <code>fsm_fire</code>? Ya lo haremos, pero se hace en <code>fsm_button_fire()</code>, que a su vez es llamada por el <code>main</code>.</p> </li> <li> <p>Si las us\u00e1semos, aparecer\u00eda el error de que hay funciones que no est\u00e1n declaradas (implicit declaration). Son las llamadas a funciones del <code>PORT</code>, que m\u00e1s tarde codificaremos.</p> </li> </ul> <p>Mucha informaci\u00f3n hasta ahora, pero ver\u00e1 c\u00f3mo se aclara todo enseguida. Vamos a codificar la tabla (array) de transiciones de la FSM del bot\u00f3n.</p> </li> <li> <p>Definimos <code>static fsm_trans_t fsm_trans_button[] = ...</code> justo despu\u00e9s de la funci\u00f3n <code>do_set_duration()</code>.</p> <p>Recuerda que cada fila de la tabla de transiciones tiene la forma: <code>EstadoIni, FuncCompruebaCondicion, EstadoSig, FuncAccionesSiTransicion</code>. No olvides a\u00f1adir la fila <code>-1, NULL, -1, NULL</code> que sirve a la librer\u00eda <code>fsm.c</code> para detectar el fin de la tabla.</p> <p>\u00bfPor qu\u00e9 es importante haber colocado la tabla en este punto? Bueno, puede ser en cualquier punto despu\u00e9s de las funciones <code>check_</code> y <code>do_</code>, porque de lo contrario, de estar m\u00e1s arriba, al compilar, la tabla de transiciones estar\u00eda haciendo referencia a funciones que todav\u00eda no se sabe que existen (\u00a1porque son privadas y no est\u00e1n en el <code>.h</code>!).</p> <p>Si ahora compilas, ver\u00e1s que han desaparecido muchos errores. Ya queda menos para acabar la implementaci\u00f3n de la librer\u00eda de la m\u00e1quina de estados. Prosigamos:</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_button_get_duration()</code> como se indica en la API. Esta funci\u00f3n nos servir\u00e1 en el programa principal para preguntar cu\u00e1nto tiempo ha durado la pulsaci\u00f3n.</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_button_reset_duration()</code> como se indica en la API. Con esta, reiniciaremos el valor de la duraci\u00f3n a \\(0 ms\\) tras leerlo.</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_button_get_debounce_time_ms()</code> como se indica en la API. Esta funci\u00f3n ser\u00e1 usada en los test unitarios.</p> </li> <li> <p>Completa la funci\u00f3n <code>fsm_button_init()</code> como se indica en la API.</p> <p>F\u00edjate en las funciones <code>fsm_button_fire()</code>, <code>fsm_button_get_inner_fsm()</code>, y <code>fsm_button_get_state()</code> dadas, que implementaremos tambi\u00e9n sucesivas versiones. Estas funciones sirven para lanzar y acceder a la m\u00e1quina de estados (<code>f</code>) y acceder al campo estado (<code>f.current_state</code>). Ser\u00e1n usadas en el test unitario de la m\u00e1quina de estados, y son \u00fatiles para depurar.</p> <p>Ya hemos acabado con la programaci\u00f3n de la librer\u00eda del bot\u00f3n. Toda esta l\u00f3gica <code>COMMON</code> puede ser usada en cualquier sistema, est\u00e9 basado en microcontrolador, o sea un PC. Hemos hecho una librer\u00eda de un bot\u00f3n que tiene un anti-rebotes y nos devuelve la duraci\u00f3n de la \u00faltima pulsaci\u00f3n. As\u00ed pues, si compilas, no deber\u00e1n aparecer errores.</p> </li> <li> <p>Documenta el c\u00f3digo que est\u00e9 sin comentar.</p> </li> </ol>"},{"location":"notebook/version_1.html#sec:test_fsm_v1","title":"<code>COMMON</code> Test unitario de la FSM del bot\u00f3n","text":"<p>Vamos a hacer el test del c\u00f3digo que hemos desarrollado de la librer\u00eda de la m\u00e1quina de estados del bot\u00f3n y probar que funciona antes de continuar con la siguiente versi\u00f3n.</p> <p>\u00a1Importante! Recuerda que los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente.</p> <p>Descarga el fichero de test de la FSM del bot\u00f3n <code>test_fsm_button.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v1_test. Ponlo en la carpeta <code>test/</code> de tu proyecto. \u00a1No lo metas en stm32f4/, pues no es un test espec\u00edfico del microcontrolador!</p> <ol> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_fsm_button</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso.</p> </li> <li> <p>Se habr\u00e1 impreso por la terminal del <code>gdb-server</code> el resultado de las pruebas de los tests. Deber\u00eda haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu c\u00f3digo hasta que pasen todas las pruebas. Si no pasan las pruebas, no contin\u00faes.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pasen todos los test.</p> </li> </ol>"},{"location":"notebook/version_1.html#ejemplo-de-uso-de-la-version-1","title":"Ejemplo de uso de la Versi\u00f3n 1","text":"<p>Com\u00fanmente llamado test de integraci\u00f3n, es un c\u00f3digo de ejemplo que consiste en probar la librer\u00eda en el sistema final, o en una versi\u00f3n particular, con el resto de librer\u00edas y m\u00f3dulos. El test de integraci\u00f3n no hace uso de la librer\u00eda <code>unity</code>, sino que es como un peque\u00f1o programa de prueba sobre las funciones que hemos implementado. Tiene su propio <code>main</code>.</p> <p>En los test de integraci\u00f3n es responsabilidad del alumno comprobar que la funcionalidad es la esperada, porque aqu\u00ed no hay test unitarios que nos ayuden.</p> <p>Nuestra librer\u00eda de bot\u00f3n devuelve la duraci\u00f3n de la \u00faltima pulsaci\u00f3n. As\u00ed pues, algunas de las comprobaciones que podemos hacer son: que la duraci\u00f3n de la pulsaci\u00f3n es la que esperamos, que se reinicia adecuadamente el valor, que se funciona el anti-rebotes\u2026</p> <p>Descarga el fichero de ejemplo <code>example1.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v1_test. Ponlo en la carpeta <code>example/</code> de tu proyecto.</p> <p>Procedamos:</p> <ol> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>example_v1</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Se parar\u00e1 en la primera l\u00ednea del <code>main()</code>. Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso. Este c\u00f3digo no termina, pues es un bucle <code>while</code> infinito.</p> </li> <li> <p>Abre la terminal del <code>gdb-server</code> para ver los mensajes que se van imprimiendo.</p> </li> <li> <p>Pulsa el bot\u00f3n de usuario <code>B1</code> de la placa. Deber\u00edas ver que se imprime por pantalla la duraci\u00f3n de la pulsaci\u00f3n. Si no es as\u00ed, revisa tu c\u00f3digo.</p> </li> <li> <p>Haz distintas pruebas y aseg\u00farate de que el comportamiento es el adecuado.</p> </li> </ol> <p>\u00a1Hemos creado nuestra primera librer\u00eda! F\u00edjate que es portable a cualquier plataforma solo con adaptar las funciones del <code>PORT</code>.</p> <p>No dejes de documentar el c\u00f3digo. Comprueba que la documentaci\u00f3n del c\u00f3digo se ha generado correctamente como se explica en la \u201cGu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C\u201d <sup>7</sup>., o en el v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d.</p> <p>Guarda una copia de su proyecto como <code>simone_v1</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla.</p> <ol> <li> <p>No nos hacemos responsables de posibles da\u00f1os que puedas ocasionar\u00a0.\u00a0\u21a9</p> </li> <li> <p>Se recomienda documentar sus c\u00f3digos siempre en ingl\u00e9s, aunque su nivel no sea muy bueno, porque si trabajamos en una empresa, no sabemos qui\u00e9n lo tendr\u00e1 que leer.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> <li> <p>Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Josu\u00e9 Pag\u00e1n Ortiz, and Alberto Bosc\u00e1 Mojena. Tutoriales sobre los fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Daniel Capell\u00e1n Mart\u00edn, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Amadeo de Gracia Herranz. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"notebook/version_2.html","title":"Versi\u00f3n 2: teclado matricial","text":"<p>En la versi\u00f3n anterior aprendimos a gestionar un \u00fanico bot\u00f3n mediante interrupciones. Sin embargo, \u00bfqu\u00e9 ocurre si nuestro sistema necesita 12, 16 o m\u00e1s botones? Si utiliz\u00e1ramos la estrategia anterior, necesitar\u00edamos una l\u00ednea de interrupci\u00f3n y un pin GPIO por cada bot\u00f3n, agotando r\u00e1pidamente los recursos del microcontrolador.</p> <p>Para solucionar esto, utilizamos la t\u00e9cnica del barrido o scanning en un teclado matricial. Esta t\u00e9cnica aprovecha la persistencia temporal para leer muchos pulsadores utilizando pocos pines, organiz\u00e1ndolos en filas y columnas.</p> <p>Bibliograf\u00eda</p> <ol> <li> <p>\u201cFundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>1</sup></p> </li> <li> <p>Datasheet \u201cSTM32F446xC/E\u201d <sup>2</sup></p> </li> <li> <p>Reference manual \u201cRM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>3</sup></p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Demostraci\u00f3n Simone</p> </li> <li> <p>Blink LED y manejo de proyecto</p> </li> <li> <p>Conceptos b\u00e1sicos de C (canal SDG1)</p> </li> <li> <p>[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen</p> </li> </ul> <p>En este cap\u00edtulo vamos a crear una librer\u00eda que nos permita gestionar un teclado matricial de 4x4 (16 teclas). A diferencia del bot\u00f3n, que funcionaba solo ten\u00edamos una interrupci\u00f3n, aqu\u00ed utilizaremos un temporizador que nos interrumpe para realizar una excitaci\u00f3n peri\u00f3dica de las filas y esperaremos interrupciones de las columnas.</p> <p>Como ya hicimos en las versiones anteriores, (i) vamos a implementar la parte portable <code>PORT</code> dependiente del HW para gestionar los niveles l\u00f3gicos de las filas y la lectura de las columnas, y lo probaremos con un test unitario. (ii) Despu\u00e9s, vamos a crear la l\u00f3gica de la FSM para gestionar el barrido y el anti-rebotes (la parte <code>COMMON</code>), y lo probaremos con un test unitario. (iii) Por \u00faltimo, montaremos el HW y probaremos el funcionamiento con un programa de ejemplo.</p> <p>El teclado matricial es un array de pulsadores conectados en intersecciones de filas y columnas. Cuando no se pulsa ninguna tecla, no hay conexi\u00f3n entre filas y columnas. Al pulsar una tecla, se cortocircuita una fila con una columna espec\u00edfica. Las caracter\u00edsticas a destacar del sistema de la Versi\u00f3n 2 se muestran en la siguiente tabla.</p> Par\u00e1metro Valor Filas Salidas (GPIO Out) Columnas Entradas con Pull-Up/Down L\u00f3gica Barrido secuencial Timer de escaneo aprox. Anti-rebotes Software <p>Caracter\u00edsticas del teclado matricial en Versi\u00f3n 2.</p> <p>La t\u00e9cnica de barrido consiste en poner una fila a un nivel l\u00f3gico activo (por ejemplo, '0' si usamos resistencias pull-up en las columnas) y leer el estado de las columnas. Si alguna columna detecta ese '0', sabemos qu\u00e9 tecla exacta (intersecci\u00f3n Fila-Columna) se ha pulsado. Este proceso se repite para todas las filas muy r\u00e1pidamente.</p> Esquem\u00e1tico de conexi\u00f3n del teclado matricial 4x4. <p>Igual que hemos hecho hasta ahora, estamos desarrollando una librer\u00eda. As\u00ed, cada vez que se quiera a\u00f1adir un teclado, le asociaremos una FSM. Las particularidades de d\u00f3nde est\u00e1n conectadas las filas y columnas son cosas espec\u00edficas del HW, por lo que estar\u00e1n en <code>PORT</code>.</p> <p>La muestra las estructuras que vamos a necesitar para el teclado. La estructura del HW del teclado (en <code>PORT</code>) se muestra en la . La estructura de la FSM (en <code>COMMON</code>) se muestra en la .</p>"},{"location":"notebook/version_2.html#section_v2","title":"{ #section_v2 }","text":"<p>Preparemos el proyecto para poder a\u00f1adir el teclado matricial:</p> <ol> <li>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT de la librer\u00eda del teclado correspondientes a la versi\u00f3n <code>V2</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v2. Solo descarga por ahora: <code>port_keyboard.h</code>, <code>stm32f4_keyboard.h</code>, y <code>stm32f4_keyboard.c</code> y col\u00f3calos en las carpetas correspondientes. No a\u00f1adas los ficheros de la parte COMMON.</li> <li>Coloca cada uno donde corresponde: <code>PORT</code> o <code>COMMON</code>, en <code>include</code>, o <code>src</code>.</li> </ol>"},{"location":"notebook/version_2.html#sec:headers_keyboard","title":"<code>PORT</code>: cabeceras de la librer\u00eda del teclado","text":"<p>Vamos a implementar el contrato con el usuario de la parte dependiente del HW de librer\u00eda del teclado. Esta interfaz permitir\u00e1 definir cu\u00e1ntas filas y columnas tiene nuestro teclado y qu\u00e9 caracteres representa cada tecla. Comenzaremos de nuevo por la cabecera y luego los c\u00f3digos fuente.</p>"},{"location":"notebook/version_2.html#cabecera-port_keyboardh","title":"Cabecera port_keyboard.h","text":"<p>Esta cabecera depende del HW pero no de las particularidades del microcontrolador STM32F446RE. Vamos a seguir los siguientes pasos:</p> <ul> <li>Incluye todas las cabeceras necesarias seg\u00fan indica la API.</li> <li>Incluye los (<code>#define</code>) necesarios para el teclado, como el identificador <code>PORT_KEYBOARD_ID</code> que usaremos en el proyecto Simone.</li> <li>Define tambi\u00e9n el mapa de caracteres. Esto suele hacerse mediante un array bidimensional o defines espec\u00edficos para cada posici\u00f3n <code>(fila, columna)</code>.</li> <li>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_keyboard.h</code>. Necesitaremos funciones para inicializar el barrido y para leer el estado de las columnas.</li> <li>Puede ser buen momento ahora para documentar con Doxygen.</li> </ul>"},{"location":"notebook/version_2.html#cabecera-stm32f4_keyboardh","title":"Cabecera stm32f4_keyboard.h","text":"<p>Esta cabecera define los pines f\u00edsicos a los que est\u00e1n conectadas las filas y columnas del teclado en nuestra placa Nucleo-STM32F446RE.</p> <ul> <li>Incluye todas las cabeceras necesarias.</li> <li>Define (<code>#define</code>) los valores de las GPIO y pines para las 4 Filas (<code>ROW</code>) y las 3 o 4 Columnas (<code>COL</code>). Es recomendable usar nombres descriptivos como <code>STM32F4_KEYBOARD_ROW_1_PIN</code>, etc.</li> <li>Documenta los <code>#define</code> con Doxygen.</li> </ul> <p>Ya hemos acabado con el encabezado (header) que interact\u00faa con el HW. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a implementar todas las funciones prototipadas en <code>port_keyboard.h</code>.</p>"},{"location":"notebook/version_2.html#sec:port_keyboard","title":"<code>PORT</code>: fuente de la librer\u00eda del teclado","text":"<p>Vamos a portar las funciones necesarias para controlar los pines del teclado. Programaremos los ficheros fuente de la parte <code>PORT</code>, que todos estar\u00e1n en el fichero <code>stm32f4_keyboard.c</code>.</p>"},{"location":"notebook/version_2.html#fuentes-stm32f4_keyboardc","title":"Fuentes stm32f4_keyboard.c","text":"<p>La complejidad aqu\u00ed reside en la gesti\u00f3n de m\u00faltiples pines y en la l\u00f3gica de configuraci\u00f3n de entrada/salida.</p> <ol> <li>Incluye las librer\u00edas necesarias.</li> <li>Define la estructura <code>stm32f4_keyboard_hw_t</code>. A diferencia del bot\u00f3n simple, esta estructura debe contener arrays o listas de los pines correspondientes a las filas y a las columnas.</li> <li>Define la variable global privada <code>static stm32f4_keyboard_hw_t keyboards_arr <p> con la configuraci\u00f3n f\u00edsica de nuestro teclado. 4. Codifica la funci\u00f3n <code>_stm32f4_keyboard_get()</code> para recuperar la configuraci\u00f3n del hardware.</p> <p>Ahora vamos a codificar las funciones que permiten la magia del barrido:</p> <ol> <li>Codifica la funci\u00f3n <code>port_keyboard_init()</code>. Esta funci\u00f3n es cr\u00edtica:</li> <li>Debe configurar los pines de las FILAS como salidas digitales.</li> <li>Debe configurar los pines de las COLUMNAS como entradas digitales con resistencia de pull-up (o pull-down seg\u00fan tu dise\u00f1o).</li> <li> <p>Inicialmente, pon todas las filas en estado inactivo (alto si usas pull-up en columnas, o bajo si usas pull-down).</p> </li> <li> <p>Codifica la funci\u00f3n <code>port_keyboard_set_row()</code>. Esta funci\u00f3n recibe un \u00edndice de fila y un valor (0 o 1). Su misi\u00f3n es escribir en el pin f\u00edsico correspondiente a esa fila.</p> </li> <li>Codifica la funci\u00f3n <code>port_keyboard_get_cols()</code>. Esta funci\u00f3n debe leer el estado de todos los pines de columna y devolver un valor (puede ser una m\u00e1scara de bits o un booleano compuesto) que indique si alguna columna est\u00e1 activa.</li> </ol> <p>Si ahora compila, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado del teclado! Vamos a probarlo con el test unitario de la parte <code>PORT</code>.</p>"},{"location":"notebook/version_2.html#sec:test_port_v2","title":"<code>PORT</code>: Test unitario del teclado","text":"<p>Antes de intentar detectar pulsaciones complejas con la FSM, debemos asegurarnos de que podemos encender las filas y leer las columnas correctamente.</p> <p>\u00a1Importante! Revisa que las conexiones f\u00edsicas coincidan con los defines de tu cabecera.</p> <p>Descarga el fichero de test HW del teclado <code>test_port_keyboard.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>test/stm32f4</code>.</p> <ol> <li>Conecta la placa y el teclado matricial.</li> <li>Pulsa sobre el icono de depuraci\u00f3n { .inline-img }.</li> <li>Selecciona el test <code>test_port_keyboard</code>.</li> <li>Este test probablemente te pedir\u00e1 que pulses teclas espec\u00edficas (ej: \"Pulsa la tecla de la Fila 1, Columna 1\") y verificar\u00e1 si el software detecta el cambio de nivel l\u00f3gico.</li> <li>Comprueba que todos los test pasan correctamente.</li> </ol> <p>\u00a1Ya hemos acabado con la parte <code>PORT</code>! Vamos ahora a implementar la parte <code>COMMON</code>.</p>"},{"location":"notebook/version_2.html#common-cabecera-de-la-fsm-del-teclado","title":"<code>COMMON</code>: cabecera de la FSM del teclado","text":""},{"location":"notebook/version_2.html#consideraciones-fsm-keyboard","title":"Consideraciones de la FSM del teclado","text":"<p>Antes de empezar, entendamos c\u00f3mo funciona el barrido l\u00f3gico.</p> <ul> <li>La FSM no lee todo el teclado de golpe. En cada ciclo (o tick), activa una fila, espera un instante para que la se\u00f1al se estabilice, lee las columnas y luego desactiva la fila para pasar a la siguiente.</li> <li>Necesitaremos gestionar el anti-rebotes (debouncing) igual que con el bot\u00f3n, pero teniendo en cuenta que estamos saltando de fila en fila.</li> <li>La FSM debe almacenar la \u00faltima tecla v\u00e1lida pulsada en el campo <code>key</code> de su estructura.</li> </ul> M\u00e1quina de estados del Teclado Matricial. <p>Nuestra librer\u00eda implementa la l\u00f3gica de la FSM mostrada en la y que llamaremos <code>fsm_keyboard</code>. Los estados principales son:</p> <ul> <li><code>WAIT_ROW</code>: Estado de espera. La FSM aguarda a que el temporizador indique que es momento de escanear la siguiente fila.</li> <li><code>SCAN_COL</code>: Se ha activado una fila. En este estado se leen las columnas para ver si hay alguna tecla pulsada en dicha fila.</li> <li><code>KEY_PRESSED</code>: Se ha detectado una pulsaci\u00f3n. Aqu\u00ed se realiza la validaci\u00f3n (anti-rebotes) y se decodifica qu\u00e9 tecla es bas\u00e1ndose en la fila activa y la columna detectada.</li> <li> <p><code>KEY_RELEASED</code>: Esperamos a que el usuario suelte la tecla para evitar lecturas m\u00faltiples de una sola pulsaci\u00f3n.</p> </li> <li> <p>Descarga los ficheros <code>fsm_keyboard.h</code> y <code>fsm_keyboard.c</code> de la parte COMMON.</p> </li> </ul> <p>Ahora, vamos a completar la cabecera <code>fsm_keyboard.h</code>.</p> <ol> <li>Incluye las librer\u00edas necesarias.</li> <li>Define el enumerado <code>FSM_KEYBOARD</code> con los estados descritos.</li> <li>Define la estructura <code>fsm_keyboard_t</code>. Recuerda que debe comenzar con el objeto <code>fsm_t</code>. Necesitar\u00e1 campos para almacenar:</li> <li>El <code>ID</code> del teclado.</li> <li>La fila actual que se est\u00e1 escaneando (<code>current_row</code>).</li> <li>La tecla detectada (<code>key_pressed</code>).</li> <li> <p>Punteros a funciones o tablas para mapear coordenadas (fila, col) a caracteres ASCII.</p> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas como <code>fsm_keyboard_get_key()</code> o <code>fsm_keyboard_reset()</code>.</p> </li> </ol>"},{"location":"notebook/version_2.html#common-fuente-de-la-fsm-del-teclado","title":"<code>COMMON</code>: fuente de la FSM del teclado","text":"<p>Vamos a implementar la l\u00f3gica de barrido en <code>fsm_keyboard.c</code>.</p> <ul> <li>Incluye las cabeceras necesarias.</li> <li>Implementa la estructura opaca si no lo hiciste en el .h.</li> </ul> <p>Funciones privadas (Entrada/Salida):</p> <ol> <li>Codifica las funciones de chequeo <code>check_</code>. Por ejemplo, <code>check_timer_expire()</code> verificar\u00e1 si ha pasado el tiempo suficiente para saltar a la siguiente fila. <code>check_col_active()</code> leer\u00e1 del puerto si hay pulsaci\u00f3n.</li> <li>Codifica las funciones de acci\u00f3n <code>do_</code>.</li> <li><code>do_next_row()</code>: Incrementa el \u00edndice de fila, hace wrap-around si llega al final, y llama a <code>port_keyboard_set_row()</code> para activar la nueva fila f\u00edsicamente.</li> <li><code>do_save_key()</code>: Si se detecta pulsaci\u00f3n, cruza el dato de la fila actual y la columna le\u00edda con tu mapa de caracteres para guardar el valor en <code>key_pressed</code>.</li> </ol> <p>Tabla de Transiciones:</p> <ol> <li>Declara la tabla <code>fsm_trans_keyboard</code>. Aseg\u00farate de cubrir el ciclo completo: esperar timer -&gt; activar fila -&gt; leer columnas -&gt; (si nada) esperar timer... o (si pulsaci\u00f3n) -&gt; gestionar pulsaci\u00f3n.</li> </ol> <p>Funciones P\u00fablicas:</p> <ol> <li>Codifica <code>fsm_keyboard_fire()</code>.</li> <li>Codifica <code>fsm_keyboard_get_key_value()</code> para que el usuario pueda recuperar la tecla detectada.</li> <li>Completa la inicializaci\u00f3n en <code>fsm_keyboard_init()</code>.</li> </ol> <p>\u00a1Ya hemos acabado con la programaci\u00f3n de la librer\u00eda del teclado!</p>"},{"location":"notebook/version_2.html#sec:test_fsm_v2","title":"<code>COMMON</code> Test unitario de la FSM del teclado","text":"<p>Vamos a verificar que la l\u00f3gica de barrido funciona independientemente del hardware (usando mocks o simulaci\u00f3n de puertos en el test).</p> <p>\u00a1Importante! Los test comprueban la l\u00f3gica de estados, no si tu cableado est\u00e1 bien.</p> <p>Descarga <code>test_fsm_keyboard.c</code> y ponlo en la carpeta <code>test/</code>.</p> <ol> <li>Selecciona el test <code>test_fsm_keyboard</code> en tu entorno de depuraci\u00f3n.</li> <li>Ejecuta el test. Este simular\u00e1 el paso del tiempo y las se\u00f1ales de columnas para verificar que la FSM transiciona correctamente y decodifica el car\u00e1cter esperado.</li> <li>Si falla, usa el depurador para ver en qu\u00e9 estado se queda la m\u00e1quina.</li> </ol>"},{"location":"notebook/version_2.html#ejemplo-de-uso-de-la-version-2","title":"Ejemplo de uso de la Versi\u00f3n 2","text":"<p>Vamos a integrar todo. Crearemos un peque\u00f1o programa que escanee el teclado y env\u00ede por puerto serie (o muestre en depuraci\u00f3n) la tecla pulsada.</p> <p>Descarga <code>example2.c</code> y ponlo en <code>example/</code>.</p> <p>Procedamos:</p> <ol> <li>Monta el teclado matricial con la placa Nucleo-STM32.</li> <li>Ejecuta el ejemplo <code>example_v2</code>.</li> <li>Abre la terminal o pon un breakpoint donde se lea la tecla.</li> <li>Pulsa varias teclas y verifica que el car\u00e1cter recibido coincide con la etiqueta f\u00edsica de la tecla.</li> </ol> <p>\u00a1Hemos dominado el barrido de entradas! Esta base es fundamental para el proyecto final.</p> <p>No dejes de documentar el c\u00f3digo con Doxygen. Guarda una copia de tu proyecto como <code>simone_v2</code>.</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_2_old.html","title":"Versi\u00f3n 2: transceptor de ultrasonidos","text":"<p>Ya tenemos una librer\u00eda que nos permite crear botones que funcionan aut\u00f3nomamente mediante FSM. En este cap\u00edtulo vamos a crear una librer\u00eda que nos permita realizar la comunicaci\u00f3n con el transceptor de ultrasonidos HC-SR04. Lo denominamos transceptor porque es un dispositivo que emite y recibe ultrasonidos. El transceptor de ultrasonidos es un dispositivo que nos permite medir distancias. En este caso, el transceptor HC-SR04 emite un pulso de ultrasonidos y mide el tiempo que tarda en recibir el eco. Conociendo la velocidad del sonido en el medio (el aire en nuestro caso), podemos calcular la distancia a la que se encuentra un objeto.</p> <p>Como ya hicimos con el bot\u00f3n, (i) vamos a implementar la parte portable <code>PORT</code> dependiente del HW para comunicarnos con el transceptor, y lo probaremos con un test unitario. (ii) Despu\u00e9s, vamos a crear la l\u00f3gica de la FSM de la comunicaci\u00f3n con el dispositivo en la parte com\u00fan (la parte <code>COMMON</code>), y lo probaremos con un test unitario. (iii) Por \u00faltimo, montaremos el HW y probaremos la comunicaci\u00f3n de transmisi\u00f3n y recepci\u00f3n de ultrasonidos con un programa de ejemplo.</p> <p>En esta versi\u00f3n se van a utilizar tres temporizadores. Para facilitar la implementaci\u00f3n, se va a dividir cada uno de los pasos de la parte <code>PORT</code> en subsecciones con sus test correspondientes.</p> Transceptor de ultrasonidos HC-SR04. <p>La tabla\u00a0[tbl:hc_sr04] muestra las caracter\u00edsticas y conexiones del transceptor de ultrasonidos HC-SR04.</p> <p>El transceptor estar\u00e1 conectado a 2 GPIOs del microcontrolador para activar la se\u00f1al de disparo (trigger) y recibir la se\u00f1al de eco (echo). La se\u00f1al de disparo se activar\u00e1 para que el transceptor emita un tren de pulsos de ultrasonidos. La se\u00f1al de eco del obst\u00e1culo encontrado se recibe y se activar\u00e1 la se\u00f1al Echo. La distancia se calcular\u00e1 midiendo el tiempo que transcurre entre la activaci\u00f3n de la se\u00f1al de eco y su fin.</p> <p>Como el temporizador est\u00e1 configurado para medir ticks de \\(1 \\mu\\)s, podemos decir que \\(58.3 \\mu s \\leadsto 1 percentage\\). O, de forma m\u00e1s general, la distancia en cent\u00edmetros se calcular\u00e1 como:</p> \\[\\text{distancia} = \\frac{\\text{Tiempo}_{\\text{eco}} (\\mu s) \\times \\text{Velocidad del sonido} \\left(\\frac{m}{s}\\right)}{2*10000} \\, \\text{percentage}\\] <p>donde la distancia se medir\u00e1 en cent\u00edmetros, el tiempo en microsegundos, y la velocidad del sonido en el aire es de 343 \\(\\frac{m}{s}\\). La distancia se dividir\u00e1 por 2 porque el tiempo que medimos es el que tarda en ir y volver el pulso de ultrasonidos. El factor de 10000 es para dejar las unidades en cent\u00edmetros.</p> <p>El tiempo lo calcularemos mediante captura de entrada, input capture (repasar los conceptos de SDG1). Contaremos ciclos de un temporizador configurado en modo input capture captura el valor del contador en el momento en el que se activa y desactiva la se\u00f1al de eco. Cada ciclo del temporizador estar\u00e1 configurado para representar \\(1 \\mu\\)s. La diferencia entre el valor del contador en el momento en el que cae la se\u00f1al de eco y el valor del contador en el momento en el que se activa la se\u00f1al de eco nos dar\u00e1 el tiempo que ha tardado en ir y volver el sonido. La distancia se calcular\u00e1 con la f\u00f3rmula anterior.</p> <p>Mira el diagrama de temporizaci\u00f3n de la . El fabricante recomienda que el tiempo de disparo sea de, al menos, 10 \\(\\mu\\)s, y que el tiempo entre medidas sea de, al menos, 60 ms. El tiempo de timeout entre medidas consecutivas lo estableceremos en 100 ms. La se\u00f1al de eco tendr\u00e1 una duraci\u00f3n proporcional a la distancia al objeto. Nosotros no tendremos oportunidad de ver el tren de pulsos de ultrasonidos a \\(40 kHz\\), pero s\u00ed podremos ver el Trigger y el Echo en el osciloscopio.</p> Diagrama de temporizaci\u00f3n del transceptor de ultrasonidos HC-SR04. <p>En nuestra implementaci\u00f3n tendremos 3 temporizadores: (i) uno para controlar la duraci\u00f3n de la se\u00f1al de disparo, (ii) otro para medir el tiempo de eco, y (iii) otro para medir el timeout del tiempo entre medidas consecutivas que queramos realizar. La muestra el diagrama de temporizaci\u00f3n de las medidas.</p> <p>Para generar la se\u00f1al de disparo (Trigger) activaremos (1 l\u00f3gico) el pin de disparo durante, al menos, 10 \\(\\mu\\)s. Para controlar la duraci\u00f3n de esta se\u00f1al, configuraremos el temporizador <code>TIM3</code> como se muestra en la tabla\u00a0[tbl:hc_sr04_timer_trigger].</p> <p>Para medir el tiempo de eco, configuraremos el temporizador <code>TIM2</code> en modo input capture que capturar\u00e1 el valor del contador en el momento en el que se activa y desactiva la se\u00f1al de eco. La diferencia entre ambos valores nos dar\u00e1 el tiempo que ha tardado en ir y volver el sonido. La distancia se calcular\u00e1 con la f\u00f3rmula anterior. La tabla\u00a0[tbl:hc_sr04_timer_echo] muestra las caracter\u00edsticas del temporizador para medir el tiempo de eco del transceptor de ultrasonidos HC-SR04.</p> <p>El sistema ya funcionar\u00eda con estas configuraciones, pero vamos a a\u00f1adir un temporizador m\u00e1s para controlar el timeout entre medidas consecutivas. Lo que querremos con ello es permitir a la FSM de Simone que pueda hacer varias medidas de distancias seguidas para calcular un valor medio o mediano de la distancia y evitar medidas err\u00f3neas. La tabla\u00a0[tbl:hc_sr04_timer_timeout] muestra las caracter\u00edsticas del temporizador <code>TIM5</code> para controlar el timeout entre medidas.</p> <p>En primer lugar, debes familiarizarte con el protocolo de temporizaci\u00f3n de la y manejar los conceptos de temporizaci\u00f3n de los temporizadores del \\**STM32F446RE**\\. Lea con detenimiento el cap\u00edtulo \u201cTemporizadores (timers)\u201d del libro\u00a0<sup>1</sup>. L\u00e9elo porque la parte portable ser\u00e1n adaptaciones de lo que ah\u00ed se presenta. Se recomienda prestar especial atenci\u00f3n a los ejemplos de interrupciones peri\u00f3dicas y de input capture.</p>"},{"location":"notebook/version_2_old.html#_1","title":"Versi\u00f3n 2: transceptor de ultrasonidos","text":"<p>En el mercado existen numerosos transceptores de ultrasonidos. En este proyecto utilizaremos el popular HC-SR04 ensamblado por multitud de fabricantes. Se puede encontrar en muchos de proyectos DIY. Para adquirir uno ve al\u00a0.</p> <p>Igual que con el bot\u00f3n, estamos desarrollando una librer\u00eda. As\u00ed, cada vez que se quiera a\u00f1adir un transceptor de ultrasonidos le asociar\u00e9 una FSM. Las particularidades de d\u00f3nde est\u00e1 conectado cada nuevo transceptor, sus caracter\u00edsticas f\u00edsicas, , son cosas espec\u00edficas del HW, por lo que estar\u00e1n en <code>PORT</code>.</p> <p>La muestra las estructuras que vamos a necesitar para el transceptor de ultrasonidos. La estructura del HW del ultrasonidos (en <code>PORT</code>) se muestra en la . La estructura de la FSM (en <code>COMMON</code>) se muestra en la .</p>"},{"location":"notebook/version_2_old.html#section-1","title":"{ #section-1 }","text":"<p>Preparemos el proyecto para poder a\u00f1adir el transceptor de ultrasonidos:</p> <ol> <li> <p>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT de la librer\u00eda del ultrasound correspondientes a la versi\u00f3n <code>V2</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v2. Solo descarga por ahora: <code>port_ultrasound.h</code>, <code>stm32f4_ultrasound.h</code>, y <code>stm32f4_ultrasound.c</code> y col\u00f3calos en las carpetas correspondientes. No a\u00f1adas los ficheros de la parte COMMON.</p> </li> <li> <p>Coloca cada uno donde corresponde: <code>PORT</code> o <code>COMMON</code>, en <code>include</code>, o <code>src</code>, como se explic\u00f3 en el .</p> </li> <li> <p>Ver\u00e1s que no compila, y es que solo se proporciona un esqueleto del c\u00f3digo.</p> </li> </ol>"},{"location":"notebook/version_2_old.html#sec:headers_ultrasound_trigger","title":"<code>PORT</code>: cabeceras de la librer\u00eda del transceptor de ultrasonidos. Se\u00f1al de trigger.","text":"<p>Vamos a implementar el contrato con el usuario de la parte dependiente del HW de librer\u00eda del transceptor de ultrasonidos. Esta es la interfaz que vamos a proporcionar al usuario para que pueda usar la librer\u00eda y a\u00f1adir tantos transceptores como necesite. Vamos a portar las funciones necesarias para usar la librer\u00eda del transceptor de ultrasonidos. Lo haremos, c\u00f3mo no, para la placa \\**Nucleo-STM32F446RE**\\.</p> <p>El montaje de nuestro m\u00f3dulo HC-SR04 tendr\u00e1 un aspecto como el mostrado en . M\u00e1s adelante lo implementaremos.</p> Montaje del transceptor de ultrasonidos HC-SR04 con la &lt;span style=\"color: RoyalBlue\"&gt;**Nucleo-STM32F446RE**&lt;/span&gt;. <p>Comenzaremos de nuevo por la cabecera y luego los c\u00f3digos fuente. Primeramente implementaremos las funciones necesarias para controlar la se\u00f1al de disparo (Trigger) del transceptor de ultrasonidos.</p>"},{"location":"notebook/version_2_old.html#cabecera-port_ultrasoundh","title":"Cabecera port_ultrasound.h","text":"<p>Esta cabecera depende del HW pero no de las particularidades del microcontrolador \\**STM32F446RE**\\. Vamos a seguir los siguientes pasos:</p> <ul> <li> <p>Incluye todas las cabeceras necesarias seg\u00fan indica la API.</p> </li> <li> <p>Incluye los (<code>#define</code>) que se indican en la API para transceptor de ultrasonidos <code>PORT_SENSOR</code> que asume que se encuentra en la parte trasera del coche.</p> <ul> <li> <p><code>PORT_SENSOR_ID</code>: valor num\u00e9rico natural que ser\u00e1 el identificador del transceptor trasero. Si es el \u00fanico transceptor del sistema, le asignaremos el 0.</p> </li> <li> <p><code>PORT_PARKING_SENSOR_TRIGGER_UP_US</code>: hace referencia al tiempo que estar\u00e1 activa la se\u00f1al de disparo (Trigger) del transceptor en microsegundos. Usa el valor m\u00ednimo requerido por el fabricante (ver ).</p> </li> <li> <p><code>PORT_PARKING_SENSOR_TIMEOUT_MS</code>: hace referencia al tiempo de timeout entre medidas consecutivas en milisegundos. Usaremos 100 ms.</p> </li> <li> <p><code>SPEED_OF_SOUND_MS</code>: velocidad del sonido en el aire en metros por segundo. Usaremos 343 m/s.</p> </li> </ul> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_ultrasound.h</code>; implementaremos primeramente las que hacen referencia a la se\u00f1al de disparo (Trigger) del transceptor de ultrasonidos. A saber (si echas en falta alguna, a\u00f1\u00e1dela): <code>port_ultrasound_init()</code>, <code>port_ultrasound_stop_trigger_timer()</code>, <code>port_ultrasound_get_trigger_ready()</code>, <code>port_ultrasound_set_trigger_ready()</code>, <code>port_ultrasound_get_trigger_end()</code>, y <code>port_ultrasound_set_trigger_end()</code>.</p> <p>F\u00edjate que hay numerosas funciones que son getters y setters de campos de la estructura del transceptor de ultrasonidos. Estas funciones son necesarias para que la parte <code>COMMON</code> pueda acceder a los campos de la estructura sin tener que conocer su implementaci\u00f3n. M\u00e1s adelante, describiremos dichos campos.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen.</p> </li> </ul> <p>Ya hemos acabado con el encabezado que interact\u00faa con el HW de la se\u00f1al de disparo del ultrasonidos \u2014y que no depende del microcontrolador\u2014. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a programar la cabecera que s\u00ed depende del microcontrolador <code>stm32f4_ultrasound.h</code>.</p>"},{"location":"notebook/version_2_old.html#cabecera-stm32f4_ultrasoundh","title":"Cabecera stm32f4_ultrasound.h","text":"<p>Esta cabecera solo define los pines a los que est\u00e1 conectado el transceptor de ultrasonidos trasero del coche en la \\**Nucleo-STM32F446RE**\\:</p> <ul> <li> <p>Incluye todas las cabeceras necesarias seg\u00fan indica la API.</p> </li> <li> <p>Define (<code>#define</code>) los valores de la GPIO del pin de disparo (Trigger) con el nombre que indica la API y los valores que indica el .</p> </li> <li> <p>Haz lo mismo para el pin de la se\u00f1al de eco (Echo), aunque no lo vayamos a usar en esta parte; nos ayudar\u00e1 en la creaci\u00f3n del array de estructuras de ultrasonidos.</p> </li> <li> <p>Documenta los <code>#define</code> con Doxygen.</p> </li> </ul> <p>Ya hemos acabado con el encabezado (header) que interact\u00faa con el HW de la se\u00f1al de disparo del ultrasonidos conectado al microcontrolador \\**Nucleo-STM32F446RE**\\. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a implementar todas las funciones prototipadas en <code>port_ultrasound.h</code> que maneja dicha se\u00f1al.</p>"},{"location":"notebook/version_2_old.html#sec:port_ultrasound_trigger","title":"<code>PORT</code>: fuente de la librer\u00eda del ultrasonidos. Se\u00f1al de trigger.","text":"<p>Vamos a portar las funciones necesarias para usar la librer\u00eda del ultrasonidos y comprobar que la parte HW est\u00e1 bien programada. Vamos a programar los ficheros fuente de la parte <code>PORT</code>, que todos estar\u00e1n en el fichero <code>stm32f4_ultrasound.c</code>. Deber\u00e1s implementar o completar todas las funciones p\u00fablicas de las que se hayan declarado el prototipo en el encabezado y varias funciones privadas. Posteriormente completar\u00e1s la ISR asociada a los pines del transceptor en el fichero <code>interr.c</code>.</p>"},{"location":"notebook/version_2_old.html#fuentes-stm32f4_ultrasoundc","title":"Fuentes stm32f4_ultrasound.c","text":"<p>Este fichero es un poco extenso, por eso se ha decidido hacerlo por partes. Las funciones de getter y setter aunque son muchas, son muy sencillas. La mayor complejidad est\u00e1 en la configuraci\u00f3n de los temporizadores y en la ISR asociadas, por lo que es importante que manejes bien los conceptos del cap\u00edtulo de temporizadores del libro\u00a0<sup>1</sup>. Empezaremos por ahora con el temporizador que controla la duraci\u00f3n y activaci\u00f3n de la se\u00f1al de disparo (Trigger).</p> <ol> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Hay que definir la estructura <code>stm32f4_ultrasound_hw_t</code> de la misma forma que est\u00e1 para el bot\u00f3n <code>stm32f4_button_hw_t</code> (ver ). En la estructura se definen los campos que se muestran en la figura y en la API. Implementa todos los campos, aunque no sean necesarios para la parte de la se\u00f1al de disparo (Trigger).</p> <p>Esta estructura es gen\u00e9rica para cualquier ultrasonidos que vayamos a usar, no solo el trasero del coche, sino cualquier otro que queramos a\u00f1adir.</p> <p>Los campos booleanos <code>trigger_ready</code>, <code>trigger_end</code>, y <code>echo_received</code> son necesarios para indicar el estado de la se\u00f1al de disparo, la se\u00f1al de eco, y la recepci\u00f3n de la se\u00f1al de eco, respectivamente. Todos ellos ser\u00e1n <code>false</code> al inicio y controlados por los setters llamados desde las ISR de los temporizadores en <code>interr.c</code>.</p> <p>Los campos <code>echo_init_tick</code>, <code>echo_end_tick</code>, y <code>echo_overflows</code> son necesarios para almacenar los tiempos de inicio y fin de la se\u00f1al de eco, y el n\u00famero de desbordamientos del temporizador durante la se\u00f1al de eco. Todos ellos ser\u00e1n inicializados a 0 y controlados tambi\u00e9n por los setters y getters llamados desde las ISR de los temporizadores.</p> </li> <li> <p>Igual que hicimos con el bot\u00f3n, ahora vamos a definir una variable global privada <code>static stm32f4_ultrasound_hw_t ultrasounds_arr[]</code>. Se trata del array de estructuras de tipo <code>stm32f4_ultrasound_hw_t</code>, que representa al HW de cada transceptor de ultrasonidos que tengamos en nuestro coche.</p> <p>Como hicimos con el bot\u00f3n, la declaraci\u00f3n e inicializaci\u00f3n de este array podemos hacerla a la vez (recuerda las secciones correspondientes de los v\u00eddeos de SDG1: inicializaci\u00f3n de arrays y arrays de estructuras).</p> <p>Asigna los valores HW del ultrasonidos de aparcamiento trasero <code>PORT_SENSOR_ID</code> utilizando los <code>#define</code> de <code>stm32f4_ultrasound.h</code>. Los flag y los tiempos de eco y desbordamientos se inicializar\u00e1n en la funci\u00f3n <code>port_ultrasound_init()</code>.</p> </li> <li> <p>Codifica la funci\u00f3n <code>_stm32f4_ultrasound_get()</code> de manera an\u00e1loga a la proporcionada para el bot\u00f3n <code>_stm32f4_button_get()</code>. Se trata de una funci\u00f3n privada que devuelve un puntero a la estructura del transceptor que se le pasa como argumento. Si el transceptor no existe, la funci\u00f3n devuelve <code>NULL</code>.</p> </li> </ol>"},{"location":"notebook/version_2_old.html#_2","title":"Versi\u00f3n 2: transceptor de ultrasonidos","text":"<p>Ahora vamos a codificar las funciones m\u00e1s importantes de la parte <code>PORT</code> del ultrasonidos, y son las que configuran el temporizador de disparo asociado al transceptor de ultrasonidos. Vamos a empezar por la funci\u00f3n que configura el temporizador para medir el tiempo de disparo.</p> <ol> <li> <p>Codifica la funci\u00f3n <code>_timer_trigger_setup()</code> como indica la API. Esta funci\u00f3n configura el temporizador que controla los tiempos de la se\u00f1al de disparo (Trigger) de cualquier transceptor de ultrasonidos que se monte en el coche; si hubiese m\u00e1s de uno, todos se lanzar\u00edan a la vez. Para ello, ap\u00f3yate en el ejemplo \u201ctimer para interrupci\u00f3n peri\u00f3dica\u201d del libro de Fundamentos\u00a0<sup>1</sup>.</p> <p>Esta funci\u00f3n configura un temporizador para que genere una interrupci\u00f3n de <code>PORT_PARKING_SENSOR_TRIGGER_UP_US</code> microsegundos desde que se habilita el mismo. El temporizador elegido se muestra en la tabla\u00a0[tbl:hc_sr04_timer_trigger].</p> <p>No lo vamos a usar para que genere interrupciones peri\u00f3dicas, sino que lo deshabilitaremos una vez que haya transcurrido el tiempo de disparo, y lo volveremos a habilitar cuando haya pasado el tiempo de timeout entre medidas consecutivas. Podemos verlo como un temporizador peri\u00f3dico que solo va a saltar 1 vez cada vez.</p> <p>Para saber qu\u00e9 fuente de reloj habilitar para el temporizador, consulta la tabla \u201cFigure 3. STM32F446xC/E block diagram\u201d del datasheet <sup>2</sup>. All\u00ed podr\u00e1s ver si nuestro temporizador est\u00e1 conectado al APB1 o al APB2, y tenemos que habilitar el reloj en el registro <code>RCC-&gt;APB1ENR</code> o <code>RCC-&gt;APB2ENR</code> respectivamente.</p> <p>Es importante que no pongas los valores de los registros de configuraci\u00f3n del temporizador a mano, sino que uses las ecuaciones que se proporcionan en el libro\u00a0<sup>1</sup> para calcular los valores de los registros <code>TIMx-&gt;PSC</code> y <code>TIMx-&gt;ARR</code>. En cualquier momento podr\u00edamos querer cambiar el ancho de pulso de la se\u00f1al de disparo, y si lo hacemos a mano, podr\u00edamos cometer errores, adem\u00e1s de que es menos legible.</p> <p>Es muy importante que la funci\u00f3n <code>_timer_trigger_setup()</code> se llame desde la funci\u00f3n <code>port_ultrasound_init()</code>. Si no, no se podr\u00e1n generar interrupciones para el fin del tiempo de disparo de los ultrasonidos.</p> </li> </ol> <p>Vamos a continuar con el resto de funciones p\u00fablicas de la parte <code>PORT</code> del ultrasonidos que manejan la se\u00f1al de disparo (Trigger).</p> <ol> <li> <p>Completa la funci\u00f3n <code>port_ultrasound_init()</code> como se indica en la API.</p> <p>Inicializa los tiempos de eco y desbordamientos a 0, y los flags a <code>false</code>, excepto el que indica que el trigger est\u00e1 listo, que se pone a <code>true</code>.</p> <p>Por el momento, solo llama a la funci\u00f3n de configuraci\u00f3n <code>stm32f4_system_gpio_config()</code> para el pin de disparo.</p> <p>Llama por ahora solo a las funci\u00f3n de configuraci\u00f3n del temporizador de disparo <code>_timer_trigger_setup()</code>.</p> </li> <li> <p>Codifica la funci\u00f3n p\u00fablica declarada en el fichero <code>port_ultrasound.h</code> relativa al control del estado del temporizador de disparo siguiendo la API: <code>port_ultrasound_stop_trigger_timer()</code>.</p> </li> <li> <p>Codifica las funciones p\u00fablicas declaradas en el fichero <code>port_ultrasound.h</code> relativas a los getters y setters para la obtenci\u00f3n y manejo de informaci\u00f3n de los transceptores de ultrasonidos siguiendo la API: <code>port_ultrasound_get_trigger_ready()</code>, <code>port_ultrasound_set_trigger_ready()</code>, <code>port_ultrasound_get_trigger_end()</code>, <code>port_ultrasound_set_trigger_end()</code>.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>\u00a1Ya hemos acabado con la implementaci\u00f3n de la parte HW <code>stm32f_ultrasound.c</code> relativa al temporizador de disparo! Ahora solo queda la ISR asociada a dicho temporizador en el fichero <code>interr.c</code>. Vamos a ello.</p>"},{"location":"notebook/version_2_old.html#interrc","title":"interr.c","text":"<p>Abre el fichero <code>interr.c</code> y:</p> <ol> <li> <p>Codifica la ISR <code>TIM3_IRQHandler</code> como se indica en la API. Recuerda que las ISR no reciben ni devuelven nada.</p> <p>Esta ISR, cuando salta, se encarga de llamar a la funci\u00f3n correspondiente para inhabilitar el temporizador de disparo.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>Si ahora compilas, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado de la se\u00f1al de disparo de un transceptor de ultrasonidos!. Vamos a probarlo con el test unitario de la parte <code>PORT</code> para esta parte.</p>"},{"location":"notebook/version_2_old.html#sec:test_port_v2_trigger","title":"<code>PORT</code>: Test unitario del ultrasonidos. Se\u00f1al de trigger.","text":"<p>Vamos a comprobar que la parte <code>PORT</code> funciona correctamente pasando los test HW del c\u00f3digo que hemos desarrollado antes de continuar.</p> <p>\u00a1Importante! Los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente. \u00a0Ten a mano y revisa el cap\u00edtulo }{ .inline-img \u201cTest unitarios y ejemplos de integraci\u00f3n\u201d del libro de fundamentos te\u00f3ricos\u00a0<sup>1</sup>.</p> <p>Descarga el fichero de test HW de la se\u00f1al de disparo del ultrasonidos <code>test_port_ultrasound_timer_trigger.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto. Ver\u00e1s que tambi\u00e9n hay otros ficheros llamados <code>test_port_ultrasound_timer_echo.c</code>, y <code>test_port_ultrasound_timer_measurements.c</code>. Estos ficheros son para probar las implementaciones de las los temporizadores de la se\u00f1al de eco y medida entre disparos; los usaremos m\u00e1s adelante.</p> <ol> <li> <p>Conecta la placa \u00a0al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona }{ .inline-img  Clean and Debug}{ .inline-img  sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_port_ultrasound_timer_trigger</code> y pulsa OK. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Comprueba que todos los test pasan correctamente en el texto mostrado en la terminal de depuraci\u00f3n. Si no es as\u00ed, lee los mensajes de error y corrige tu c\u00f3digo hasta que pase todas las pruebas. Si no pasa las pruebas, no contin\u00faes programando.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pase todos los test.}{ .inline-img </p> </li> </ol> <p>\u00a1Ya hemos acabado con la parte <code>PORT</code> del transceptor de ultrasonidos para la se\u00f1al de disparo! Vamos ahora a implementar la parte <code>PORT</code> para la se\u00f1al de eco.</p>"},{"location":"notebook/version_2_old.html#sec:headers_ultrasound_echo","title":"<code>PORT</code>: cabeceras de la librer\u00eda del transceptor de ultrasonidos. Se\u00f1al de echo.","text":"<p>Vamos a continuar con la cabecera y luego los c\u00f3digos fuente para controlar la se\u00f1al de eco (Echo) del transceptor de ultrasonidos.</p>"},{"location":"notebook/version_2_old.html#cabecera-port_ultrasoundh_1","title":"Cabecera port_ultrasound.h","text":"<p>Vamos a seguir los siguientes pasos:</p> <ul> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_ultrasound.h</code> que hacen referencia a la se\u00f1al de eco (Echo) del transceptor de ultrasonidos. A saber (si echas en falta alguna, a\u00f1\u00e1dela): <code>port_ultrasound_reset_echo_ticks()</code>, <code>port_ultrasound_get_echo_init_tick()</code>, <code>port_ultrasound_set_echo_init_tick()</code>, <code>port_ultrasound_get_echo_end_tick()</code>, <code>port_ultrasound_set_echo_end_tick()</code>, <code>port_ultrasound_get_echo_received()</code>, <code>port_ultrasound_set_echo_received()</code>, <code>port_ultrasound_get_echo_overflows()</code>, y <code>port_ultrasound_set_echo_overflows()</code>.</p> <p>Recuerda que las funciones que son getters y setters de campos de la estructura del transceptor de ultrasonidos son necesarias para que la parte <code>COMMON</code> pueda acceder a los campos de la estructura sin tener que conocer su implementaci\u00f3n.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen.</p> </li> </ul> <p>Ya hemos acabado con el encabezado que interact\u00faa con el HW de la se\u00f1al de eco del ultrasonidos \u2014y que no depende del microcontrolador\u2014. En la la cabecera que s\u00ed depende del microcontrolador <code>stm32f4_ultrasound.h</code> ya no tenemos que hacer nada m\u00e1s. Vamos ahora a implementar todas las funciones prototipadas en <code>port_ultrasound.h</code> que maneja la se\u00f1al de eco.</p>"},{"location":"notebook/version_2_old.html#sec:port_ultrasound_echo","title":"<code>PORT</code>: fuente de la librer\u00eda del ultrasonidos. Se\u00f1al de echo.","text":""},{"location":"notebook/version_2_old.html#fuentes-stm32f4_ultrasoundc_1","title":"Fuentes stm32f4_ultrasound.c","text":"<p>Vamos a continuar con el temporizador que mide la duraci\u00f3n de la se\u00f1al de eco (Echo). Vamos a empezar por la funci\u00f3n que configura el temporizador para medir la duraci\u00f3n del eco recibido.</p> <ol> <li> <p>Codifica la funci\u00f3n <code>_timer_echo_setup()</code> como indica la API. Esta funci\u00f3n configura un temporizador para que mida el tiempo de eco del transceptor de ultrasonidos. El temporizador elegido se muestra en la tabla\u00a0[tbl:hc_sr04_timer_echo].</p> <p>El c\u00f3digo configura el canal del temporizador para capturar eventos de entrada. Repasa el ejemplo \u201ccaptura de entrada (input capture)\u201d del libro de Fundamentos\u00a0<sup>1</sup> para entender c\u00f3mo se configura un temporizador en modo input capture.</p> <p>F\u00edjate que esta funci\u00f3n s\u00ed recibe como argumento el identificador del transceptor de ultrasonidos. Esto es porque cada transceptor de ultrasonidos que montemos en el coche tendr\u00e1 su propio temporizador para medir el tiempo de eco. Recuerda que el temporizador que mide el tiempo de eco se configura en modo input capture, y est\u00e1 asociado a un pin GPIO del microcontrolador. Es por ello que todo el c\u00f3digo de configuraci\u00f3n del temporizador ha de ir en un bloque <code>if</code> que compruebe el identificador del transceptor. Si en un futuro a\u00f1adimos m\u00e1s transceptores de ultrasonidos, cada uno tendr\u00e1 su propio temporizador y su propio pin GPIO asociado, pero la funci\u00f3n <code>_timer_echo_setup()</code> ser\u00e1 la misma para todos.</p> <p>Para saber qu\u00e9 canal del temporizador configurar, consulta la tabla de Funci\u00f3n Alternativa en el datasheet <sup>2</sup> para el pin de eco del transceptor de ultrasonidos.</p> <p>En esta ocasi\u00f3n puedes poner los valores de los registros <code>TIMx-&gt;PSC</code> y <code>TIMx-&gt;ARR</code> a mano, o usando las ecuaciones. El tiempo de cada tick del temporizador ser\u00e1 de \\(1 \\mu\\)s. Puedes crear un <code>#define</code> para ello si lo consideras oportuno.</p> <p>\u00bfPor qu\u00e9 nos interesa que el tiempo de cada tick sea de \\(1 \\mu\\)s? Porque as\u00ed podemos aplicar f\u00e1cilmente la f\u00f3rmula de la distancia en cent\u00edmetros que hemos visto al principio de este cap\u00edtulo. En realidad se puede usar cualquier tiempo de tick que quieras, pero tendr\u00e1s que modificar la f\u00f3rmula de la distancia en consecuencia.</p> <p>No obstante, se recomienda trabajar con precisi\u00f3n de \\(1 \\mu\\)s. Recuerda que nuestro reloj de sistema es de \\(16 MHz\\), y que para que cada ciclo del temporizador sea de \\(1 \\mu\\)s (frecuencia de \\(1 MHz\\)), tenemos que preescalarlo con el valor adecuado, dando lugar a que <code>PSC=prescaler-1</code>. Como vemos, el valor de prescaler nos fija la resoluci\u00f3n del temporizador, pero con el valor de <code>ARR</code> tenemos m\u00e1s libertad. No obstante, se recomienda que el valor de <code>ARR</code> sea lo m\u00e1s grande posible para que el temporizador no desborde en la medida de la distancia m\u00e1xima que queremos medir, por ejemplo, su valor m\u00e1ximo.</p> <p>Las caracter\u00edsticas m\u00e1s importantes de la configuraci\u00f3n del canal son que:</p> <ul> <li> <p>Configura com entrada el canal que le corresponda de forma natural (\u00a0si es canal 1, <code>TI1</code>, si es canal 2, <code>TI2</code>, ). Comprueba los bits Capture/ Compare X Selection (<code>CCxS</code>) de los registros <code>CCMRx</code> para saber qu\u00e9 canal configurar. Ver el punto TIMx capture/compare mode register 1 y TIMx capture/compare mode register 2 del datasheet <sup>2</sup>.</p> </li> <li> <p>Deshabilita el filtrado digital para capturar cada evento.</p> </li> <li> <p>Selecciona que los flancos de subida y bajada sean los que activen la captura.</p> </li> <li> <p>Configura el prescaler de entrada para capturar cada transici\u00f3n v\u00e1lida.</p> </li> <li> <p>Habilita las interrupciones de captura para el canal correspondiente y las interrupciones de actualizaci\u00f3n.</p> </li> </ul> </li> </ol> <p>Vamos a continuar con el resto de funciones p\u00fablicas de la parte <code>PORT</code> del ultrasonidos que manejan la se\u00f1al de eco (Echo).</p> <ol> <li> <p>Contin\u00faa completando la funci\u00f3n <code>port_ultrasound_init()</code> como se indica en la API.</p> <p>A\u00f1ade llama a la funci\u00f3n de configuraci\u00f3n <code>stm32f4_system_gpio_config()</code> para el pin de eco.</p> <p>Recuerda que es muy importante indicar en el modo el pin de eco, no es de entrada ni salida, sino alternativo, trabajar\u00e1 como entrada en modo input capture. No olvides llamar a <code>stm32f4_system_gpio_config_alternate()</code>.</p> <p>Es muy importante que a\u00f1adas la llamada a <code>_timer_echo_setup()</code> en la funci\u00f3n <code>port_ultrasound_init()</code>. Si no, no se podr\u00e1n generar de la captura de entrada.</p> </li> <li> <p>Codifica las funciones p\u00fablicas declaradas en el fichero <code>port_ultrasound.h</code> relativa al control del temporizador de eco siguiendo la API: <code>port_ultrasound_stop_echo_timer()</code> y <code>port_ultrasound_reset_echo_ticks()</code>.</p> </li> <li> <p>Codifica las funciones p\u00fablicas declaradas en el fichero <code>port_ultrasound.h</code> relativas a los getters y setters para la obtenci\u00f3n y manejo de informaci\u00f3n de los transceptores de ultrasonidos siguiendo la API:<code>port_ultrasound_get_echo_init_tick()</code>, <code>port_ultrasound_set_echo_init_tick()</code>, <code>port_ultrasound_get_echo_end_tick()</code>, <code>port_ultrasound_set_echo_end_tick()</code>, <code>port_ultrasound_get_echo_received()</code>, <code>port_ultrasound_set_echo_received()</code>, <code>port_ultrasound_get_echo_overflows()</code>, y <code>port_ultrasound_set_echo_overflows()</code>.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>\u00a1Ya hemos acabado con la implementaci\u00f3n de la parte HW <code>stm32f_ultrasound.c</code> relativa al temporizador de eco! Ahora solo queda la ISR asociada a dicho temporizador en el fichero <code>interr.c</code>. Vamos a ello.</p>"},{"location":"notebook/version_2_old.html#interrc_1","title":"interr.c","text":"<p>Abre el fichero <code>interr.c</code> y:</p> <ol> <li> <p>Codifica la ISR <code>TIM2_IRQHandler</code>. Esta ISR se encarga de gestionar la se\u00f1al de eco del transceptor de ultrasonidos.</p> <p>Esta ISR puede saltar por 3 motivos: (i) por un desbordamiento (overflow) del temporizador, (ii) por un flanco de subida, o (iii) por un flanco de bajada.</p> <p>Lo primero que hace es comprobar si la interrupci\u00f3n es por un desbordamiento del temporizador. Si es as\u00ed, incrementa el n\u00famero de desbordamientos del temporizador en la estructura del ultrasonidos correspondiente llamando a la funci\u00f3n <code>port_ultrasound_set_echo_overflows()</code>.</p> <p>Posteriormente comprueba si la interrupci\u00f3n es por un flanco de subida o de bajada. En caso de ser un flanco de subida, guarda el tiempo de inicio de la se\u00f1al de eco. En caso de ser un flanco de bajada, guarda el tiempo de fin de la se\u00f1al de eco y llama a la funci\u00f3n que indica que <code>echo_received</code> es <code>true</code>.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>Si ahora compilas, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado de la se\u00f1al de eco de un transceptor de ultrasonidos!. Vamos a probarlo con el test unitario de la parte <code>PORT</code> para esta parte.</p>"},{"location":"notebook/version_2_old.html#sec:test_port_v2_echo","title":"<code>PORT</code>: Test unitario del ultrasonidos. Se\u00f1al de echo.","text":"<p>Vamos a comprobar que la parte <code>PORT</code> funciona correctamente pasando los test HW del c\u00f3digo que hemos desarrollado antes de continuar.</p> <p>Descarga el fichero de test HW de la se\u00f1al de disparo del ultrasonidos <code>test_port_ultrasound_timer_echo.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto.</p> <ol> <li> <p>Conecta la placa \u00a0al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona }{ .inline-img  Clean and Debug}{ .inline-img  sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_port_ultrasound_timer_echo</code> y pulsa OK. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Comprueba que todos los test pasan correctamente en el texto mostrado en la terminal de depuraci\u00f3n. Si no es as\u00ed, lee los mensajes de error y corrige tu c\u00f3digo hasta que pase todas las pruebas. Si no pasa las pruebas, no contin\u00faes programando.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pase todos los test.}{ .inline-img </p> </li> </ol> <p>\u00a1Ya hemos acabado con la parte <code>PORT</code> del transceptor de ultrasonidos para la se\u00f1al de eco! Vamos ahora a implementar la parte <code>PORT</code> para el temporizador de timeout entre medidas consecutivas.</p>"},{"location":"notebook/version_2_old.html#sec:headers_ultrasound_timeout","title":"<code>PORT</code>: cabeceras de la librer\u00eda del transceptor de ultrasonidos. Timeout entre medidas.","text":"<p>Vamos a terminar con la cabecera y los c\u00f3digos fuente para controlar el temporizador que controla el tiempo entre medidas del transceptor de ultrasonidos.</p>"},{"location":"notebook/version_2_old.html#cabecera-port_ultrasoundh_2","title":"Cabecera port_ultrasound.h","text":"<p>Vamos a seguir los siguientes pasos:</p> <ul> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_ultrasound.h</code> que hacen referencia a la se\u00f1al de eco (Echo) del transceptor de ultrasonidos. A saber (si echas en falta alguna, a\u00f1\u00e1dela): <code>port_ultrasound_start_measurement()</code>, <code>port_ultrasound_start_new_measurement_timer()</code>, <code>port_ultrasound_stop_new_measurement_timer()</code>, y <code>port_ultrasound_stop_ultrasound()</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen.</p> </li> </ul> <p>Ya hemos acabado con el encabezado que interact\u00faa con el HW del temporizador que gestiona el tiempo entre medidas del ultrasonidos \u2014y que no depende del microcontrolador\u2014. En la la cabecera que s\u00ed depende del microcontrolador <code>stm32f4_ultrasound.h</code> ya no tenemos que hacer nada m\u00e1s. Vamos ahora a implementar todas las funciones prototipadas en <code>port_ultrasound.h</code> que maneja este temporizador.</p>"},{"location":"notebook/version_2_old.html#sec:port_ultrasound_timeout","title":"<code>PORT</code>: fuente de la librer\u00eda del ultrasonidos. Timeout entre medidas.","text":""},{"location":"notebook/version_2_old.html#fuentes-stm32f4_ultrasoundc_2","title":"Fuentes stm32f4_ultrasound.c","text":"<p>Vamos a empezar por la funci\u00f3n que configura el temporizador de timeout entre medidas.</p> <ol> <li> <p>Codifica la funci\u00f3n <code>_timer_new_measurement_setup()</code> como indica la API. Esta funci\u00f3n configura un temporizador para que genere una interrupci\u00f3n de <code>PORT_PARKING_SENSOR_TIMEOUT_MS</code> milisegundos desde que se habilita el mismo. El temporizador elegido se muestra en la tabla\u00a0[tbl:hc_sr04_timer_timeout].</p> <p>Esta funci\u00f3n se llamar\u00e1 desde la funci\u00f3n <code>port_ultrasound_init()</code> para que se configure el temporizador que controla el timeout entre medidas consecutivas. Este timer S\u00cd lo vamos a usar para que genere interrupciones peri\u00f3dicas durante todo el tiempo que el coche est\u00e1 aparcando. Cada vez que se genere una interrupci\u00f3n, se tomar\u00e1 una nueva medida de distancia.</p> <p>Para saber qu\u00e9 fuente de reloj habilitar para el temporizador: APB1 o APB2, consulta la tabla \u201cFigure 3. STM32F446xC/E block diagram\u201d del datasheet <sup>2</sup>.</p> <p>De nuevo, es importante que no pongas los valores de los registros <code>TIMx-&gt;PSC</code> y <code>TIMx-&gt;ARR</code> a mano, sino que uses las ecuaciones.</p> </li> </ol> <p>Vamos a continuar con el resto de funciones p\u00fablicas de la parte <code>PORT</code> del ultrasonidos que manejan el temporizador de timeout entre medidas.</p> <ol> <li> <p>Vamos a finalizar la funci\u00f3n <code>port_ultrasound_init()</code> como se indica en la API. Solo a\u00f1ade la llamada a <code>_timer_new_measurement_setup()</code>. Si no, no se podr\u00e1n tomar m\u00faltiples medidas.</p> </li> <li> <p>Codifica las funciones p\u00fablicas declaradas en el fichero <code>port_ultrasound.h</code> relativa al control del temporizador entre medidas siguiendo la API: <code>port_ultrasound_start_measurement()</code>, <code>port_ultrasound_start_new_measurement_timer()</code>, <code>port_ultrasound_stop_new_measurement_timer()</code>, y <code>port_ultrasound_stop_ultrasound()</code>.</p> <p>F\u00edjate que algunas funciones acceden directamente a los temporizadores, y recuerda que el temporizador de eco depende del identificador del transceptor de ultrasonidos. Ten esto en cuenta para encapsular dicho acceso en un bloque condicional que compruebe el identificador del transceptor.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>\u00a1Ya hemos acabado con la implementaci\u00f3n de la parte HW <code>stm32f_ultrasound.c</code> por completo! Ahora solo queda la ISR asociada al temporizador peri\u00f3dico de timeouten el fichero <code>interr.c</code>. Vamos a ello.</p>"},{"location":"notebook/version_2_old.html#interrc_2","title":"interr.c","text":"<p>Abre el fichero <code>interr.c</code> y:</p> <ol> <li> <p>Codifica la ISR <code>TIM5_IRQHandler</code> de manera an\u00e1loga a la anterior.</p> <p>Esta ISR se encarga de llamar a la funci\u00f3n correspondiente que indica que se ha acabado el tiempo de timeout entre medidas consecutivas y el trigger est\u00e1 listo para una nueva medida.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>Si ahora compilas, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado de un transceptor de ultrasonidos!. Vamos a probarlo con el test unitario de la parte <code>PORT</code> para el temporizador de timeout entre medidas.</p>"},{"location":"notebook/version_2_old.html#sec:test_port_v2_timeout","title":"<code>PORT</code>: Test unitario del ultrasonidos. Se\u00f1al de timeout entre medidas.","text":"<p>Vamos a comprobar que la parte <code>PORT</code> funciona correctamente pasando los test HW del c\u00f3digo que hemos desarrollado antes de continuar con la parte <code>COMMON</code>.</p> <p>Descarga el fichero de test HW de la se\u00f1al de disparo del ultrasonidos <code>test_port_ultrasound_timer_measurements.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto.</p> <ol> <li> <p>Conecta la placa \u00a0al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona }{ .inline-img  Clean and Debug}{ .inline-img  sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_port_ultrasound_timer_measurements</code> y pulsa OK. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Comprueba que todos los test pasan correctamente en el texto mostrado en la terminal de depuraci\u00f3n. Si no es as\u00ed, lee los mensajes de error y corrige tu c\u00f3digo hasta que pase todas las pruebas. Si no pasa las pruebas, no contin\u00faes programando.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pase todos los test.}{ .inline-img </p> </li> </ol> <p>\u00a1Ya hemos acabado con la parte <code>PORT</code> del transceptor de ultrasonidos! Vamos ahora a implementar la parte <code>COMMON</code>.</p>"},{"location":"notebook/version_2_old.html#common-cabecera-de-la-fsm-del-ultrasonidos","title":"<code>COMMON</code>: cabecera de la FSM del ultrasonidos","text":""},{"location":"notebook/version_2_old.html#consideraciones-de-la-fsm-del-ultrasonidos","title":"Consideraciones de la FSM del ultrasonidos","text":""},{"location":"notebook/version_2_old.html#_3","title":"Versi\u00f3n 2: transceptor de ultrasonidos","text":"<p>Antes de empezar vamos a partir de una serie de consideraciones.</p> <ul> <li> <p>La FSM almacena varias distancias en un array y la distancia mediana de la \u00faltima serie de medidas.</p> </li> <li> <p>La FSM contiene un campo de estado (<code>status</code>) que indica si el sistema est\u00e1 aparcando (activo, <code>true</code>) o no (inactivo, <code>false</code>).</p> </li> <li> <p>El usuario debe solicitar/\u00a0comprobar la distancia mediante la funci\u00f3n <code>fsm_ultrasound_get_intensity()</code> para recuperar el campo de distancia <code>intensity_perc</code>.</p> </li> <li> <p>El valor de inicio de distancia al arrancar la FSM, y el de reinicio, debe ser \\(0 ms\\).</p> </li> <li> <p>La FSM contiene informaci\u00f3n del identificador (<code>ID</code>) del transceptor. Este <code>ID</code> es \u00fanico y gestionado por el usuario en el <code>PORT</code>. Ah\u00ed es donde el usuario proporciona identificadores e informaci\u00f3n HW (GPIO a la que est\u00e1 conectado, ) para todos los transceptores de ultrasonidos de su sistema.</p> </li> </ul> M\u00e1quina de estados del ultrasonidos. <p>Nuestra librer\u00eda implementa la l\u00f3gica de la FSM mostrada en la y que llamaremos <code>fsm_keyboard</code> (en los ficheros <code>.c</code> y <code>.h</code>). Tiene 5 estados en los que:</p> <ul> <li> <p><code>WAIT_START</code>: estado inicial en el que el transceptor est\u00e1 inactivo y preparado para activar el trigger. En tal caso, se lanza el inicio de una nueva serie de medidas.</p> </li> <li> <p><code>TRIGGER_START</code>: en este estado se est\u00e1 un tiempo muy breve, solo desde que se inicia la disparo del emisor de ultrasonido, hasta que salta la interrupci\u00f3n del temporizador de disparo, y se deshabilita dicho timer hasta la pr\u00f3xima medida.</p> </li> <li> <p><code>WAIT_ECHO_START</code>: inmediatamente el sistema queda esperando la recepci\u00f3n del inicio de la se\u00f1al de eco en el sensor de ultrasonidos. Cuando se detecta el inicio del eco, la FSM avanza al siguiente estado sin ejecutar ninguna acci\u00f3n adicional.</p> </li> <li> <p><code>WAIT_ECHO_END</code>: en este estado, el sensor est\u00e1 esperando hasta que finalice la se\u00f1al de eco en la captura de entrada. Una vez recibidos ambos flancos de la se\u00f1al, se calcula la distancia con <code>do_set_intensity</code> y se guarda. Si se han recibido <code>FSM_ULTRASOUND_NUM_MEASUREMENTS</code> medidas, se calcula la mediana de las distancias y se guarda en el campo <code>intensity_perc</code>. Si se detecta que el sistema se ha apagado, se detienen las mediciones y se vuelve al estado inicial.</p> </li> <li> <p><code>SET_DISTANCE</code>: en este estado ya se ha almacenado el valor de la distancia calculada y se queda a la espera de que el flag <code>trigger_ready</code> est\u00e9 a <code>true</code>. Si se detecta que el sistema se ha apagado, se detienen las mediciones y se vuelve al estado inicial.</p> </li> </ul> <p>La parte <code>COMMON</code> de nuestra librer\u00eda trabaja con la estructura (<code>struct</code>) p\u00fablica que se muestra en la . El tipo de esta estructura est\u00e1 declarada en el fichero <code>fsm_keyboard.h</code> (<code>typedef struct fsm_ultrasound_t fsm_ultrasound_t;</code>), pero la definici\u00f3n de la estructura est\u00e1 en el fichero <code>.c</code>.</p> <ol> <li>Lo primero, descarga del repositorio de la asignatura los ficheros correspondientes a la parte COMMON de la librer\u00eda del ultrasound correspondientes a la versi\u00f3n <code>V2</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v2. Solo descarga lo que faltaba por implementar, es decir, los ficheros <code>fsm_keyboard.h</code> y <code>fsm_keyboard.c</code>. Ponlos en las carpetas correspondientes de tu proyecto.</li> </ol> <p>Ahora, vamos a completar la cabecera de la FSM del transceptor de ultrasonidos, <code>fsm_keyboard.h</code>.</p> <ol> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Define el <code>#define</code> <code>FSM_ULTRASOUND_NUM_MEASUREMENTS</code> con el n\u00famero de medidas que se van a almacenar en el array de distancias para calcular la mediana. Usaremos 5 medidas.</p> </li> <li> <p>Ahora vamos a definir el enumerado con los nombres de los estados de la FSM. Escribe el <code>enum</code> <code>FSM_ULTRASOUND</code> con los nombres de los estados del diagrama de la .</p> </li> <li> <p>Es buena pr\u00e1ctica ir documentado el c\u00f3digo a la vez que se programa.</p> </li> <li> <p>Seguidamente declararemos la estructura <code>fsm_ultrasound_t</code> para hacerla p\u00fablica. No obstante, no vamos definir sus campos p\u00fablicamente, como se ha indicado anteriormente.</p> </li> </ol> <p>Continuamos con las declaraciones de funciones p\u00fablicas de la librer\u00eda. Procedamos:</p> <ol> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>fsm_keyboard.h</code>.</p> <p>Estas son las funciones que podr\u00e1n ser llamadas desde el exterior y, como en el caso del bot\u00f3n, el nombre de la funci\u00f3n debe empezar por <code>fsm_</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen.</p> </li> </ol> <p>Vamos ahora a programar el fichero fuente <code>fsm_keyboard.c</code>.</p>"},{"location":"notebook/version_2_old.html#common-fuente-de-la-fsm-del-ultrasonidos","title":"<code>COMMON</code>: fuente de la FSM del ultrasonidos","text":"<p>Vamos a proceder con la implementaci\u00f3n de las funciones del ultrasonidos. Deber\u00e1s implementar todas las funciones p\u00fablicas de las que ya has declarado el prototipo en el encabezado, y el resto de funciones privadas que aparecen en la API del fichero <code>fsm_keyboard.c</code>. Tambi\u00e9n definiremos las variables globales y estructuras que sean necesarias. \u00a1Recuerda que las funciones privadas no se declaran en el <code>.h</code>!</p> <ul> <li> <p>Lo primero que debe aparecer es la inclusi\u00f3n de cabeceras como indica la API.</p> </li> <li> <p>Vamos a declarar la estructura <code>fsm_ultrasound_t</code>. Definiremos la estructura con los campos que se muestran en la . Es muy importante que la m\u00e1quina de estados del ultrasonidos <code>fsm_t</code> sea el primer campo.</p> </li> <li> <p>De igual modo, es buen momento para aprovechar a documentar la estructura.</p> </li> </ul> <p>Ahora empezamos a codificar las funciones privadas de la FSM. Empezaremos con las funciones de entrada o comprobaci\u00f3n <code>check_</code> de la FSM bajo la l\u00ednea de <code>/* State machine input or transition functions */</code>.</p> <ol> <li> <p>Codifica las funciones <code>check_on()</code>, <code>check_trigger_end()</code>, <code>check_echo_init()</code>, <code>check_echo_received()</code>, y <code>check_new_measurement()</code> como se indica en la API.</p> </li> <li> <p>Documenta las funciones con Doxygen, encima del nombre de cada funci\u00f3n.</p> </li> </ol> <p>Seguiremos con las funciones de salida o actualizaci\u00f3n de la FSM <code>do_</code>.</p> <ol> <li> <p>Codifica las funciones <code>do_start_measurement()</code>, <code>do_stop_trigger()</code>, <code>do_set_intensity()</code>, <code>do_stop_measurement()</code>, y <code>do_start_new_measurement()</code> como se indica en la API.</p> </li> <li> <p>Documenta las funciones con Doxygen. En este caso, igual que antes, la documentaci\u00f3n ir\u00e1 en el <code>.c</code>, encima del nombre de cada funci\u00f3n.</p> </li> </ol>"},{"location":"notebook/version_2_old.html#_4","title":"Versi\u00f3n 2: transceptor de ultrasonidos","text":"<p>Todav\u00eda no hemos acabado con el desarrollo, pero puedes compilar para ir depurando errores.</p> <ol> <li> <p>Declara la tabla de transiciones de la FSM <code>fsm_trans_ultrasound</code>. Esto eliminar\u00e1 muchos errores de compilaci\u00f3n. \u00a1Importante! En la declaraci\u00f3n de esta tabla es importante el orden en el que se colocan las transiciones: en aseg\u00farate en <code>SET_DISTANCE</code> de comprobar antes que hay que hacer una nueva medida (<code>check_new_measurement()</code>), que de comprobar si hay que parar (<code>check_off()</code>); de otra manera puedes tener errores y acabar antes de tiempo.</p> </li> <li> <p>Completa la funci\u00f3n de inicializaci\u00f3n de la FSM <code>fsm_ultrasound_init()</code> como se indica en la API. En esta funci\u00f3n se inicializan los campos de la estructura de la FSM, y se llama a la funci\u00f3n <code>fsm_init()</code> para inicializar la m\u00e1quina de estados. Tambi\u00e9n se llama a la funci\u00f3n <code>port_ultrasound_init()</code> para inicializar el HW del transceptor de ultrasonidos.</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_ultrasound_fire()</code> igual que la funci\u00f3n <code>fsm_button_fire()</code> que se daba implementada en la parte del bot\u00f3n. Esta funci\u00f3n lanza la FSM. Haz lo propio con la funci\u00f3n <code>fsm_ultrasound_destroy()</code> igual que la funci\u00f3n <code>fsm_button_destroy()</code> que se daba implementada en la parte del bot\u00f3n. Esta funci\u00f3n destruye la FSM. La usaremos en la integraci\u00f3n final del sistema.</p> </li> <li> <p>Codifica las funciones <code>fsm_ultrasound_get_inner_fsm()</code> y <code>fsm_ultrasound_get_state()</code>. Se usar\u00e1n en el test de la FSM.</p> </li> <li> <p>Codifica las funciones <code>fsm_ultrasound_get_intensity()</code>, <code>fsm_ultrasound_stop()</code>, <code>fsm_ultrasound_start()</code>, <code>fsm_ultrasound_get_status()</code>, <code>fsm_ultrasound_set_status()</code>, <code>fsm_ultrasound_get_ready()</code>, y <code>fsm_ultrasound_get_new_measurement_ready()</code> como se indica en la API.</p> </li> </ol> <p>Ya hemos acabado con la programaci\u00f3n de la librer\u00eda del ultrasonidos. Toda esta l\u00f3gica <code>COMMON</code> puede ser usada en cualquier sistema, est\u00e9 basado en microcontrolador, o sea un PC. Ahora, si compilas, no deber\u00e1n aparecer errores.</p> <ol> <li>Documenta el c\u00f3digo que est\u00e9 sin comentar.</li> </ol>"},{"location":"notebook/version_2_old.html#sec:test_fsm_v2","title":"<code>COMMON</code> Test unitario de la FSM del ultrasonidos","text":"<p>Vamos a hacer el test del c\u00f3digo que hemos desarrollado de la librer\u00eda de la m\u00e1quina de estados del ultrasonidos y probar que funciona antes de continuar con la siguiente versi\u00f3n.</p> <p>\u00a1Importante! Recuerda que los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente.</p> <p>Descarga el fichero de test de la FSM del ultrasonidos <code>test_fsm_ultrasound.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>test/</code> de tu proyecto. \u00a1No lo metas en stm32f4/, pues no es un test espec\u00edfico del microcontrolador!</p> <ol> <li> <p>Con la placa \u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_fsm_ultrasound</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso.</p> </li> <li> <p>Se habr\u00e1 impreso por la terminal del <code>gdb-server</code> el resultado de las pruebas de los tests. Deber\u00eda haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu c\u00f3digo hasta que pasen todas las pruebas. Si no pasan las pruebas, no contin\u00faes.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pasen todos los test.}{ .inline-img </p> </li> </ol>"},{"location":"notebook/version_2_old.html#ejemplo-de-uso-de-la-version-2","title":"Ejemplo de uso de la Versi\u00f3n 2","text":"<p>En este test de integraci\u00f3n del transceptor de ultrasonidos es responsabilidad del alumno comprobar que la funcionalidad es la esperada. El ejemplo que se da no contempla todas las situaciones.</p> <p>Descarga el fichero de ejemplo <code>example2\u030c.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>example/</code> de tu proyecto.</p> <p>Procedamos:</p> <p>Para poder hacer el ejemplo del sistema de ultrasonidos, necesitamos montar el transceptor. En la se muestra un ejemplo de montaje.</p> <ol> <li> <p>Monte el HW como se muestra en la .</p> </li> <li> <p>Con la placa \u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona }{ .inline-img  Clean and Debug}{ .inline-img  sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>example_v2</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Se parar\u00e1 en la primera l\u00ednea del <code>main()</code>. Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso. Este c\u00f3digo no termina, pues es un bucle <code>while</code> infinito.</p> </li> <li> <p>Abre la terminal del <code>gdb-server</code> para ver los mensajes que se van imprimiendo.</p> </li> <li> <p>Ve acercando y alejando un objeto del transceptor de ultrasonidos para ver c\u00f3mo se actualiza la distancia en la terminal. Puedes servirte de una regla colocada en la mesa para comprobar que la distancia es la correcta.</p> </li> <li> <p>Haz distintas pruebas y aseg\u00farate de que el comportamiento es el adecuado.</p> </li> </ol> <p>\u00a1Hemos creado nuestra segunda librer\u00eda! F\u00edjate que es portable a cualquier plataforma solo con adaptar las funciones del <code>PORT</code>.</p> <p>No dejes de documentar el c\u00f3digo. Comprueba que la documentaci\u00f3n del c\u00f3digo se ha generado correctamente como se explica en la \u201cGu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C\u201d <sup>3</sup>., o en el v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d.</p> <p>Guarda una copia de su proyecto como <code>simone_v2</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla.</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Daniel Capell\u00e1n Mart\u00edn, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Amadeo de Gracia Herranz. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_3.html","title":"Versi\u00f3n 3: RGB light RGB","text":"<p>Ya tenemos una librer\u00eda que nos permite tener botones que funcionan aut\u00f3nomamente mediante FSM. De ella hemos creado un bot\u00f3n que representa la marcha atr\u00e1s del coche. Adem\u00e1s, hemos creado una librer\u00eda que nos permite crear transceptores de ultrasonido, tambi\u00e9n gestionados mediante FSM. De esta \u00faltima, hemos creado un transceptor que estar\u00eda colocado en la parte trasera del coche para detectar obst\u00e1culos mientras se aparca.</p> <p>Bibliograf\u00eda</p> <ol> <li> <p>\"Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>1</sup></p> </li> <li> <p>Datasheet \"STM32F446xC/E\u201d <sup>2</sup></p> </li> <li> <p>Reference manual \"RM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>3</sup></p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Demostraci\u00f3n Simone</p> </li> <li> <p>Conceptos b\u00e1sicos de C (canal SDG1)</p> </li> <li> <p>\"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d</p> </li> </ul> <p>En este cap\u00edtulo vamos a crear una librer\u00eda que nos permita mostrar un RGB light (LED) RGB\u00a0donde cada color estar\u00e1 controlado por una se\u00f1al PWM. Este RGB light nos permitir\u00e1 mostrar a qu\u00e9 distancia se encuentra un obst\u00e1culo del coche.</p> <p>Como ya hicimos en las versiones anteriores, (i) vamos a implementar la parte portable <code>PORT</code> dependiente del HW para comunicarnos con el RGB light (LED) RGB, y lo probaremos con un test unitario. (ii) Despu\u00e9s, vamos a crear la l\u00f3gica de la FSM para gestionar la representaci\u00f3n de la distancia con los distintos colores (la parte <code>COMMON</code>), y lo probaremos con un test unitario. (iii) Por \u00faltimo, montaremos el HW y probaremos el funcionamiento del LED RGB\u00a0con un programa de ejemplo.</p> <p>Cuando lea esta introducci\u00f3n conviene que lea y entienda el cap\u00edtulo \"Circuito de reloj\u201d del libro\u00a0<sup>1</sup>, prestando especial atenci\u00f3n al ejemplo proporcionado sobre PWM.</p> <p>Cada uno de los LED (, y ) del RGB light RGB estar\u00e1 conectado a una GPIO del STM32F446RE. Los tres LED est\u00e1n controlados por el mismo temporizador en modo PWM, pero cada uno con un canal de dicho temporizador. La se\u00f1al PWM es una se\u00f1al cuadrada que tiene un periodo fijo y un ciclo de trabajo variable. Si el ciclo de trabajo es del 100\\%, el LED estar\u00e1 a m\u00e1xima intensidad, y si es del 0\\%, el LED estar\u00e1 apagado. Las caracter\u00edsticas a destacar del sistema de la Versi\u00f3n 3 se muestran en el\u00a0.</p> <p>Un color se representa en el RGB light RGB mediante la combinaci\u00f3n de los tres colores b\u00e1sicos: rojo, verde y azul. La combinaci\u00f3n de los tres colores b\u00e1sicos en diferentes proporciones nos permite obtener una amplia gama de colores. La intensidad la controla el ciclo de trabajo (canal del temporizador), pero la frecuencia para los tres colores ser\u00e1 la misma. La frecuencia de la se\u00f1al PWM ser\u00e1 de \\(50 Hz\\), valor lo suficientemente alto para que no se perciba el parpadeo de los LED. Nuestro ojo integrar\u00e1 esos trenes de pulsos y lo veremos como un color determinado. Si se cambia el ciclo de trabajo, estaremos controlando la intensidad de cada LED, y por tanto el color mostrado.</p> <p>\u00bfCu\u00e1ndo cambiaremos los valores del ciclo de trabajo? Pues depende de la distancia a la que se encuentre el objeto detectado por el sensor de RGB light. Cuanto m\u00e1s cerca, m\u00e1s rojo, y cuanto m\u00e1s lejos, m\u00e1s azul. El verde se usar\u00e1 para mostrar distancias intermedias y entre medias tendremos una mezcla de colores. En el se muestran los valores de ciclo de trabajo para seis situaciones de distancia que se contemplan en el sistema Simone. En la Versi\u00f3n 5 puedes implementar funciones de interpolaci\u00f3n para que el cambio de color sea m\u00e1s suave. Tienes una lista de colores en la www.downtownuplighting.com\u2014aunque no todos se pueden mostrar en un LED RGB.</p> <p>La muestra un ejemplo de se\u00f1al PWM para un color amarillento (que no el amarillo de el ). Se muestran en el osciloscopio dos de los LED del RGB light RGB. En la parte superior se muestra el canal de osciloscopio para el LED rojo, y en la parte inferior el canal de osciloscopio para el LED verde. F\u00edjate que el periodo de la se\u00f1al PWM es el mismo para los dos LED (\\(20 ms\\)), pero el ciclo de trabajo es distinto: \\(20.8\\%\\) para el LED rojo y \\(36.6\\%\\) para el LED verde.</p> Ejemplo de se\u00f1ales PWM para un color amarillento. <p>Igual que hemos hecho hasta ahora, estamos desarrollando una librer\u00eda. As\u00ed, cada vez que se quiera a\u00f1adir un RGB light (LED) RGB\u00a0le asociar\u00e9 una FSM. Las particularidades de d\u00f3nde est\u00e1 conectado cada nuevo RGB light, sus caracter\u00edsticas f\u00edsicas, etc., son cosas espec\u00edficas del HW, por lo que estar\u00e1n en <code>PORT</code>.</p> <p>La muestra las estructuras que vamos a necesitar para el RGB light RGB. La estructura del HW del LED RGB\u00a0(en <code>PORT</code>) se muestra en la . La estructura de la FSM (en <code>COMMON</code>) se muestra en la .</p>"},{"location":"notebook/version_3.html#section","title":"{ #section }","text":"<p>Preparemos el proyecto para poder a\u00f1adir el RGB light (LED) RGB:</p> <ol> <li> <p>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT de la librer\u00eda del RGB light correspondientes a la versi\u00f3n <code>V3</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v3. Solo descarga por ahora: <code>port_rgb_light.h</code>, <code>stm32f4_rgb_light.h</code>, y <code>stm32f4_rgb_light.c</code> y col\u00f3calos en las carpetas correspondientes. No a\u00f1adas los ficheros de la parte COMMON.</p> </li> <li> <p>Coloca cada uno donde corresponde: <code>PORT</code> o <code>COMMON</code>, en <code>include</code>, o <code>src</code>, como se explic\u00f3 en el los cap\u00edtulos anteriores.</p> </li> <li> <p>Ver\u00e1s que no compila, y es que solo se proporciona un esqueleto del c\u00f3digo.</p> </li> </ol>"},{"location":"notebook/version_3.html#sec:headers_rgb_light","title":"<code>PORT</code>: cabeceras de la librer\u00eda del RGB light","text":"<p>Vamos a implementar el contrato con el usuario de la parte dependiente del HW de librer\u00eda del RGB light. Esta es la interfaz que vamos a proporcionar al usuario para que pueda usar la librer\u00eda y a\u00f1adir LED RGB\u00a0como necesite. Vamos a portar las funciones necesarias para usar la librer\u00eda, c\u00f3mo no, para la placa Nucleo-STM32F446RE. Comenzaremos de nuevo por la cabecera y luego los c\u00f3digos fuente. El montaje de nuestro RGB light RGB\u00a0con la Nucleo-STM32F446RE\u00a0se muestra en la .</p> Montaje del LED &lt;span style=\"color: red; font-weight: bold;\"&gt;R&lt;/span&gt;&lt;span style=\"color: green; font-weight: bold;\"&gt;G&lt;/span&gt;&lt;span style=\"color: blue; font-weight: bold;\"&gt;B&lt;/span&gt;\u00a0de c\u00e1todo com\u00fan con la &lt;span style=\"color: RoyalBlue; font-weight: bold;\"&gt;Nucleo-STM32F446RE&lt;/span&gt;. <p>En el mercado existen numerosos LED RGB. En este proyecto utilizaremos un LED de c\u00e1todo com\u00fan. En este tipo de LED, el \u00e1nodo de cada LED est\u00e1 conectado a un pin del microcontrolador a trav\u00e9s de una resistencia, y los c\u00e1todos de los tres LED est\u00e1n internamente conectados a un pin com\u00fan que ir\u00e1 a tierra. Para adquirir uno, ve al\u00a0).</p>"},{"location":"notebook/version_3.html#cabecera-port_rgb_lighth","title":"Cabecera port_rgb_light.h","text":"<p>Esta cabecera depende del HW pero no de las particularidades del microcontrolador STM32F446RE. Vamos a seguir los siguientes pasos:</p> <ul> <li> <p>Incluye todas las cabeceras necesarias seg\u00fan indica la API.</p> </li> <li> <p>Incluye los (<code>#define</code>) que se indican en la API para RGB light <code>PORT_RGB_LIGHT_ID</code> que refleja la distancia al objeto en la parte trasera del coche.</p> <ul> <li> <p><code>PORT_RGB_LIGHT_ID</code>: valor num\u00e9rico natural que ser\u00e1 el identificador del RGB light trasero. Si es el \u00fanico RGB light del sistema, le asignaremos el 0.</p> </li> <li> <p><code>COLOR_RGB_MAX_VALUE</code>: valor m\u00e1ximo que puede tomar el ciclo de trabajo de un LED RGB. Usaremos 255 que es el m\u00e1ximo valor que puede tomar un <code>uint8_t</code>.</p> </li> <li> <p><code>COLOR_RED</code>, <code>COLOR_GREEN</code>, \u2026: son estructuras de tipo <code>rgb_color_t</code> que representan los colores de el . Cada estructura tiene tres campos: <code>red</code>, <code>green</code> y <code>blue</code> que representan el ciclo de trabajo en 8 bits. Siendo 0 el ciclo de trabajo m\u00ednimo y 255 el m\u00e1ximo. Es opcional usar estas estructuras, pero es una buena pr\u00e1ctica para que el c\u00f3digo sea m\u00e1s legible.</p> </li> </ul> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_rgb_light.h</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar con Doxygen.</p> </li> </ul> <p>Ya hemos acabado con el encabezado que interact\u00faa con el HW del RGB light y que no depende del microcontrolador. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a programar la cabecera que s\u00ed depende del microcontrolador <code>stm32f4_rgb_light.h</code>.</p>"},{"location":"notebook/version_3.html#cabecera-stm32f4_rgb_lighth","title":"Cabecera stm32f4_rgb_light.h","text":"<p>Esta cabecera solo define los pines a los que est\u00e1 conectado el LED RGB\u00a0de cada RGB light asociado.</p> <ul> <li> <p>Incluye todas las cabeceras necesarias seg\u00fan indica la API.</p> </li> <li> <p>Define (<code>#define</code>) los valores de las GPIO de los pines de los LED rojo, verde y azul.</p> </li> <li> <p>Documenta los <code>#define</code> con Doxygen.</p> </li> </ul> <p>Ya hemos acabado con el encabezado (header) que interact\u00faa con el HW del RGB light conectado al microcontrolador Nucleo-STM32F446RE. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a implementar todas las funciones prototipadas en <code>port_rgb_light.h</code>.</p>"},{"location":"notebook/version_3.html#sec:port_rgb_light","title":"<code>PORT</code>: fuente de la librer\u00eda del RGB light","text":"<p>Vamos a portar las funciones necesarias para usar la librer\u00eda del RGB light y comprobar que la parte HW est\u00e1 bien programada. Vamos a programar los ficheros fuente de la parte <code>PORT</code>, que todos estar\u00e1n en el fichero <code>stm32f4_rgb_light.c</code>. Deber\u00e1s implementar o completar todas las funciones p\u00fablicas de las que se hayan declarado el prototipo en el encabezado y algunas funciones privadas.</p>"},{"location":"notebook/version_3.html#fuentes-stm32f4_rgb_lightc","title":"Fuentes stm32f4_rgb_light.c","text":"<p>Este fichero es mucho menos extenso que el de la versi\u00f3n anterior. La mayor complejidad est\u00e1 en la configuraci\u00f3n de los canales del temporizador, pero si ha le\u00eddo el cap\u00edtulo del libro relativo a PWM y lo ha entendido, no deber\u00eda tener problema\u00a0<sup>1</sup>. Vamos a ello.</p> <ol> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Hay que definir la estructura <code>stm32f4_rgb_light_hw_t</code>. En la estructura se definen los campos que se muestran en la y en la API.</p> <p>Esta estructura es gen\u00e9rica para cualquier LED RGB\u00a0que vayamos a usar, no solo el referente al trasero del coche, sino cualquier otro que queramos a\u00f1adir. Es muy sencilla y b\u00e1sicamente contiene los campos de las GPIO de los pines de los LED rojo, verde y azul.</p> </li> <li> <p>Igual que hicimos con el bot\u00f3n, ahora vamos a definir una variable global privada <code>static stm32f4_rgb_light_hw_t rgb_lights_arr[]</code>. Se trata del array de estructuras de tipo <code>stm32f4_rgb_light_hw_t</code>, que representa al HW de cada RGB light que tengamos en nuestro coche.</p> <p>Asigna los valores HW del LED RGB\u00a0de aparcamiento trasero <code>PORT_RGB_LIGHT_ID</code> utilizando los <code>#define</code> de <code>stm32f4_rgb_light.h</code>.</p> </li> <li> <p>Codifica la funci\u00f3n <code>_stm32f4_rgb_light_get()</code> de manera an\u00e1loga a como se ha hecho en las versiones anteriores.</p> </li> </ol>"},{"location":"notebook/version_3.html#_1","title":"Versi\u00f3n 3","text":"<p>Ahora vamos a codificar las funciones m\u00e1s importantes de la parte <code>PORT</code> del RGB light, y son las que configuran el temporizador asociado al LED RGB\u00a0trasero.</p> <ol> <li> <p>Codifica la funci\u00f3n <code>_timer_pwm_config()</code> como indica la API. Esta funci\u00f3n configura el temporizador que controla los ciclos de trabajo de los LED rojo, verde y azul. Para ello, ap\u00f3yate en el ejemplo \"timer para PWM\u201d del libro de Fundamentos\u00a0<sup>1</sup>.</p> <p>Esta funci\u00f3n configura un temporizador para que genere una se\u00f1al PWM con una frecuencia fija y un ciclo de trabajo variable. El temporizador elegido y la frecuencia se muestra en el .</p> <p>Esta funci\u00f3n recibe el identificador del RGB light RGB. Cada RGB light tendr\u00e1 su propio temporizador, pero esta funci\u00f3n ser\u00e1 llamada para configurar todos ellos. Aseg\u00farate de que el c\u00f3digo se ejecuta dentro de un bloque condicional que compruebe el identificador del RGB light.</p> <p>Para saber qu\u00e9 fuente de reloj habilitar para el temporizador, consulta la tabla \"Figure 3. STM32F446xC/E block diagram\u201d del datasheet <sup>2</sup>. All\u00ed podr\u00e1s ver si nuestro temporizador est\u00e1 conectado al APB1 o al APB2, y tenemos que habilitar el reloj en el registro <code>RCC-&gt;APB1ENR</code> o <code>RCC-&gt;APB2ENR</code> respectivamente.</p> <p>Puedes poner los valores de los registros <code>TIMx-&gt;PSC</code> y <code>TIMx-&gt;ARR</code> a mano, o usando las ecuaciones. Puedes crear un <code>#define</code> para la frecuencia de la se\u00f1al PWM, si te es m\u00e1s c\u00f3modo. Si lo haces a mano, aseg\u00farate de que los valores son correctos.</p> <p>Aseg\u00farate de que los registro Capture Compare Enable Register (<code>CCER</code>) y Capture Compare Mode Register (<code>CCMRx</code>) est\u00e1n configurados correctamente. En el CCER se habilitan los canales de salida y en el CCMRx se configura el modo PWM. La x es el registro 1 o 2, dependiendo del canal que est\u00e9s configurando.</p> <p>Es muy importante que la funci\u00f3n <code>_timer_pwm_config()</code> se llame desde la funci\u00f3n <code>port_rgb_light_init()</code>. Si no, no se podr\u00e1n generar las se\u00f1ales PWM.</p> </li> </ol> <p>Vamos a continuar con las funciones p\u00fablicas de la parte <code>PORT</code> del RGB light.</p> <ol> <li> <p>Completa la funci\u00f3n <code>port_rgb_light_init()</code> como se indica en la API.</p> <p>Configura las GPIO y el modo alternativo de los tres LED RGB. Para ello, consulta la tabla de Funci\u00f3n Alternativa del datasheet <sup>2</sup>.</p> <p>Aseg\u00farate de que la funci\u00f3n <code>_timer_pwm_config()</code> se llama desde esta funci\u00f3n y que el LED RGB\u00a0comienza apagado.</p> </li> <li> <p>Codifica la funci\u00f3n <code>port_rgb_light_set_rgb</code> siguiendo la API.</p> <p>Esta funci\u00f3n se encarga de configurar el ciclo de trabajo de los LED rojo, verde y azul. Lo hace con la proporci\u00f3n de los valores recibidos en la estructura <code>rgb_color_t</code> sobre el m\u00e1ximo valor definido en <code>COLOR_RGB_MAX_VALUE</code>. Si el valor recibido es 0, el LED estar\u00e1 apagado, deshabilitando el canal correspondiente.</p> <p>F\u00edjate que la funci\u00f3n recibe el identificador del RGB light RGB. Aseg\u00farate de que el c\u00f3digo se ejecuta dentro de un bloque condicional que compruebe el identificador del RGB light.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>Si ahora compila, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado del RGB light (LED) RGB! Vamos a probarlo con el test unitario de la parte <code>PORT</code>.</p>"},{"location":"notebook/version_3.html#sec:test_port_v3","title":"<code>PORT</code>: Test unitario del RGB light","text":"<p>Vamos a comprobar que la parte <code>PORT</code> funciona correctamente pasando los test HW del c\u00f3digo que hemos desarrollado de la librer\u00eda del RGB light (LED) RGB\u00a0antes de continuar con la FSM.</p> <p>\u00a1Importante! Los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente. \u00a0Ten a mano y revisa el cap\u00edtulo \"Test unitarios y ejemplos de integraci\u00f3n\u201d del libro de fundamentos te\u00f3ricos\u00a0<sup>1</sup>.</p> <p>Descarga el fichero de test HW del RGB light <code>test_port_rgb_light.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v3_test. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto.</p> <ol> <li> <p>Conecta la placa Nucleo-STM32\u00a0al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_port_rgb_light</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Comprueba que todos los test pasan correctamente en el texto mostrado en la terminal de depuraci\u00f3n. Si no es as\u00ed, lee los mensajes de error y corrige tu c\u00f3digo hasta que pase todas las pruebas. Si no pasa las pruebas, no contin\u00faes con el siguiente test.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pase todos los test.</p> </li> </ol> <p>\u00a1Ya hemos acabado con la parte <code>PORT</code> del RGB light! Vamos ahora a implementar la parte <code>COMMON</code>.</p>"},{"location":"notebook/version_3.html#common-cabecera-de-la-fsm-del-rgb-light","title":"<code>COMMON</code>: cabecera de la FSM del RGB light","text":""},{"location":"notebook/version_3.html#consideraciones-de-la-fsm-del-RGB","title":"Consideraciones de la FSM del RGB light","text":""},{"location":"notebook/version_3.html#_2","title":"Versi\u00f3n 3","text":"<p>Antes de empezar vamos a partir de una serie de consideraciones.</p> <ul> <li> <p>La FSM almacena la \u00faltima distancia que se le ha indicado que tiene que representar.</p> </li> <li> <p>La FSM contiene un campo de estado (<code>status</code>) que indica si el RGB light est\u00e1 activo. El sistema Simone puede estar en modo aparcamiento y el ultrasonidos puede estar tomando medidas, pero el RGB light se puede desactivar para que no moleste. Si el RGB light est\u00e1 desactivado, no se mostrar\u00e1 ning\u00fan color. Esto es habitual, sobre todo cuando el sistema de notificaci\u00f3n de obst\u00e1culos es un pitido. En otras situaciones, por ejemplo, con m\u00e1s sensores alrededor del coche, el RGB light puede estar activo.</p> <p>La m\u00e1quina de estados superior, la del sistema Simone, ser\u00e1 la que indique si el RGB light est\u00e1 activo o no. La FSM del RGB light solo se encargar\u00e1 de representar la distancia en colores si est\u00e1 activo.</p> </li> <li> <p>La FSM contiene otro flag que indica si el RGB light est\u00e1 en modo ocioso (<code>idle</code>). En este estado, el RGB light ya ha puesto un color, no se ha cambiado la distancia, y podemos entrar en un modo de bajo consumo Sleep Mode (Versi\u00f3n 4). Esto puede ser normal en una situaci\u00f3n en la que se est\u00e1 aparcando (marcha atr\u00e1s) y no se est\u00e1 moviendo. En Sleep Mode, el n\u00facleo del procesador se detiene, pero los perif\u00e9ricos y el sistema de reloj contin\u00faan funcionando, por eso el LED permanecer\u00e1 encendido en el color que se haya quedado.</p> </li> <li> <p>El flag <code>new_color</code> lo activa la m\u00e1quina de estados de Simone cuando se ha cambiado la distancia a representar. La FSM del RGB light comprobar\u00e1 este flag para saber si tiene que cambiar el color del LED.</p> </li> <li> <p>El valor de inicio de distancia al arrancar la FSM debe ser negativo, de tal manera que nos aseguremos que es una distancia inv\u00e1lida y el LED RGB\u00a0permanezca apagado. El valor de la distancia se mide en cent\u00edmetros.</p> </li> <li> <p>La FSM contiene informaci\u00f3n del identificador (<code>ID</code>) del RGB light. Este <code>ID</code> es \u00fanico y gestionado por el usuario en el <code>PORT</code>. Ah\u00ed es donde el usuario proporciona identificadores e informaci\u00f3n HW (GPIO a la que est\u00e1 conectado) para todos los RGB light (LED) RGB\u00a0del sistema.</p> </li> </ul> M\u00e1quina de estados del RGB light. <p>Nuestra librer\u00eda implementa la l\u00f3gica de la FSM mostrada en la y que llamaremos <code>fsm_rgb_light</code> (en los ficheros <code>.c</code> y <code>.h</code>). Tiene 2 estados en los que:</p> <ul> <li> <p><code>WAIT_COLOR</code>: estado inicial de la FSM. En este estado la FSM espera a que se le indique una distancia para representar. Si se le indica una distancia, se calcula el color y se cambia al estado <code>SET_COLOR</code>. Tambi\u00e9n se vuelve a este estado cuando el sistema de aparcamiento no est\u00e1 activo (<code>status</code> es <code>false</code>).</p> </li> <li> <p><code>SET_COLOR</code>: en este estado la FSM calcula el color en funci\u00f3n de la distancia que se le ha indicado. Tras poner el color, se activa el flag <code>idle</code> y se queda en este estado.</p> </li> </ul> <p>La parte <code>COMMON</code> de nuestra librer\u00eda trabaja con la estructura (<code>struct</code>) p\u00fablica que se muestra en la . El tipo de esta estructura est\u00e1 declarada en el fichero <code>fsm_rgb_light.h</code> (<code>typedef struct fsm_rgb_light_t fsm_rgb_light_t;</code>), pero la definici\u00f3n de la estructura est\u00e1 en el fichero <code>.c</code>.</p> <ol> <li>Lo primero, descarga del repositorio de la asignatura los ficheros correspondientes a la parte COMMON de la librer\u00eda del RGB light correspondientes a la versi\u00f3n <code>V3</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v3. Solo descarga lo que faltaba por implementar, es decir, los ficheros <code>fsm_rgb_light.h</code> y <code>fsm_rgb_light.c</code>. Ponlos en las carpetas correspondientes de tu proyecto.</li> </ol> <p>Ahora, vamos a completar la cabecera de la FSM del RGB light, <code>fsm_rgb_light.h</code>.</p> <ol> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Ahora vamos a definir el enumerado con los nombres de los estados de la FSM. Escribe el <code>enum</code> <code>FSM_RGB_LIGHT_SYSTEM</code> con los nombres de los estados del diagrama de la .</p> </li> <li> <p>Defina los <code>#define</code> que se indican en la API para las distancias m\u00e1ximas y m\u00ednimas que se pueden representar en el RGB light. Estas distancias son las que se indican en el . El valor de la distancia se mide en cent\u00edmetros, y el m\u00e1ximo de un umbral coincide con el m\u00ednimo del siguiente, *e.g.*\u00a0<code>DANGER_MAX_CM</code> es igual a <code>LEVEL_MEDIUM_MIN_INTENSITY</code>, etc.</p> </li> <li> <p>Es buena pr\u00e1ctica ir documentado el c\u00f3digo a la vez que se programa.</p> </li> <li> <p>Seguidamente declararemos la estructura <code>fsm_rgb_light_t</code> para hacerla p\u00fablica. No obstante, no vamos definir sus campos p\u00fablicamente, como se ha indicado anteriormente.</p> </li> </ol> <p>Continuamos con las declaraciones de funciones p\u00fablicas de la librer\u00eda. Procedamos:</p> <ol> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>fsm_rgb_light.h</code>. A\u00f1ada la funci\u00f3n <code>fsm_rgb_light_check_activity()</code> aunque la usaremos en la siguiente versi\u00f3n, tambi\u00e9n ser\u00e1 necesaria para el test de la FSM.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen.</p> </li> </ol> <p>Vamos ahora a programar el fichero fuente <code>fsm_rgb_light.c</code>.</p>"},{"location":"notebook/version_3.html#common-fuente-de-la-fsm-del-rgb-light","title":"<code>COMMON</code>: fuente de la FSM del RGB light","text":"<p>Vamos a proceder con la implementaci\u00f3n de las funciones del RGB light. Deber\u00e1s implementar todas las funciones p\u00fablicas de las que ya has declarado el prototipo en el encabezado, y la funci\u00f3n privada que aparece en la API del fichero <code>fsm_rgb_light.c</code>. Tambi\u00e9n definiremos las variables globales y estructuras que sean necesarias. \u00a1Recuerda que las funciones privadas no se declaran en el <code>.h</code>!</p> <ul> <li> <p>Lo primero que debe aparecer es la inclusi\u00f3n de cabeceras como indica la API.</p> </li> <li> <p>Vamos a declarar la estructura <code>fsm_rgb_light_t</code>. Definiremos la estructura con los campos que se muestran en la . Es muy importante que la m\u00e1quina de estados del RGB light <code>fsm_t</code> sea el primer campo.</p> </li> <li> <p>De igual modo, es buen momento para aprovechar a documentar la estructura.</p> </li> </ul> <p>Ahora empezamos a codificar las funciones privadas de la FSM. Bajo la l\u00ednea de <code>/* Private functions */</code> vamos a codificar la funci\u00f3n <code>_compute_rgb_light_levels()</code>.</p> <ol> <li> <p>Codifica la funci\u00f3n <code>_compute_rgb_light_levels()</code> que se encarga de calcular los niveles de ciclo de trabajo de cada LED rejo, verde y azul. Esta funci\u00f3n recoge de la estructura de la FSM la distancia, y sigue el flujograma de la API. Puedes asignar el valor a cada campo de la estructura <code>rgb_color_t *p_color</code> directamente o, si definiste las estructuras de colores en el <code>.h</code>, puedes asignarlas a la estructura de color. Ten en cuenta que el valor que almacenan no es el ciclo de trabajo entre 0 y 100, sino entre 0 y 255.</p> </li> <li> <p>Documenta la funci\u00f3n con Doxygen.</p> </li> </ol> <p>Continuamos con las funciones de entrada o comprobaci\u00f3n <code>check_</code> de la FSM bajo la l\u00ednea de <code>/* State machine input or transition functions */</code>.</p> <ol> <li> <p>Codifica las funciones <code>check_active()</code>, <code>check_set_new_color()</code> y, <code>check_off()</code> como se indica en la API.</p> </li> <li> <p>Documenta las funciones con Doxygen, encima del nombre de cada funci\u00f3n.</p> </li> </ol> <p>Seguiremos con las funciones de salida o actualizaci\u00f3n de la FSM <code>do_</code>.</p> <ol> <li> <p>Codifica las funciones <code>do_set_on()</code>, <code>do_set_color()</code> y, <code>do_set_off()</code> como se indica en la API.</p> </li> <li> <p>Documenta las funciones con Doxygen. En este caso, igual que antes, la documentaci\u00f3n ir\u00e1 en el <code>.c</code>, encima del nombre de cada funci\u00f3n.</p> </li> </ol>"},{"location":"notebook/version_3.html#_3","title":"Versi\u00f3n 3","text":"<p>Todav\u00eda no hemos acabado con el desarrollo, pero puedes compilar para ir depurando errores.</p> <ol> <li> <p>Declara la tabla de transiciones de la FSM <code>fsm_trans_rgb_light</code>. Esto eliminar\u00e1 muchos errores de compilaci\u00f3n.</p> </li> <li> <p>Completa la funci\u00f3n de inicializaci\u00f3n de la FSM <code>fsm_rgb_light_init()</code> como se indica en la API. En esta funci\u00f3n se inicializan los campos de la estructura de la FSM, y se llama a la funci\u00f3n <code>fsm_init()</code> para inicializar la m\u00e1quina de estados. Tambi\u00e9n se llama a la funci\u00f3n <code>port_rgb_light_init()</code> para inicializar el HW del LED RGB.</p> </li> <li> <p>Codifica las funciones <code>fsm_rgb_light_fire()</code> y <code>fsm_rgb_light_destroy()</code> igual que hiciste en las versiones anteriores. Estas funciones lanzan la FSM y liberan la memoria respectivamente.</p> </li> <li> <p>Codifica las funciones <code>fsm_rgb_light_get_inner_fsm()</code> y <code>fsm_rgb_light_get_state()</code>. Se usar\u00e1n en el test de la FSM.</p> </li> <li> <p>Codifica las funciones <code>fsm_rgb_light_get_intensity()</code>, <code>fsm_rgb_light_set_level()</code>, <code>fsm_rgb_light_get_status()</code> y <code>fsm_rgb_light_set_status()</code> como se indica en la API.</p> </li> </ol> <p>Ya hemos acabado con la programaci\u00f3n de la librer\u00eda del RGB light. Ahora, si compilas, no deber\u00e1n aparecer errores.</p> <ol> <li>Documenta el c\u00f3digo que est\u00e9 sin comentar todav\u00eda.</li> </ol>"},{"location":"notebook/version_3.html#sec:test_fsm_v3","title":"<code>COMMON</code> Test unitario de la FSM del RGB light","text":"<p>Vamos a hacer el test del c\u00f3digo que hemos desarrollado de la librer\u00eda de la m\u00e1quina de estados del RGB light y probar que funciona antes de continuar con la siguiente versi\u00f3n.</p> <p>\u00a1Importante! Recuerda que los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente.</p> <p>Descarga el fichero de test de la FSM del RGB light <code>test_fsm_rgb_light.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v3_test. Ponlo en la carpeta <code>test/</code> de tu proyecto. \u00a1No lo metas en stm32f4/, pues no es un test espec\u00edfico del microcontrolador!</p> <ol> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_fsm_rgb_light</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso.</p> </li> <li> <p>Comprueba los mensajes del <code>gdb-server</code> para ver el resultado de las pruebas de los tests. Deber\u00eda haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu c\u00f3digo hasta que pasen todas las pruebas. Si no pasan las pruebas, no contin\u00faes.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pasen todos los test.</p> </li> </ol>"},{"location":"notebook/version_3.html#ejemplo-de-uso-de-la-version-3","title":"Ejemplo de uso de la Versi\u00f3n 3","text":"<p>En este test de integraci\u00f3n del RGB light es responsabilidad del alumno comprobar que la funcionalidad es la esperada. El ejemplo que se da no contempla todas las situaciones.</p> <p>Descarga el fichero de ejemplo <code>example3\u030c.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v3_test. Ponlo en la carpeta <code>example/</code> de tu proyecto.</p> <p>Procedamos:</p> <p>Para poder hacer el ejemplo del RGB light, necesitamos montar el LED RGB. En la se muestra un ejemplo de montaje.</p> <ol> <li> <p>Monte el HW como se muestra en la .</p> </li> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>example_v3</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Se parar\u00e1 en la primera l\u00ednea del <code>main()</code>. Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso. Este c\u00f3digo no termina, pues es un bucle <code>while</code> infinito.</p> </li> <li> <p>Abre la terminal del <code>gdb-server</code> para ver los mensajes que se van imprimiendo.</p> </li> <li> <p>Comprueba que los colores del LED RGB\u00a0cambian en funci\u00f3n de la distancia que se le indica en los mensajes de la terminal.</p> </li> <li> <p>Haz distintas pruebas y aseg\u00farate de que el comportamiento es el adecuado.</p> </li> </ol> <p>\u00a1Hemos creado nuestra tercera librer\u00eda! F\u00edjate que es portable a cualquier plataforma solo con adaptar las funciones del <code>PORT</code>.</p> <p>No dejes de documentar el c\u00f3digo. Comprueba que la documentaci\u00f3n del c\u00f3digo se ha generado correctamente como se explica en la \"Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C\u201d <sup>4</sup>., o en el v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d.</p> <p>Guarda una copia de su proyecto como <code>simone_v3</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla.</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Daniel Capell\u00e1n Mart\u00edn, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Amadeo de Gracia Herranz. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_4.html","title":"Versi\u00f3n 4: integraci\u00f3n final y modos de bajo consumo","text":""},{"location":"notebook/version_4.html#sec:low_power_modes","title":"Modos de bajo consumo","text":"<p>Ya tenemos todos los elementos del sistema para que sea funcional. Quiz\u00e1s quisi\u00e9ramos \u2014si se hace el dise\u00f1o correspondiente\u2014 dise\u00f1ar una PCB para desplegarlo en alg\u00fan sitio. Si hici\u00e9semos esto, muy seguramente alimentar\u00edamos el dispositivo con una bater\u00eda. Si midi\u00e9semos el consumo con un amper\u00edmetro, podr\u00edamos calcular la autonom\u00eda de nuestro sistema. Te habr\u00e1s fijado que en los dispositivos comerciales como relojes inteligentes, mandos de TV, dispositivos IoT\u2026la autonom\u00eda puede superar de largo varios meses con un uso normal del mismo. Para conseguir esto contamos con los modos de bajo consumo. Buena parte de los microcontroladores que hoy en d\u00eda se precien cuentan con distintos modos de bajo consumo. Lea la secci\u00f3n \u201cModos de bajo consumo\u201d del libro de Fundamentos Te\u00f3ricos\u00a0<sup>1</sup>.</p> <p>En esta versi\u00f3n, antes de hacer la integraci\u00f3n final, vamos a implementar unas pocas funciones para gestionar el modo sleep de bajo consumo en nuestro sistema. Esto se destaca en 2 estados de la FSM de Simone que veremos m\u00e1s adelante. Estos estados comprueban si alguna de las FSM de los elementos est\u00e1, o no, activa, y en caso de que todas est\u00e9n inactivas, se va a dormir. El sistema se despertar\u00e1 ante alguna interrupci\u00f3n de un timer o interrupci\u00f3n externa (pulsaci\u00f3n de bot\u00f3n o teclado).</p> <p>Antes de empezar a implementar las funciones de bajo consumo vamos a partir de una serie de consideraciones de la FSM. En la siguiente secci\u00f3n se detallan mucho m\u00e1s los estados, pero por ahora, nos fijamos en lo relativo al bajo consumo:</p> <ul> <li> <p>En bajo consumo desactivaremos el SysTick para que no despierte al sistema cada \\(1 ms\\). As\u00ed pues, el contador del sistema no aumenta mientras se est\u00e1 dormido.</p> </li> <li> <p>Las ISR que generan interrupciones externas \u2014bot\u00f3n y teclado matricial\u2014 son las encargadas de reactivar el SysTick.</p> </li> <li> <p>La FSM del bot\u00f3n est\u00e1 inactiva en el estado <code>BUTTON_RELEASED</code>.</p> </li> <li> <p>La FSM del teclado matricial est\u00e1 inactiva en el estado <code>KEYBOARD_RELEASED_WAIT_ROW</code>.</p> </li> <li> <p>La FSM del RGB light est\u00e1 activa si el status indica que est\u00e1 funcionando, y no est\u00e1 ocioso (idle).</p> </li> <li> <p>Las autotransiciones de los estados de la FSM Simone (<code>SLEEP_WHILE_IDLE</code> y <code>SLEEP_WHILE_PLAYBACK</code>) est\u00e1n pensadas para cuando est\u00e9 trabajando en depuraci\u00f3n. El depurador genera interrupciones en la ejecuci\u00f3n del c\u00f3digo que despiertan a nuestro sistema. Como no se trata de interrupciones de nuestros elementos, no pasaremos a los estados, pero debemos dormirnos mientras no se detenga el depurador de nuevo en otro breakpoint. Este es el cometido de dichas autotransiciones.</p> </li> </ul> <p>Procedamos. Como siempre, tenga abierta la p\u00e1gina web de la API https://sdg2dieupm.github.io/simone/, ah\u00ed est\u00e1n todos los detalles de implementaci\u00f3n. Ahora vamos a tocar varios ficheros pero no crearemos ninguno nuevo.</p> <p>Vamos a a\u00f1adir las funciones de comprobaci\u00f3n espec\u00edficas de cada m\u00e1quina de estados.</p> <ol> <li> <p>En <code>fsm_button.c</code>: A\u00f1ade la funci\u00f3n <code>fsm_button_check_activity()</code> y su prototipo y documentaci\u00f3n del c\u00f3digo en <code>fsm_button.h</code>.</p> </li> <li> <p>En <code>fsm_keyboard.c</code> a\u00f1ade la funci\u00f3n <code>fsm_keyboard_check_activity()</code> y su prototipo y documentaci\u00f3n del c\u00f3digo en <code>fsm_keyboard.h</code>.</p> </li> <li> <p>En <code>fsm_rgb_light.c</code> a\u00f1ade la funci\u00f3n <code>fsm_rgb_light_check_activity()</code> y su prototipo y documentaci\u00f3n en <code>fsm_rgb_light.h</code>.</p> </li> </ol> <p>Para terminar, vamos a a\u00f1adir las funciones HW espec\u00edficas de manejo del modo stop y sleep en nuestro STM32F446RE. Primero a\u00f1adiremos algunas funciones generales del sistema en <code>stm32f4_system.c</code>; luego las modificaciones necesarias para restablecer el reloj de sistema SysTick tras una interrupci\u00f3n del bot\u00f3n o del teclado matricial, o de temporizador.</p> <p>En <code>stm32f4_system.c</code>:</p> <ol> <li> <p>Copia el c\u00f3digo de <code>port_system_power_stop()</code> y <code>port_system_power_sleep()</code> de la API. Por tener un orden, puedes hacerlo en una parte dedicada a POWER RELATED FUNCTIONS.</p> </li> <li> <p>Copia el c\u00f3digo de <code>port_system_systick_suspend()</code> de la API. Por tener un orden, puedes hacerlo en la parte dedicada a TIMER RELATED FUNCTIONS.</p> </li> <li> <p>Copia el c\u00f3digo de <code>port_system_systick_resume()</code> de la API. Por tener un orden, puedes hacerlo tambi\u00e9n en la parte dedicada a TIMER RELATED FUNCTIONS.</p> </li> <li> <p>Implementa la funci\u00f3n <code>port_system_sleep()</code> como indica la API. Por tener un orden, puedes hacerlo junto con las anteriores en la parte dedicada a POWER RELATED FUNCTIONS.</p> </li> </ol> <p>En <code>port_system.h</code>:</p> <ol> <li>A\u00f1ade los prototipos de las funciones anteriores y su documentaci\u00f3n.</li> </ol> <p>En el fichero en el que se encuentran nuestras ISR, <code>interr.c</code>, a\u00f1ade al principio de todas las ISR de todos las GPIO la llamada a <code>port_system_systick_resume()</code> para reactivar el contador del sistema SysTick inmediatamente tras la interrupci\u00f3n de pulsaci\u00f3n de cualquier tecla o del bot\u00f3n de usuario: <code>EXTI15_10_IRQHandler()</code>, <code>EXTI4_IRQHandler()</code>, y <code>EXTI9_5_IRQHandler()</code>.</p> <p>\u00a1Ya tenemos un sistema eficiente energ\u00e9ticamente! En el futuro ten siempre en consideraci\u00f3n la importancia de estos modos de bajo consumo en cualquier sistema embebido que se alimente con bater\u00edas. Vamos a unir todas las piezas.</p>"},{"location":"notebook/version_4.html#sec:fsm_simone_1","title":"Integraci\u00f3n final","text":"<p>Ya tenemos todos los m\u00f3dulos de las versiones V1-V3 de Simone desarrollados y probados: bot\u00f3n, teclado matricial y RGB light (LED) RGB. Ahora vamos a integrarlos en el sistema central, y rellenar el <code>main.c</code> del programa. Procedamos:</p> <p>La m\u00e1quina de estados del sistema Simone involucra a todos los elementos del mismo y la gesti\u00f3n del bajo consumo. Ser\u00e1 una implementaci\u00f3n principalmente de la l\u00f3gica de control del juego en <code>fsm_simone.c</code> y <code>fsm_simone.h</code>. La parte dependiente del hardware (<code>PORT</code>) relacionada con la temporizaci\u00f3n del juego (<code>port_simone</code>) se os proporciona parcialmente implementada para facilitar la integraci\u00f3n.</p>"},{"location":"notebook/version_4.html#sec:fsm_simone_main","title":"Mec\u00e1nica del juego y reglas","text":"<p>El sistema debe gestionar la l\u00f3gica del juego, tiempos de espera, niveles de dificultad y la interacci\u00f3n con los drivers de hardware (bot\u00f3n, teclado matricial y LED RGB).</p>"},{"location":"notebook/version_4.html#inicio","title":"Inicio","text":"<p>El sistema arranca en reposo en el estado <code>IDLE</code>. Al pulsar el bot\u00f3n de usuario, el sistema arranca pansando al estado que gestiona las secuencias de colores.</p> <p>El juego tiene 3 niveles de dificultad predefinidos: f\u00e1cil, medio y dif\u00edcil. Al arrancar el sistema, empieza en modo f\u00e1cil por defecto.</p> <p>Los niveles predefinidos son: <code>LEVEL_EASY</code>, <code>LEVEL_MEDIUM</code> y <code>LEVEL_HARD</code>.</p> <p>Consejo</p> <p>Utiliza un <code>enum</code> para definir los niveles y <code>#defines</code> para definir las teclas de cad nivel. La FSM tendr\u00e1 un campo <code>level</code> en su estructura para guardar el nivel del juego.</p>"},{"location":"notebook/version_4.html#generacion-de-secuencia-de-colores-y-teclas-asociadas","title":"Generaci\u00f3n de secuencia de colores y teclas asociadas","text":"<p>El juego b\u00e1sico usa 6 colores para mostrar al usuario de manera aleatoria en una secuencia, y se define tambi\u00e9n el color apagado para parpadear entre colores. Cada color estar\u00e1 asociado a una tecla. Los colores est\u00e1n definidos en <code>rgb_colors.h</code> como estructuras de tipo <code>rgb_color_t</code>. Las asociaciones son las siguientes:</p> Tecla Color '0' <code>color_white</code> '1' <code>color_red</code> '2' <code>color_green</code> '3' <code>color_blue</code> '5' <code>color_yellow</code> '8' <code>color_turquoise</code> <p>El n\u00famero de colores se debe definir en el fichero de cabecera con la etiqueta <code>NUMBER_OF_COLORS_GAME</code>.</p> <p>Cada color de la secuencia se mostrar\u00e1 a una velocidad (tiempo que tarda en apagarse), y a una intensidad lum\u00ednica. La dificultad rige estos dos par\u00e1metros elegidos al inicio del juego.</p> Nivel Velocidad por color Intensidad m\u00ednima <code>LEVEL_EASY</code> <code>SIMONE_TIME_ON_LEVEL_EASY_MS</code>: 3000 ms <code>LEVEL_EASY_MIN_INTENSITY</code>: 80% <code>LEVEL_MEDIUM</code> <code>SIMONE_TIME_ON_LEVEL_MEDIUM_MS</code>: 2000 ms <code>LEVEL_MEDIUM_MIN_INTENSITY</code>: 50% <code>LEVEL_HARD</code> <code>SIMONE_TIME_ON_LEVEL_HARD_MS</code>: 1000 ms <code>LEVEL_HARD_MIN_INTENSITY</code>: 20% <p>En todos los casos el tiempo de apagado entre colores es fijo: <code>SIMONE_TIME_OFF_BETWEEN_COLORS_MS</code>: 300 ms, que se debe definir en el fichero de cabecera. De igual modo se debe definir el tiempo de espera m\u00e1ximo para la entrada del usuario entre pulsaciones: <code>SIMONE_TIME_WAIT_INPUT_MS</code>: 5000 ms, y el timpo de feedback visual al usuario tras cada pulsaci\u00f3n: <code>SIMONE_TIME_VISUAL_FEEDBACK_MS</code>: 300 ms.</p> <p>La longitud de la secuencia m\u00e1xima es fija para todos los niveles <code>SEQUENCE_LENGTH</code>: 5 colores. Cuando el jugador complete la secuencia m\u00e1xima en un nivel, el sistema subir\u00e1 autom\u00e1ticamente al siguiente nivel (si no est\u00e1 ya en el m\u00e1ximo) y reiniciar\u00e1 la secuencia.</p> <p>Consejo</p> <p>Declara los <code>#define</code> de velocidad e intensidad en <code>fsm_simone.h</code> para mayor legibilidad.</p> <p>El juego debe comportarse de forma determinista siguiendo las siguientes reglas:</p>"},{"location":"notebook/version_4.html#flujo-del-juego","title":"Flujo del juego","text":"<ol> <li> <p>Ronda:</p> <ul> <li>El sistema a\u00f1ade un color aleatorio a la secuencia.</li> <li>El sistema reproduce la secuencia completa usando el LED (respetando la velocidad del nivel actual). Nota: Debe haber un breve instante de apagado entre colores consecutivos para distinguirlos si son el mismo.</li> <li>El sistema espera a que el usuario repita la secuencia.</li> </ul> </li> <li> <p>Turno del jugador:</p> <ul> <li>El usuario debe pulsar las teclas en el orden correcto.</li> <li>Timeout de usuario: Si el usuario tarda m\u00e1s de <code>SIMONE_TIME_WAIT_INPUT_MS</code> milisegundos en pulsar una tecla entre paso y paso, pierde la partida. Se ha establcido que este valor sea de 5000 ms.</li> <li>Si se pulsa una tecla incorrecta, pierde la partida.</li> <li>Si se pulsa una tecla correcta, se reinicia el temporizador y el jugador tiene otros <code>SIMONE_TIME_WAIT_INPUT_MS</code> milisegundos para pulsar la siguiente tecla.</li> </ul> </li> <li> <p>Victoria de ronda y juego:</p> <ul> <li>Si el usuario completa la secuencia actual correctamente, el sistema a\u00f1ade un nuevo color y repite el proceso (Ronda + 1).</li> <li>Si el usuario completa la secuencia de m\u00e1xima longitud <code>SEQUENCE_LENGTH</code> correctamente, aumenta de nivel.</li> <li>Si el usuario ya estaba en el nivel m\u00e1ximo y completa la secuencia, gana la partida y la FSM va al estado <code>IDLE</code>.</li> </ul> </li> <li> <p>Game over</p> <ul> <li>Si el usuario pierde (por error o por timeout), el sistema debe mostrar un mensaje de resultado y volver al estado de reposo para permitir empezar una nueva partida.</li> </ul> </li> </ol>"},{"location":"notebook/version_4.html#instrucciones-de-implementacion","title":"Instrucciones de implementaci\u00f3n","text":"<p>Para el desarrollo de la FSM, se os proporcionan la parte portable <code>PORT</code>, algunos <code>#define</code> de <code>fsm_simone.h</code>, y alg\u00fan c\u00f3digo en <code>fsm_simone.c</code>, como dos funciones auxiliares que facilitan la conversi\u00f3n entre los tipos de datos:</p> <ul> <li><code>_get_key_from_color()</code>: devuelve el car\u00e1cter asociado a un color (ej. '1' para Rojo).</li> <li><code>_get_color_from_key()</code>: devuelve el color asociado a un car\u00e1cter.</li> </ul> <p>Deb\u00e9is implementar el resto de la l\u00f3gica siguiendo la tabla de transiciones que dise\u00f1\u00e9is bas\u00e1ndoos en la especificaci\u00f3n de la FSM. Deb\u00e9is  completar el fichero de cabecera con los prototipos de funci\u00f3n y a\u00f1adir cualquier <code>#include</code>, <code>#define</code>, o funci\u00f3n auxiliar que consider\u00e9is necesaria para el correcto funcionamiento.</p> <p>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT y COMMON de la librer\u00eda de Simone correspondientes a la versi\u00f3n <code>V4</code>: https://github.com/sdg2DieUpm/simone/tree/simone_v4 y col\u00f3calos en las carpetas correspondientes de tu proyecto.</p>"},{"location":"notebook/version_4.html#sec:fsm_simone_spec","title":"FSM Simone. Especificaci\u00f3n detallada","text":"<p>En esta ocasi\u00f3n no se proporciona la m\u00e1quina de estados, ni funciones, ni API. Se dar\u00e1 el detalle de la l\u00f3gica de control del juego y alg\u00fan detalle de implementaci\u00f3n m\u00e1s cr\u00edtico, as\u00ed como las restricciones a implementar.</p> <p>La l\u00f3gica del juego es m\u00e1s compleja que la de un simple perif\u00e9rico. El sistema debe ser capaz de generar secuencias aleatorias, reproducirlas respetando tiempos, esperar la entrada del usuario, validar dicha entrada en tiempo real y gestionar la victoria o la derrota. Para gobernar todo esto, utilizaremos una FSM central que orquestar\u00e1 el funcionamiento del juego.</p> <p>Objetivo</p> <p>El objetivo de esta versi\u00f3n es implementar la l\u00f3gica de control del juego en <code>fsm_simone.c</code> y <code>fsm_simone.h</code>. La parte dependiente del hardware (<code>PORT</code>) relacionada con la temporizaci\u00f3n del juego (<code>port_simone</code>) se os proporciona parcialmente implementada para facilitar la integraci\u00f3n.</p>"},{"location":"notebook/version_4.html#definicion-de-la-estructura-de-datos","title":"Definici\u00f3n de la estructura de datos","text":"<p>Antes de dibujar estados y transiciones, es fundamental entender qu\u00e9 datos necesita manejar nuestra m\u00e1quina para funcionar. La estructura de datos <code>fsm_simone_t</code> act\u00faa como la memoria del juego. Aparte de los punteros a las otras FSM (teclado, bot\u00f3n, luces), necesitamos variables para gestionar la secuencia. Compl\u00e9tala con los detalles que se indican a continuaci\u00f3n.</p> <p>Hay que tener cuidado de no confundir los diferentes \u00edndices que gestionan el progreso del juego. Observa los campos definidos en la estructura:</p> <ul> <li>FSMs de los elementos:</li> <li><code>f</code>: estructura base de la FSM de Simone de tipo sm_t` y que ha de ser el primer elemento de la estructura.</li> <li><code>p_fsm_button</code>: puntero a la FSM del bot\u00f3n de usuario.</li> <li><code>p_fsm_keyboard</code>: puntero a la FSM del teclado matricial.</li> <li> <p><code>p_fsm_rgb_light</code>: puntero a la FSM del LED RGB.</p> </li> <li> <p>Secuencia de datos:</p> </li> <li><code>seq_colors</code>: un array que almacena la lista de <code>`SEQUENCE_LENGTH</code> colores (<code>rgb_color_t</code>) de la secuencia actual.</li> <li><code>seq_intensities</code>: un array paralelo al anterior, tambi\u00e9n de longitud <code>SEQUENCE_LENGTH</code>, y que almacena la intensidad ([0-100]) de cada color como un entero.</li> <li> <p><code>level</code>: almacena como un entero el nivel de dificultad actual definido en un enumerado (f\u00e1cil, medio, dif\u00edcil).</p> </li> <li> <p>\u00cdndices de control (\u00a1Cuidado aqu\u00ed!):</p> </li> <li><code>seq_idx</code>: indica la longitud actual de la secuencia que se debe jugar. Si estamos en la ronda 3, este \u00edndice valdr\u00e1 3. Determina hasta d\u00f3nde tiene que llegar la m\u00e1quina reproduciendo y hasta d\u00f3nde tiene que llegar el jugador repitiendo.</li> <li><code>playback_idx</code>: es el \u00edndice de Simone. Recorre la secuencia del array de colores y de intensidades. Indica qu\u00e9 color de la secuencia se est\u00e1 mostrando actualmente por los LED.</li> <li> <p><code>player_idx</code>: es el \u00edndice del jugador. Recorre tambi\u00e9n la secuencia, pero para comparar si el valor pulsado por el usuario es correcto.</p> </li> <li> <p>Flags y otros campos:</p> </li> <li><code>player_key</code>: almacena el caracter de la tecla que acaba de pulsar el usuario para poder verificarla con la correspondiente del color que deber\u00eda haber pulsado el usuario</li> <li><code>playback_over</code>: es un booleano que usaremos para controlar el parpadeo de los LED (encendido/apagado) durante la reproducci\u00f3n de la secuencia de colores.</li> <li><code>level</code>: almacena el nivel de dificultad actual del juego como un entero. Albergar\u00e1 los valores del enumerado que contiene los niveles <code>LEVEL_EASY</code>, <code>LEVEL_MEDIUM</code> y <code>LEVEL_HARD</code>.</li> <li><code>on_off_press_time_ms</code>: entero que almacena el tiempo que el bot\u00f3n de usuario ha estado presionado (para gestionar el encendido y apagado del sistema).</li> </ul> <p>Completa la estructura y docum\u00e9ntala en <code>fsm_simone.h</code>.</p> <p>Consejo sobre los \u00edndices</p> <p>El juego consiste esencialmente en comparar \u00edndices.</p> <ol> <li>La m\u00e1quina Simone reproduce desde <code>0</code> hasta <code>seq_idx</code> usando su \u00edndice <code>playback_idx</code>.</li> <li>El jugador repite desde <code>0</code> hasta <code>seq_idx</code> usando su \u00edndice <code>player_idx</code>.</li> <li>Si <code>player_idx</code> alcanza a <code>seq_idx</code> es que todo han sido aciertos, por tanto \u00a1ronda superada! Se incrementa <code>seq_idx</code> y vuelta a empezar.</li> </ol> <p>Importante: Nombres de las constantes</p> <p>Para que vuestro c\u00f3digo pase los test autom\u00e1ticos de los profesores, deb\u00e9is respetar escrupulosamente los nombres de los <code>#define</code> de tiempos y teclas, as\u00ed como los nombres de los estados en el <code>enum FSM_SIMONE</code> definidos en el fichero de cabecera proporcionado.</p>"},{"location":"notebook/version_4.html#especificacion-de-la-maquina-de-estados","title":"Especificaci\u00f3n de la m\u00e1quina de estados","text":"<p>El juego consta de 7 estados: 5 de juego y 2 de gesti\u00f3n de bajo consumo. Mant\u00e9n los nombres proporcionados de los estados. Tienes que completar y documentar todas las funciones de la tabla de transiciones y funciones auxiliares faltantes, as\u00ed como la propia tabla de transiciones. Sigue los criterios que hemos usado en las tres versiones anteriores.</p> <p>La l\u00f3gica del juego se divide en los siguientes estados principales. Estudia detenidamente qu\u00e9 debe ocurrir en cada uno y, sobre todo, qu\u00e9 condiciones provocan las transiciones a los siguientes estados.</p>"},{"location":"notebook/version_4.html#sec:estado-idle","title":"Estado <code>IDLE</code>","text":"<p>Es el estado de reposo. El sistema est\u00e1 dormido esperando a que el usuario quiera jugar.</p> Entradas Salidas (1) al arrancar el sistema (1) Por encendido del usuario (2) Por victoria (desde <code>WAIT_KEY</code>) (2) Por inactividad (3) Por derrota (desde <code>WAIT_KEY</code>) (4) Por apagado del usuario (desde <code>WAIT_KEY</code>)"},{"location":"notebook/version_4.html#cond:simone_idle_on","title":"Transici\u00f3n (1): Por encendido del usuario","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_on()</code> debe detectar si el jugador ha pulsado el bot\u00f3n de usuario durante el tiempo definido en <code>main.c</code> (<code>SIMONE_ON_OFF_PRESS_TIME_MS</code>). Si esto sucede, pasar\u00e1 al estado <code>ADD_COLOR</code> para iniciar la partida.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_init_game()</code> inicializa las variables del juego. Debe resetear la duraci\u00f3n del bot\u00f3n de usuario, la tecla del teclado matricial, los \u00edndices de control (<code>seq_idx</code>, <code>playback_idx</code>, <code>player_idx</code>), y las variables <code>playback_over</code>, y <code>player_key</code> (esta \u00faltima al car\u00e1cter definido en <code>KEY_NO_KEY_PRESSED</code>).</p> <p>El nivel de dificultad lo inicializa a <code>LEVEL_EASY</code>. Inicializa cada elemento del array de secuencia de colores al color <code>color_off</code> (ver colores en <code>rgb_colors.c</code>), y cada elemento del array de las intensidades a <code>0</code>.</p> <p>Llama a una funci\u00f3n privada auxiliar (<code>_add_color()</code>) pas\u00e1ndole un puntero a la m\u00e1quina de estados de Simone para a\u00f1adir un color e intensidad aleatorios a la secuencia. Ser\u00e1 el primer color de la ronda 1.</p> <p>Para que el LED RGB muestre el color, esta funci\u00f3n debe activar el status de la FSM RGB light llamando a la funci\u00f3n apropiada de dicha FSM.</p> <p>Por \u00faltimo, antes de salir, imprime un mensaje de inicio al usuario. Algo como: <code> <code>printf(\"[SIMONE][%ld] Simone game INIT\\n\", port_system_get_millis());</code> </code></p> <p>Funci\u00f3n auxiliar <code>_add_color</code></p> <p>Esta funci\u00f3n privada que encapsula la generaci\u00f3n aleatoria recibe un puntero a la FSM de Simone y debe:</p> <ol> <li> <p>Generar un \u00edndice aleatorio para seleccionar un color del array <code>p_colors_library</code>. Este array debe colocarse al inicio de <code>fsm_simone.c</code> y contiene direcciones los 6 colores usados en el juego.</p> <pre><code>const rgb_color_t *p_colors_library[] = {&amp;color_red, &amp;color_green, &amp;color_blue, &amp;color_yellow, &amp;color_turquoise, &amp;color_white};\n</code></pre> <p>Para generar el \u00edndice aleatorio usa la funci\u00f3n <code>rand()</code> de la <code>&lt;stdlib.h&gt;</code>, y el operador m\u00f3dulo <code>%</code> para acotar el valor al rango <code>0</code> a <code>NUMBER_OF_COLORS_GAME</code>. El valor aleatorio se generar\u00e1 gracias a la semilla <code>srand()</code> iniciada en <code>fsm_simone_init()</code>.</p> </li> <li> <p>Generar una intensidad aleatoria respetando los rangos definidos para el nivel actual (usando los define <code>LEVEL_X_MIN_INTENSITY</code>).</p> <p>Como la funci\u00f3n <code>rand()</code> devuelve un valor entre <code>0</code> y <code>RAND_MAX</code>, puedes usar la siguiente f\u00f3rmula para acotar el valor al rango deseado:</p> <pre><code>random_num = (random_num % (max - min + 1)) + min;\n</code></pre> <p>Donde los valores m\u00e1ximos y m\u00ednimos dependen del nivel actual <code>level</code>.</p> </li> <li> <p>Si <code>seq_idx</code> ha alcanzado el valor <code>SEQUENCE_LENGTH</code>, reseteamos <code>seq_idx</code>. Si no, guardamos el color e intensidad generados en las posiciones <code>seq_idx</code> de los arrays <code>seq_colors</code> y <code>seq_intensities</code>, respectivamente, y luego incrementamos <code>seq_idx</code> en 1.</p> </li> </ol>"},{"location":"notebook/version_4.html#cond:simone_idle_no_activity","title":"Transici\u00f3n (2): Por inactividad","text":"<p>Si no hay actividad, el sistema puede dormirse pasando al estado <code>SLEEP_WHILE_IDLE</code>.</p> <p>La funci\u00f3n de comprobaci\u00f3n <code>check_no_activity()</code> devuelve directamente el valor inverso al de su contraria <code>check_activity()</code>. Esta \u00faltima, lo que hace es devolver <code>true</code> si alguna de las FSM de los elementos (bot\u00f3n, teclado, RGB light) est\u00e1 activa. Para ello, llama a las funciones de comprobaci\u00f3n de actividad que hemos implementado en la secci\u00f3n de bajo consumo (<code>fsm_xxx_check_activity()</code>).</p> <p>La funci\u00f3n de acci\u00f3n <code>do_sleep_idle()</code> debe poner el sistema en un estado de bajo consumo. Para ello llama a la funci\u00f3n de sleep del <code>PORT</code> del sistema que hemos implementado en la secci\u00f3n de bajo consumo.</p> <p>Aqu\u00ed tienes la especificaci\u00f3n para el estado <code>ADD_COLOR</code>, siguiendo el mismo formato, estilo y estructura que tu ejemplo de <code>IDLE</code>.</p>"},{"location":"notebook/version_4.html#sec:estado-add_color","title":"Estado <code>ADD_COLOR</code>","text":"<p>Este es un estado de transici\u00f3n. El sistema no se detiene aqu\u00ed esperando eventos externos, sino que realiza las operaciones l\u00f3gicas necesarias para preparar la secuencia de la siguiente ronda antes de reproducirla.</p> Entradas Salidas (1) Al iniciar partida (desde <code>IDLE</code>) (1) Secuencia actualizada (2) Al completar ronda (desde <code>WAIT_KEY</code>)"},{"location":"notebook/version_4.html#cond:simone_add_color_added","title":"Transici\u00f3n (1): Secuencia actualizada","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_color_added()</code> verifica si la longitud de la secuencia (<code>seq_idx</code>) es diferente del \u00edndice del jugador (<code>player_idx</code>). Como la la funci\u00f3n auxiliar <code>_add_color()</code> habr\u00e1 a\u00f1adido un nuevo color, esta condici\u00f3n se cumplir\u00e1 inmediatamente, permitiendo el paso al estado de reproducci\u00f3n de la secuencia <code>PLAYBACK</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_playback()</code> es el core de la reproducci\u00f3n. Su objetivo es gestionar el parpadeo de los LED respetando los tiempos de cada nivel. Dado que esta funci\u00f3n se llama repetidamente, utiliza la variable <code>playback_over</code> como un selector para alternar entre dos fases: mostrar color y pausa.</p> <p>Flujograma de implementaci\u00f3n:</p> <pre><code>flowchart TD\n    Start([do_playback]) --&gt; Guard{\"\u00bfsecuencia recorrida por completo?\"}\n\n    %% Guarda de seguridad\n    Guard -- \"&lt;code&gt;true&lt;/code&gt;\" --&gt; EndReturn([&lt;code&gt;return&lt;/code&gt;])\n\n    Guard -- &lt;code&gt;false&lt;/code&gt; --&gt; ResetHW[\"1. Reset flag timer Simone&lt;br/&gt;2. Stop escaneo del teclado\"]\n\n    ResetHW --&gt; CheckPhase{\"playback_over\"}\n\n    %% RAMA 1: MOSTRAR COLOR (playback_over == false)\n    CheckPhase -- \"&lt;code&gt;false&lt;/code&gt;\" --&gt; LedOn[\"1. Coger color e intensidad de los arrays.&lt;br/&gt;2. Llamar funci\u00f3n de la FSM del LED RGB para poner color e intensidad.\"]\n    LedOn --&gt; SetTimerOn[\"1. Seleccionar duraci\u00f3n de ON seg\u00fan nivel de dificultad&lt;br/&gt;2. Set timer de Simone con  duraci\u00f3n.\"]\n    SetTimerOn --&gt; UpdateFlagOn[\"&lt;code&gt;playback_over = true&lt;/code&gt;\"]\n    UpdateFlagOn --&gt; EndFunc([&lt;code&gt;return&lt;/code&gt;])\n\n    %% RAMA 2: PAUSA / GAP (playback_over == true)\n    CheckPhase -- \"&lt;code&gt;true&lt;/code&gt;\" --&gt; LedOff[\"Llamar funci\u00f3n de la FSM del LED RGB para poner color &lt;code&gt;color_off&lt;/code&gt;.\"]\n    LedOff --&gt; IncIdx[\"Set timer de Simone con duraci\u00f3n de pausa entre colores.\"]\n    IncIdx --&gt; UpdateFlagOff[\"1. &lt;code&gt;playback_idx++&lt;/code&gt;&lt;br/&gt;2. &lt;code&gt;playback_over=false&lt;/code&gt;\"]\n\n    %% Comprobaci\u00f3n de fin de secuencia\n    UpdateFlagOff --&gt; CheckEnd{\"&lt;code&gt;playback_idx&gt;=seq_idx&lt;/code&gt;\"}\n    CheckEnd -- \"&lt;code&gt;true&lt;/code&gt;\" --&gt; SetMarker[\"Marcar fin de playback\"]\n    CheckEnd -- \"&lt;code&gt;false&lt;/code&gt;\" --&gt; EndFunc\n    SetMarker --&gt; EndFunc\n\n    %% Estilos para facilitar lectura\n    style Start fill:#f9f,stroke:#333,stroke-width:2px\n    style EndReturn fill:#faa,stroke:#333\n    style EndFunc fill:#ccf,stroke:#333\n    style CheckPhase fill:#ffd,stroke:#333,stroke-width:2px</code></pre> <p>Aunque el diagrama resume el flujo l\u00f3gico, la implementaci\u00f3n correcta de <code>do_playback()</code> requiere prestar atenci\u00f3n a varios detalles t\u00e9cnicos para mantener la estabilidad del sistema:</p> <ol> <li>La naturaleza no bloqueante del temporizador: Cuando el diagrama indica \"Set timer de Simone\", debes llamar a <code>port_simone_set_timer_timeout()</code>. Hay que entender que esta funci\u00f3n no detiene la ejecuci\u00f3n del c\u00f3digo (no es un <code>delay</code>), sino que  programa una interrupci\u00f3n futura. El microcontrolador se dormir\u00e1 en el estado <code>SLEEP_WHILE_PLAYBACK</code> hasta que ese tiempo expire, interrumpa y vuelva a comprobarse la tabla de transiciones.</li> <li>Protecci\u00f3n contra entradas espurias: Una de las primeras acciones es detener el escaneo del teclado. Si no se hace, el usuario podr\u00eda pulsar teclas mientras se muestran las luces; esas pulsaciones se quedar\u00edan guardadas en el struct HW del teclado y se procesar\u00edan err\u00f3neamente en cuanto el juego pasara al estado de espera, provocando que se detecte como una tecla mal pulsada al inicio de la ronda siguiente.</li> <li>Acceso a la memoria de la secuencia: En la fase de encendido, debes recuperar la informaci\u00f3n almacenada previamente. Usa la variable <code>playback_idx</code> para acceder a los arrays paralelos <code>seq_colors</code> y <code>seq_intensities</code>. Recuerda que la funci\u00f3n de encendido del LED (<code>fsm_rgb_light_set_color_intensity</code>) requiere ambos par\u00e1metros.</li> <li>Sincronizaci\u00f3n de \u00edndices: F\u00edjate bien en la comparaci\u00f3n final. Comparamos <code>playback_idx</code> (lo que estamos mostrando ahora) con <code>seq_idx</code> (la longitud total de la secuencia actual).<ul> <li>Si <code>seq_idx</code> es 3, significa que hay colores en las posiciones 0, 1 y 2.</li> <li>Cuando terminamos de mostrar el color 2 y su pausa, incrementamos <code>playback_idx</code> a 3.</li> <li>Como 3 es mayor o igual que 3, sabemos que hemos terminado.</li> </ul> </li> </ol> <p>El marcador de fin de playback</p> <p>Para marcar el final de playback y poder comprobar al inicio si ha acabado o no, podemos usar varios mecanismos. Puedes usar, por ejemplo, una variable global, o puedes usar un valor inv\u00e1lido (que nunca vaya a ocurrir en el \u00edndice <code>playback_idx</code>). Cualquiera que uses, ten en cuenta que este marcador ser\u00e1 la forma de comunicar  a la funci\u00f3n de comprobaci\u00f3n <code>check_playback_over()</code> que la tarea de reproducci\u00f3n ha concluido.</p>"},{"location":"notebook/version_4.html#sec:estado-playback","title":"Estado <code>PLAYBACK</code>","text":"<p>En este estado el sistema ha tomado el control para mostrar la secuencia de colores al jugador como se ha mostrado en el flujograma de <code>do_playback</code>.</p> Entradas Salidas (1) Desde <code>ADD_COLOR</code> (1) Apagado manual (2) Desde <code>SLEEP_WHILE_PLAYBACK</code> (2) Turno del jugador (3) Por inactividad"},{"location":"notebook/version_4.html#cond:simone_playback_off","title":"Transici\u00f3n (1): Apagado manual","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_off()</code> verifica si el bot\u00f3n de la placa se ha mantenido pulsado el tiempo suficiente. Es id\u00e9ntica a la funci\u00f3n <code>check_on()</code>. Si se cumple, el sistema debe volver al estado de reposo <code>IDLE</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_stop_simone()</code>: resetea la duraci\u00f3n del bot\u00f3n de usuario, desactiva el estado del LED, resetea el nivel de dificultad a <code>LEVEL_EASY</code>, e imprime un mensaje de despedida indicando que el juego ha terminado y que puede presionar el bot\u00f3n para iniciar una nueva partida.</p>"},{"location":"notebook/version_4.html#cond:simone_playback_over","title":"Transici\u00f3n (2): Turno del jugador","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_playback_over()</code> determina si la m\u00e1quina ha terminado de reproducir toda la secuencia y, adem\u00e1s, ha terminado el tiempo de espera del \u00faltimo apagado. Debe devolver <code>true</code> solo si se cumplen dos condiciones simult\u00e1neamente:</p> <ol> <li>El marcador de fin de reproducci\u00f3n est\u00e1 activado (establecido en <code>do_playback()</code>).</li> <li>El temporizador ha expirado (<code>port_simone_get_timeout_status()</code>).</li> </ol> <p>La funci\u00f3n de acci\u00f3n <code>do_start_player_sequence()</code> prepara el sistema para escuchar al usuario. La funci\u00f3n debe:</p> <ol> <li>Reiniciar flag <code>playback_over</code> y reiniciar el \u00edndice del jugador <code>player_idx</code> para empezar a comprobar desde el principio.</li> <li>Apagar LED con el color <code>color_off</code> llamando a la funci\u00f3n correspondiente de la FSM del LED.</li> <li>Set timeout del temporizador con el tiempo m\u00e1ximo que tiene el usuario para reaccionar (<code>SIMONE_TIME_WAIT_INPUT_MS</code>).</li> <li>Iniciar el escaneo del teclado llamando a la funci\u00f3n correspondiente de la FSM del teclado, ya que se desactiv\u00f3 durante la reproducci\u00f3n.</li> <li>Imprimir un mensaje por consola informando al usuario de que es su turno y cu\u00e1ntos segundos tiene para responder entre pulsaciones.</li> </ol>"},{"location":"notebook/version_4.html#cond:simone_playback_no_activity","title":"Transici\u00f3n (3): Por inactividad","text":"<p>Si no ha expirado el temporizador mientras mostramos un color o una pausa, el sistema puede dormirse para ahorrar energ\u00eda.</p> <p>La funci\u00f3n de comprobaci\u00f3n <code>check_no_activity()</code> devuelve el valor inverso al de su contraria <code>check_activity()</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_sleep_playback()</code> debe poner el sistema en un estado de bajo consumo. Para ello llama a la funci\u00f3n de sleep del <code>PORT</code> del sistema que hemos implementado en la secci\u00f3n de bajo consumo.</p>"},{"location":"notebook/version_4.html#sec:estado-wait_key","title":"Estado <code>WAIT_KEY</code>","text":"<p>Es el turno del jugador. El sistema espera cualquier reacci\u00f3n por parte del usuario, ya sea para apagar el juego, introducir una tecla de la secuencia, o porque se ha agotado el tiempo.</p> Entradas Salidas (1) Desde <code>PLAYBACK</code> (1) Apagado manual (2) Desde <code>VERIFY_INPUT</code> (2) Victoria final (3) Derrota por tiempo (4) Fin de ronda (5) Pulsaci\u00f3n de una tecla"},{"location":"notebook/version_4.html#cond:simone_wait_key_off","title":"Transici\u00f3n (1): Apagado manual","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_off()</code> verifica si el bot\u00f3n de la placa se ha mantenido pulsado el tiempo suficiente. Es id\u00e9ntica a la funci\u00f3n <code>check_on()</code>. Si se cumple, el sistema debe volver al estado de reposo <code>IDLE</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_stop_simone()</code>: resetea la duraci\u00f3n del bot\u00f3n de usuario, desactiva el estado del LED, resetea el nivel de dificultad a <code>LEVEL_EASY</code>, e imprime un mensaje de despedida indicando que el juego ha terminado y que puede presionar el bot\u00f3n para iniciar una nueva partida.</p>"},{"location":"notebook/version_4.html#cond:simone_wait_key_winner","title":"Transici\u00f3n (2): Victoria final","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_winner()</code> es la m\u00e1s estricta. Deben cumplirse 3 condiciones: se cumple solo si (1) el jugador ha terminado la secuencia (debes jugar con los \u00edndices del jugador y la secuencia), (2) el \u00edndice que recorre el array de la secuencia ha llegado o superado la longitud m\u00e1xima (<code>SEQUENCE_LENGTH</code>) y, adem\u00e1s, (3) estamos en el nivel <code>level</code> de dificultad m\u00e1s alto (<code>LEVEL_HARD</code>).</p> <p>Si se cumplen estas 3 condiciones, el jugador ha ganado la partida y pasa al estado de reposo <code>IDLE</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_winner()</code> detiene el temporizador (<code>port_simone_stop_timer()</code>), y muestra un mensaje de felicitaci\u00f3n por consola indicando cu\u00e1ntos colores ha conseguido recordar el jugador.</p>"},{"location":"notebook/version_4.html#cond:simone_wait_key_timeout","title":"Transici\u00f3n (3): Derrota por tiempo","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_player_key_timeout()</code> verifica si el temporizador de espera de usuario ha expirado (<code>port_simone_get_timeout_status()</code>). Si el jugador tarda demasiado en pensar (<code>SIMONE_TIME_WAIT_INPUT_MS</code>), la condici\u00f3n se cumple y pasa al estado de reposo <code>IDLE</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_game_over_timeout()</code> gestiona el fin de la partida por tiempo. Detiene el temporizador (<code>port_simone_stop_timer()</code>), reinicia todos los \u00edndices y elementos de la estructura de Simone (<code>seq_idx</code>, <code>player_idx</code>, etc.), detiene el escaneo del teclado antes de volver al reposo. Por \u00faltimo imprime un mensaje de Game Over, indicando alguna estad\u00edstica relevante (por ejemplo, cu\u00e1ntos colores ha conseguido recordar el jugador).</p>"},{"location":"notebook/version_4.html#cond:simone_wait_key_round_end","title":"Transici\u00f3n (4): Fin de ronda","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_player_round_end()</code> verifica si (1) el jugador ha reproducido con \u00e9xito toda la secuencia actual (comparando los \u00edndices <code>player_idx</code> y <code>seq_idx</code>), pero (2) a\u00fan no ha cumplido las condiciones de victoria total; esto es, no ha alcanzado la longitud m\u00e1xima de la secuencia o no est\u00e1 en el nivel m\u00e1s alto.</p> <p>Si se cumplen estas dos condiciones, el jugador ha superado la ronda y pasa al estado <code>ADD_COLOR</code> para preparar la siguiente ronda.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_add_color()</code> prepara el sistema para el siguiente nivel o secuencia. Puedes ver su l\u00f3gica detallada en el flujograma.</p> <p>Flujograma de implementaci\u00f3n:</p> <pre><code>flowchart TD\n    Start([do_add_color]) --&gt; ResetVars[\"Reset de &lt;code&gt;player_idx&lt;/code&gt;, &lt;code&gt;playback_idx&lt;/code&gt; y &lt;code&gt;playback_over&lt;/code&gt;\"]\n\n    ResetVars --&gt; CheckLevelUp{\"Array lleno &amp; nivel &lt; HARD\"}\n\n    %% RAMA 1: SUBIR NIVEL\n    CheckLevelUp -- \"&lt;code&gt;true&lt;/code&gt;\" --&gt; LevelUp[\"1. Subir nivel&lt;br/&gt;2. Reiniciar &lt;code&gt;seq_idx&lt;/code&gt;&lt;br/&gt;3. Imprimir mensaje de aviso\"]\n    LevelUp --&gt; AddSeq\n\n    %% RAMA 2: MANTENER NIVEL\n    CheckLevelUp -- \"&lt;code&gt;false&lt;/code&gt;\" --&gt; AddSeq[\"Llamar a &lt;code&gt;_add_sequence(p_fsm)&lt;/code&gt;\"]\n\n    AddSeq --&gt; EndFunc([&lt;code&gt;return&lt;/code&gt;])\n\n    %% Estilos de formato\n    style Start fill:#f9f,stroke:#333,stroke-width:2px\n    style EndFunc fill:#ccf,stroke:#333\n    style CheckLevelUp fill:#ffd,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"notebook/version_4.html#cond:simone_wait_any_key","title":"Transici\u00f3n (5): Pulsaci\u00f3n de una tecla","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_any_key_pressed()</code> utiliza el driver del teclado para detectar si hay alguna tecla disponible en el buffer. Devuelve <code>true</code> si el usuario ha pulsado algo (valor de tecla le\u00edda es distinto de <code>KEY_NO_KEY_PRESSED</code>). En tal caso, el sistema transiciona al estado intermedio <code>VERIFY_INPUT</code> para validar la pulsaci\u00f3n.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_capture_input()</code> realiza de nuevo la lectura de la tecla pulsada y proporciona feedback visual inmediato al usuario del color de la tecla que haya pulsado (sea correcta, o no). Debe:</p> <ol> <li>Obtiene la tecla del teclado y la guarda en la variable <code>player_key</code>. Luego, resetea el valor de la tecla del teclado para evitar lecturas repetidas usando la funci\u00f3n correspondiente de la FSM del teclado.</li> <li>Traduce la tecla a color usando la funci\u00f3n auxiliar <code>_get_color_from_key()</code>, y enciende el LED al m\u00e1ximo brillo con el color resultante.</li> <li>Pone el temporizador de Simone con un tiempo breve de feedback visual (definido en <code>SIMONE_TIME_VISUAL_FEEDBACK_MS</code>).</li> </ol>"},{"location":"notebook/version_4.html#sec:estado-verify_input","title":"Estado <code>VERIFY_INPUT</code>","text":"<p>Este es un estado temporal de retenci\u00f3n. El sistema entra aqu\u00ed justo despu\u00e9s de que el usuario pulse una tecla para mantener el LED encendido durante un breve instante (<code>SIMONE_TIME_VISUAL_FEEDBACK_MS</code>), permitiendo al jugador ver qu\u00e9 color ha seleccionado. En este estado se comprueba si la tecla le\u00edda es la esperada, o no.</p> Entradas Salidas (1) Desde <code>WAIT_KEY</code> (1) Tecla correcta (2) Tecla incorrecta"},{"location":"notebook/version_4.html#cond:simone_verify_valid","title":"Transici\u00f3n (1): Tecla correcta","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_input_valid()</code> realiza una validaci\u00f3n en dos pasos:</p> <ol> <li>Espera visual: Primero verifica si el temporizador de feedback visual ha expirado (<code>!port_simone_get_timeout_status()</code>). Si el tiempo no ha pasado, devuelve <code>false</code> y sale de la funci\u00f3n.</li> <li>Validaci\u00f3n l\u00f3gica: Si el tiempo ha pasado, compara la tecla pulsada guardada en la estructura con la esperada seg\u00fan la secuencia (ay\u00fadate de la funci\u00f3n auxiliar <code>_get_key_from_color()</code>). Devuelve <code>true</code> solo si coinciden. En este caso transicionar\u00e1 de vuelta al estado <code>WAIT_KEY</code> para esperar la siguiente pulsaci\u00f3n.</li> </ol> <p>La funci\u00f3n de acci\u00f3n <code>do_valid_key()</code> consolida el progreso del jugador. Debe:</p> <ol> <li>Apagar el LED con el color <code>color_off</code>.</li> <li>Aumentar el \u00edndice del jugador.</li> <li>Reiniciar la tecla guardada en la estructura a <code>KEY_NO_KEY_PRESSED</code>.</li> <li>Reiniciar el temporizador (<code>port_simone_set_timer_timeout()</code>) para dar tiempo al usuario a pulsar la siguiente tecla.</li> </ol>"},{"location":"notebook/version_4.html#cond:simone_verify_invalid","title":"Transici\u00f3n (2): Tecla incorrecta","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_input_invalid_finished()</code> sigue la misma l\u00f3gica temporal que la anterior, pero devuelve <code>true</code> si la tecla pulsada es diferente a la esperada.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_game_over_invalid_key()</code> gestiona la derrota:</p> <ol> <li>Apaga el LED para finalizar el feedback.</li> <li>Reinicia todos los elementos de la estructura de Simone (<code>seq_idx</code>, <code>player_idx</code>, <code>player_key</code>, etc.) para que la pr\u00f3xima vez se empiece desde cero.</li> <li>Reiniciar el temporizador de Simone (<code>port_simone_stop_timer()</code>) y detiene el escaneo* del teclado usando la funci\u00f3n correspondiente de la FSM del teclado.</li> <li>Muestra por consola informaci\u00f3n sobre qu\u00e9 tecla se esperaba y cu\u00e1l se puls\u00f3 realmente, junto con un mensaje de Game Over. Hace uso de la funci\u00f3n auxiliar <code>_get_key_from_color()</code>.</li> </ol>"},{"location":"notebook/version_4.html#sec:estado-sleep_while_idle","title":"Estado <code>SLEEP_WHILE_IDLE</code>","text":"<p>Es el estado de bajo consumo. El sistema entra aqu\u00ed cuando est\u00e1 en reposo (<code>IDLE</code>) y no hay ninguna interacci\u00f3n por parte del usuario, permitiendo ahorrar energ\u00eda mientras se espera a que se inicie una nueva partida.</p> Entradas Salidas (1) Desde <code>IDLE</code> (1) Detecci\u00f3n de actividad (2) Desde <code>SLEEP_WHILE_IDLE</code> (autotransici\u00f3n) (2) Sin actividad"},{"location":"notebook/version_4.html#cond:simone_sleep_idle_wake","title":"Transici\u00f3n (1): Detecci\u00f3n de actividad","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_activity()</code> verifica si alg\u00fan perif\u00e9rico ha generado un evento (bot\u00f3n pulsado, tecla pulsada, etc.). Al despertar por una interrupci\u00f3n, esta condici\u00f3n se cumple y el sistema transiciona de vuelta a <code>IDLE</code> para procesar dicho evento.</p> <p>En esta transici\u00f3n no hay funci\u00f3n de acci\u00f3n asociada (es <code>NULL</code>), ya que la propia salida del estado de sue\u00f1o es suficiente para reactivar la l\u00f3gica principal.</p>"},{"location":"notebook/version_4.html#cond:simone_sleep_idle_sleep","title":"Transici\u00f3n (2): Sin actividad","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_no_activity()</code> confirma que el sistema sigue inactivo. Esta autotransici\u00f3n sirve para gestionar el bajo consumo en modo depuraci\u00f3n, cuando se despierta por un breakpoint o similar.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_sleep_idle()</code> detendr\u00e1 el reloj de la CPU  hasta que ocurra la pr\u00f3xima interrupci\u00f3n.</p>"},{"location":"notebook/version_4.html#sec:estado-sleep_while_playback","title":"Estado <code>SLEEP_WHILE_PLAYBACK</code>","text":"<p>Este estado gestiona el bajo consumo durante la reproducci\u00f3n. Mientras el LED est\u00e1 encendido mostrando un color o apagado durante una pausa, no es necesario que la CPU est\u00e9 consumiendo ciclos. El sistema duerme aqu\u00ed hasta que el temporizador interrumpe.</p> Entradas Salidas (1) Desde <code>PLAYBACK</code> (1) Timeout del color/pausa (2) Desde <code>SLEEP_WHILE_PLAYBACK</code> (autotransici\u00f3n) (2) Sin actividad"},{"location":"notebook/version_4.html#cond:simone_sleep_playback_timeout","title":"Transici\u00f3n (1): Timeout del color/pausa","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_playback_color_timeout()</code> consulta al si el temporizador (<code>port_simone_get_timeout_status()</code>) configurado en el paso anterior ha expirado. Si es as\u00ed, significa que es hora de cambiar el estado del LED.</p> <p>La funci\u00f3n de acci\u00f3n asociada es <code>do_playback()</code>. Esta transici\u00f3n devuelve al sistema al estado <code>PLAYBACK</code>, ejecutando inmediatamente la l\u00f3gica de alternancia de luces (encender/apagar) descrita en el flujograma de dicho estado.</p> <p>Funcionamiento c\u00edclico</p> <p>Observa que el sistema entra y sale constantemente entre <code>PLAYBACK</code> y <code>SLEEP_WHILE_PLAYBACK</code>.</p> <ol> <li><code>PLAYBACK</code> configura el LED y el temporizador, y salta a dormir.</li> <li>Espera dormido en bajo consumo.</li> <li>Timer interrumpe y vuelve a <code>PLAYBACK</code> para cambiar el LED, y puede volver a dormir de nuevo.</li> </ol>"},{"location":"notebook/version_4.html#cond:simone_sleep_playback_sleep","title":"Transici\u00f3n (2): Sin actividad","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_no_activity()</code> verifica que no hay eventos pendientes.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_sleep_playback()</code> detendr\u00e1 el reloj de la CPU  hasta que ocurra la pr\u00f3xima interrupci\u00f3n de la misma forma que lo hace <code>do_sleep_idle()</code>, o <code>do_sleep_playback()</code>.</p> <p>Funciones de bajo consumo</p> <p>Habr\u00e1s notado que hay 3 funciones que hacen lo mismo: <code>do_sleep_idle()</code>, <code>do_sleep_playback()</code> y <code>do_sleep_playback()</code>. Esto es una buena pr\u00e1ctica para poder saber d\u00f3nde est\u00e1 y de d\u00f3nde viene el sistema cuando se est\u00e1 depurando.</p> <p>Bajo consumo durante la lectura del teclado</p> <p>N\u00f3tese que no hay bajo consumo en el estado <code>WAIT_KEY</code>. Esto es intencionado, ya que el jugador debe poder interactuar en cualquier momento. Por la forma en la que se excitan y leen las filas y columnas, la gesti\u00f3n del bajo consumo aqu\u00ed es posible, pero m\u00e1s complicada de manejar. Se deja como implementaci\u00f3n a elegir en la Versi\u00f3n 5.</p>"},{"location":"notebook/version_4.html#sec:v4_fsm_simone_init","title":"Inicializaci\u00f3n de la FSM Simone","text":"<p>Ya hemos codificado las funciones de entrada y salida, ahora vamos a codificar las funciones privadas que nos quedan.</p> <p>Codifica la funci\u00f3n <code>fsm_simone_init()</code> de forma an\u00e1loga a las anteriores m\u00e1quinas de estados. </p> <ol> <li>Llama a la funci\u00f3n <code>fsm_init()</code> pas\u00e1ndole el puntero a la m\u00e1quina de estados, y el array de transiciones.</li> <li>Inicializa el HW asociado a la FSM de Simone llamando a <code>port_simone_init()</code>.</li> <li>Inicializa en la estructura todos los elementos que ser reciben: los punteros a las m\u00e1quinas de estados de los elementos del sistema Simone, el tiempo de pulsaci\u00f3n del bot\u00f3n para encender y apagar, y el nivel inicial. </li> <li>Inicializa la semilla aleatoria con la funci\u00f3n <code>srand(time(NULL))</code> para asegurar que los n\u00fameros aleatorios generados sean diferentes en cada ejecuci\u00f3n. Deber\u00e1s importar la cabecera <code>&lt;time.h&gt;</code> para usar la funci\u00f3n <code>time()</code>.</li> <li>Imprime un mensaje por consola indicando al usuario que debe pulsar el bot\u00f3n para iniciar una nueva partida.</li> </ol> <p>Codifica las funciones <code>fsm_simone_fire()</code> y <code>fsm_simone_destroy()</code> de forma an\u00e1loga a las anteriores m\u00e1quinas de estados.</p> <p>Ya hemos terminado con al FSM, ahora vamos a integrar todas las FSM en el <code>main.c</code> y a probarlo.</p>"},{"location":"notebook/version_4.html#sec:v4_integration","title":"Integraci\u00f3n HW-SW de la FSM Simone","text":"<p>Ha llegado la hora de integrar la parte HW-SW del sistema, y depurar. Vamos a escribir las l\u00edneas de c\u00f3digo necesarias en <code>main.c</code> para probar que funciona. Procedamos:</p> <ol> <li> <p>Abre el fichero <code>main.c</code> e incluye las cabeceras necesarias.</p> </li> <li> <p>Define la macro <code>SIMONE_ON_OFF_PRESS_TIME_MS</code> como indica la API para definir una pulsaci\u00f3n larga como aquella que supere \\(1 s\\). \u00a1Ojo, porque el tiempo hay que darlo en milisegundos! Este es el tiempo que se debe mantener pulsado el bot\u00f3n para encender y apagar el juego.</p> </li> <li> <p>Despu\u00e9s de la inicializaci\u00f3n del sistema con la llamada a la funci\u00f3n <code>port_system_init()</code>, crea la m\u00e1quina de estados para el bot\u00f3n. Dale un nombre representativo (*e.g.*, <code>p_fsm_button</code>). Para ello llama a la funci\u00f3n <code>fsm_button_new()</code> con los argumentos necesarios. A continuaci\u00f3n, haz lo propio con la m\u00e1quina de estados del teclado matricial, y con la del RGB light trasero. Dales nombres representativos.</p> </li> <li> <p>Crea la m\u00e1quina de estados para el sistema Simone, puedes darle un nombre representativo (*e.g.*, <code>p_fsm_simone</code>). \u00a1No pases los valores \u201ca pincho\u201d, usa los <code>#define</code> que has creado!</p> </li> <li> <p>En el bucle <code>while</code>, lanza constantemente la funci\u00f3n <code>fsm_xxx_fire()</code>, para las m\u00e1quinas de estados del bot\u00f3n, el teclado, el RGB light y Simone.</p> <p>Conviene que el sistema sea lo \u00faltimo porque depende de la actualizaci\u00f3n del estado de las FSM de los elementos anteriores.</p> </li> <li> <p>Por \u00faltimo solo nos queda un aspecto meramente formal, casi acad\u00e9mico. Cuando creamos las m\u00e1quinas de estado con las funciones <code>fsm_xxx_new()</code> estamos reservando memoria de forma din\u00e1mica (con la funci\u00f3n <code>malloc()</code>). Cuando las m\u00e1quinas de estado dejan de usarse, esa memoria debe ser liberada para poder ser usada por otras partes del c\u00f3digo. Esa liberaci\u00f3n se har\u00e1 con la llamada a la funci\u00f3n <code>fsm_destroy()</code>.</p> <p>Despu\u00e9s del bucle <code>while</code> llama a <code>fsm_xxx_destroy()</code> para cada una de las FSM pas\u00e1ndole su tipo concreto. Esto libera la memoria de cada una de las m\u00e1quinas de estado creadas: bot\u00f3n, teclado matricial, RGB light, y Simone.</p> <p>Como se dec\u00eda, esto es pura ortodoxia, porque el bucle <code>while</code> del <code>main</code> es infinito, y nunca saldr\u00e1 de ah\u00ed, por lo que nuestras FSM nunca dejar\u00e1n de usarse y las l\u00edneas que acabas de escribir con <code>fsm_xxx_destroy()</code> nunca se ejecutar\u00e1n. No obstante, conviene que sepas que as\u00ed deber\u00eda hacerse.</p> </li> <li> <p>Compila y comprueba que no tiene ning\u00fan error. Si tienes, corr\u00edgelos.</p> </li> </ol> <p>Puede ser buen momento ahora para documentar todo el c\u00f3digo con Doxygen.</p>"},{"location":"notebook/version_4.html#test-de-integracion-de-simone","title":"Test de integraci\u00f3n de Simone","text":""},{"location":"notebook/version_4.html#test-de-funcionalidades","title":"Test de funcionalidades","text":"<p>Ya has probado los test de ejemplo de los distintos elementos y que se os han sido proporcionado. Ahora vamos a probar el sistema Simone completo. No se os va a pedir hacer un test formal, pero con todo el trabajo que has hecho, es conveniente que compruebes que todo funciona correctamente. Monta el circuito como se muestra en la . Prueba todo el sistema como en el v\u00eddeo demostraci\u00f3n Simone. Procedamos:</p> Montaje final con el teclado, el bot\u00f3n y el LED RGB. <ol> <li> <p>Conecta la placa Nucleo-STM32\u00a0al ordenador.</p> </li> <li> <p>Compila y carga el programa <code>main</code> en la placa ( <code>Clean and Debug</code>). Comprueba que no tienes errores de compilaci\u00f3n.</p> </li> <li> <p>Prueba que el bot\u00f3n enciende y apaga el juego Simone.</p> </li> <li> <p>Prueba que el RGB light se enciende de manera acorde en la primera ronda y enciende un color y mostrando los mensajes por la terminal oportuna</p> </li> <li> <p>Prueba que el teclado recoge correctamente las teclas, tanto cuando aciertos, como cuando fallas.</p> </li> <li> <p>Prueba que el nivel de dificultad sube correctamente cada vez que se completa una secuencia de longitud <code>SEQUENCE_LENGTH</code>, hasta un m\u00e1ximo de 3 niveles.</p> </li> <li> <p>Prueba que mientras est\u00e1 haciendo el playback no responde al teclado.</p> </li> <li> <p>Prueba que puedes apagarlo y encenderlo en cualquier momento.</p> </li> <li> <p>Prueba que, estando apagada, el juego Simone no responde al teclado ni muestra nada por el LED RGB.</p> </li> <li> <p>Prueba, en general, el funcionamiento correcto como en el v\u00eddeo de demostraci\u00f3n. Si encuentras alg\u00fan error, corr\u00edgelo.</p> </li> </ol>"},{"location":"notebook/version_4.html#comprobaci\u00f3n-de-bajo-consumo","title":"Comprobaci\u00f3n de bajo consumo","text":"<p>Comprobaremos que el modo sleep de bajo consumo se gestiona correctamente. Compila y comprueba que no tienes errores de sintaxis o de c\u00f3digo. Para comprobar que el sistema est\u00e1 dormido, podemos hacerlo de dos formas:</p> <ol> <li> <p>Lo m\u00e1s habitual \u2014si no tenemos acceso a un depurador y si tenemos que caracterizar nuestro producto\u2014 ser\u00eda hacerlo mediante la medici\u00f3n del consumo del microcontrolador (\u00a1no de los elementos HW de nuestro sistema!). Para medir el consumo, ve el punto \u201c6.6 JP6 (IDD)\u201d del manual de la placa\u00a0<sup>2</sup>. Si vas a medirlo, tambi\u00e9n deber\u00edas desconectar los jumpers del <code>ST-LINK</code> del conector <code>CN2</code>. Para ver el ahorro tendr\u00edamos que medirlo en ejecuci\u00f3n sobre versi\u00f3n final. Esto puedes hacerlo si deseas como funcionalidad extra en la Versi\u00f3n 5, e incluir la informaci\u00f3n en la documentaci\u00f3n del c\u00f3digo (fichero <code>README.md</code>).</p> </li> <li> <p>Lo que haremos para demostrar que el sistema alterna entre el modo despierto y dormido ser\u00e1 depurando. Contin\u00faa con la depuraci\u00f3n sin poner puntos de parada. Cuando el sistema est\u00e9 inactivo, pausa la depuraci\u00f3n y comprueba que se ha detenido en la l\u00ednea de c\u00f3digo tras la llamada a wait for interrupt (<code>__WFI()</code>), similar a como se muestra en la . Esto querr\u00e1 decir que, efectivamente, la ejecuci\u00f3n estaba detenida esperando una interrupci\u00f3n, se ha despertado, y ha pasado a la siguiente l\u00ednea de c\u00f3digo.</p> </li> </ol> Restauraci\u00f3n del modo despierto vista en depuraci\u00f3n. <p>Realiza con con Paint, Drawio, o cualquier programa que elijas el diagrama de la FSM del sistema con todas sus transiciones. A\u00f1\u00e1dela a tu <code>README.md</code>.</p> <p>\u00a1Ya tenemos el sistema Simone funcionando! No olvides documentarlo (v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d). En la siguiente versi\u00f3n podr\u00e1s a\u00f1adir m\u00e1s funcionalidades a tu elecci\u00f3n. Puedes incluir m\u00e1s capturas o im\u00e1genes para enriquecer la documentaci\u00f3n.</p> <p>Guarda una copia de su proyecto como <code>simone_v4</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla. Esta copia s\u00fabela al buz\u00f3n de entrega de la asignatura separada de la que hagas con la versi\u00f3n 5, que tiene otro buz\u00f3n. \u00a1\u00c1nimo!</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Um1724 user manual. stm32 nucleo-64 boards. Technical Report, STMicroelectronics, 2020. URL: https://www.st.com/resource/en/user_manual/um1724-stm32-nucleo64-boards-mb1136-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_4_old.html","title":"Versi\u00f3n 4: modos de bajo consumo e integraci\u00f3n final","text":"<p>Bibliograf\u00eda</p> <ol> <li> <p>\"Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>1</sup></p> </li> <li> <p>User Manual \"UM1724. STM32 Nucleo-64 boards.\u201d <sup>2</sup></p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Demostraci\u00f3n Simone</p> </li> <li> <p>\"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d</p> </li> </ul>"},{"location":"notebook/version_4_old.html#modos-de-bajo-consumo","title":"Modos de bajo consumo","text":"<p>Ya tenemos todos los elementos del sistema para que sea funcional. Quiz\u00e1s quisi\u00e9ramos \u2014si se hace el dise\u00f1o correspondiente\u2014 dise\u00f1ar una PCB para desplegarlo en alg\u00fan sitio. Si hici\u00e9semos esto, muy seguramente alimentar\u00edamos el dispositivo con una bater\u00eda. Si midi\u00e9semos el consumo con un amper\u00edmetro, podr\u00edamos calcular la autonom\u00eda de nuestro sistema. Se habr\u00e1 fijado que en los dispositivos comerciales como relojes inteligentes, mandos de TV, dispositivos IoT\u2026la autonom\u00eda puede superar de largo varios meses con un uso normal del mismo. Para conseguir esto contamos con los modos de bajo consumo. Buena parte de los microcontroladores que hoy en d\u00eda se precien cuentan con distintos modos de bajo consumo. Lea la secci\u00f3n \"Modos de bajo consumo\u201d del libro de Fundamentos Te\u00f3ricos\u00a0<sup>1</sup>.</p> <p>En esta versi\u00f3n, antes de hacer la integraci\u00f3n final, vamos a implementar unas pocas funciones para gestionar el modo sleep de bajo consumo en nuestro sistema. Esto se destaca en 2 estados de la FSM de Simone que veremos m\u00e1s adelante y que se muestran en la : <code>SLEEP_WHILE_ON</code>, y <code>SLEEP_WHILE_OFF</code>. Estos estados comprueban si alguna de las FSM de los elementos est\u00e1, o no, activa, y en caso de que todas est\u00e9n inactivas, se va a dormir. El sistema se despertar\u00e1 ante alguna interrupci\u00f3n de un timer o interrupci\u00f3n externa (pulsaci\u00f3n de bot\u00f3n).</p> <p>Antes de empezar a implementar las funciones de bajo consumo vamos a partir de una serie de consideraciones de la FSM. En la siguiente secci\u00f3n se detallan mucho m\u00e1s los estados, pero por ahora, nos fijamos en lo relativo al bajo consumo:</p> <ul> <li> <p>En bajo consumo desactivaremos el SysTick para que no despierte al sistema cada \\(1 ms\\). As\u00ed pues, el contador del sistema no aumenta mientras se est\u00e1 dormido.</p> </li> <li> <p>Las ISR que generan interrupciones externas \u2014bot\u00f3n y transceptor ultrasonidos\u2014 son las encargadas de reactivar el SysTick.</p> </li> <li> <p>La FSM del bot\u00f3n est\u00e1 inactiva en el estado <code>BUTTON_RELEASED</code>.</p> </li> <li> <p>La FSM del transceptor de ultrasonidos est\u00e1 inactiva siempre, pues el dispositivo \"solo est\u00e1 funcionando\u201d cuando hay interrupciones del temporizador del trigger, o del input capture del echo. No es bloqueante.</p> </li> <li> <p>La FSM del RGB light est\u00e1 activa si el status indica que est\u00e1 funcionando, y no est\u00e1 ocioso (idle).</p> </li> <li> <p>Las autotransiciones de los estados de la FSM Simone (<code>SLEEP_WHILE_ON</code> y <code>SLEEP_WHILE_OFF</code>) est\u00e1n pensados para cuando est\u00e9 trabajando en depuraci\u00f3n. El depurador genera interrupciones en la ejecuci\u00f3n del c\u00f3digo que despiertan a nuestro sistema. Como no se trata de interrupciones de nuestros elementos, no pasaremos a los estados, pero debemos dormirnos mientras no se detenga el depurador de nuevo en otro breakpoint. Este es el cometido de dichas autotransiciones.</p> </li> </ul> <p>Procedamos. Como siempre, tenga abierta la p\u00e1gina web de la API https://sdg2dieupm.github.io/simone/, ah\u00ed est\u00e1n todos los detalles de implementaci\u00f3n. Vamos a tocar varios ficheros pero no crearemos ninguno nuevo.</p> <p>Vamos a a\u00f1adir las funciones de comprobaci\u00f3n espec\u00edficas de cada m\u00e1quina de estados.</p> <ol> <li> <p>En <code>fsm_button.c</code>: A\u00f1ade la funci\u00f3n <code>fsm_button_check_activity()</code> y su prototipo y documentaci\u00f3n del c\u00f3digo en <code>fsm_button.h</code>.</p> </li> <li> <p>En <code>fsm_keyboard.c</code> a\u00f1ade la funci\u00f3n <code>fsm_ultrasound_check_activity()</code> y su prototipo y documentaci\u00f3n del c\u00f3digo en <code>fsm_keyboard.h</code>.</p> </li> <li> <p>En <code>fsm_rgb_light.c</code> a\u00f1ade la funci\u00f3n <code>fsm_rgb_light_check_activity()</code> y su prototipo y documentaci\u00f3n en <code>fsm_rgb_light.h</code>.</p> </li> </ol> <p>Para terminar, vamos a a\u00f1adir las funciones HW espec\u00edficas de manejo del modo stop y sleep en nuestro STM32F446RE. Primero a\u00f1adiremos algunas funciones generales del sistema en <code>stm32f4_system.c</code>; luego las modificaciones necesarias para restablecer el reloj de sistema SysTick tras una interrupci\u00f3n del bot\u00f3n o del transceptor de ultrasonidos, o de temporizador.</p> <p>En <code>stm32f4_system.c</code>:</p> <ol> <li> <p>Copia el c\u00f3digo de <code>port_system_power_stop()</code> y <code>port_system_power_sleep()</code> de la API. Por tener un orden, puede hacerlo en una parte dedicada a POWER RELATED FUNCTIONS.</p> </li> <li> <p>Copia el c\u00f3digo de <code>port_system_systick_suspend()</code> de la API. Por tener un orden, puede hacerlo en la parte dedicada a TIMER RELATED FUNCTIONS.</p> </li> <li> <p>Copia el c\u00f3digo de <code>port_system_systick_resume()</code> de la API. Por tener un orden, puede hacerlo tambi\u00e9n en la parte dedicada a TIMER RELATED FUNCTIONS.</p> </li> <li> <p>Implementa la funci\u00f3n <code>port_system_sleep()</code> como indica la API. Por tener un orden, puede hacerlo junto con las anteriores en la parte dedicada a POWER RELATED FUNCTIONS.</p> </li> </ol> <p>En <code>port_system.h</code>:</p> <ol> <li>A\u00f1ade los prototipos de las funciones anteriores y su documentaci\u00f3n.</li> </ol> <p>En el fichero en el que se encuentran nuestras ISR, <code>interr.c</code>.</p> <ol> <li> <p>A\u00f1ade al principio de la ISR del bot\u00f3n la llamada a <code>port_system_systick_resume()</code> para reactivar el contador del sistema SysTick, inmediatamente, tras la interrupci\u00f3n de pulsaci\u00f3n (en estado inactivo el bot\u00f3n no est\u00e1 pulsado, por eso no estar\u00e1 durmiendo si el bot\u00f3n permanece pulsado).</p> </li> <li> <p>Haz lo mismo en la ISR del echo del transceptor de ultrasonidos, <code>TIM2_IRQHandler()</code>.</p> </li> </ol> <p>\u00a1Ya tenemos un sistema eficiente energ\u00e9ticamente! En el futuro ten siempre en consideraci\u00f3n la importancia de estos modos de bajo consumo en cualquier sistema embebido que se alimente con bater\u00edas. Vamos a unir todas las piezas.</p>"},{"location":"notebook/version_4_old.html#sec:fsm_simone_1","title":"Integraci\u00f3n final","text":"<p>Ya tenemos todos los m\u00f3dulos de las versiones V1-V3 de Simone desarrollados y probados: bot\u00f3n, transceptor de ultrasonidos y RGB light (LED) RGB. Ahora vamos a integrarlos en el sistema central, y rellenar el <code>main.c</code> del programa. Procedamos:</p> <p>La m\u00e1quina de estados del sistema Simone involucra a todos los elementos del mismo y la gesti\u00f3n del bajo consumo. Al ser una implementaci\u00f3n puramente l\u00f3gica y no intervenir aqu\u00ed ning\u00fan elemento HW, todo ser\u00e1 desarrollo de la parte <code>COMMON</code>.</p>"},{"location":"notebook/version_4_old.html#consideraciones-de-la-fsm-de-simone","title":"Consideraciones de la FSM de Simone","text":""},{"location":"notebook/version_4_old.html#_1","title":"Versi\u00f3n 4: modos de bajo consumo e integraci\u00f3n final","text":"<p>Antes de empezar vamos a partir de una serie de consideraciones.</p> <ul> <li> <p>La FSM contiene en su estructura las m\u00e1quinas de estados del resto de elementos del sistema.</p> </li> <li> <p>Es Simone qui\u00e9n define qu\u00e9 es una pulsaci\u00f3n larga, o corta. Recuerde que la pulsaci\u00f3n larga del bot\u00f3n nos indicar\u00e1 el inicio de la marcha atr\u00e1s y por tanto el arranque del sistema de aparcamiento Simone, y la pulsaci\u00f3n corta servir\u00e1 para pausar el RGB light.</p> </li> <li> <p>Es esta FSM qui\u00e9n gestiona si el sistema est\u00e1 en pausa, o no.</p> </li> <li> <p>La FSM es \u00fanica, por lo que no es necesario tener informaci\u00f3n de identificador.</p> </li> <li> <p>Es la FSM del sistema Simone qui\u00e9n pregunta a los distintos m\u00f3dulos su estado y gestiona la activaci\u00f3n del modo de bajo consumo.</p> </li> </ul> <p>La muestra los estados de la FSM de Simone. Ya podemos comprobar que el sistema Simone se enciende y apaga correctamente (meter y quitar la marcha atr\u00e1s). Ahora crearemos los ficheros de partida. En esta ocasi\u00f3n no hay plantilla de descarga, as\u00ed que vamos a crear los ficheros nosotros mismos:</p> <ol> <li> <p>Crea el fichero <code>fsm_simone.h</code> en la carpeta correspondiente de <code>COMMON</code>. Este fichero contendr\u00e1 la cabecera de la FSM de Simone. Pon las protecciones del fichero para evitar m\u00faltiples inclusiones, para lo que tienes que a\u00f1adir las directivas de precompilador <code>#ifndef</code>, <code>#define</code>, y <code>#endif</code>, como se ha hecho en las versiones anteriores.</p> </li> <li> <p>Crea el fichero <code>fsm_simone.c</code> en la carpeta correspondiente de <code>COMMON</code>. Este fichero contendr\u00e1 la implementaci\u00f3n de la FSM de Simone.</p> </li> </ol> <p>Vamos a empezar por la cabecera de la FSM de Simone.</p>"},{"location":"notebook/version_4_old.html#common-cabecera-de-la-fsm-de-simone","title":"<code>COMMON</code>: cabecera de la FSM de Simone","text":"<p>Abre el fichero <code>fsm_simone.h</code> y procedamos.</p> <ol> <li> <p>Incluye las librer\u00edas necesarias seg\u00fan indica la API.</p> </li> <li> <p>Seguidamente crea el enumerado <code>FSM_SIMONE</code> con los estados de la .</p> </li> <li> <p>Seguidamente declararemos la estructura <code>fsm_simone_t</code> para hacerla p\u00fablica. No obstante, no vamos definir sus campos p\u00fablicamente.</p> </li> <li> <p>Incluye los prototipos de las funciones p\u00fablicas de la FSM seg\u00fan indica la API.</p> </li> <li> <p>Documenta las funciones, enumerado y tipo nuevo. No olvides incluir el encabezado del fichero con su nombre y la fecha.</p> </li> </ol> Estructura de la FSM de Simone en <code>COMMON</code>."},{"location":"notebook/version_4_old.html#common-implementacion-de-la-fsm-de-simone","title":"<code>COMMON</code>: implementaci\u00f3n de la FSM de Simone","text":"<p>Vamos a proceder con la implementaci\u00f3n de las funciones de la FSM de Simone.</p> <p>Aunque el sistema Simone es \u00fanico \u2014no va a haber m\u00e1s que una FSM de este tipo\u2014, estamos implementando una librer\u00eda. Esta librer\u00eda no tiene <code>main</code> y se gestionar\u00e1 desde el fichero <code>main.c</code> del proyecto, como veremos m\u00e1s adelante.</p> <ol> <li> <p>Lo primero que debe aparecer es la inclusi\u00f3n de cabeceras. Incluya las librer\u00edas que indica la API.</p> </li> <li> <p>A continuaci\u00f3n completa la estructura <code>fsm_simone_t</code> con los campos que se muestran en la y como nos dice la API. De nuevo, es muy importante que la m\u00e1quina de estados de la simone <code>fsm_t</code> est\u00e9 lo primero.</p> <ul> <li> <p><code>*p_fsm_button</code>, <code>on_off_press_time_ms</code> y <code>pause_rgb_light_time_ms</code> son los campos que nos permitir\u00e1n gestionar el bot\u00f3n.</p> </li> <li> <p><code>*p_fsm_button</code> es un puntero a la m\u00e1quina de estados del bot\u00f3n, <code>on_off_press_time_ms</code> es el tiempo en milisegundos para considerar que se ha metido la marcha atr\u00e1s, y <code>pause_rgb_light_time_ms</code> es el tiempo en milisegundos para considerar una pulsaci\u00f3n corta del bot\u00f3n para pausar el RGB light.</p> </li> <li> <p><code>is_paused</code> es una variable que nos indica si el RGB light est\u00e1 pausado o no.</p> </li> <li> <p><code>*p_fsm_ultrasound_rear</code> es el puntero a la m\u00e1quina de estados del transceptor de ultrasonidos trasero.</p> </li> <li> <p><code>*p_fsm_rgb_light_rear</code> es el puntero a la m\u00e1quina de estados del RGB light que indica la distancia a un obst\u00e1culo por la parte trasera del coche.</p> </li> </ul> </li> <li> <p>Documenta los campos de la estructura <code>fsm_simone_t</code>.</p> </li> </ol> <p>Comenzamos con las funciones de entrada o comprobaci\u00f3n, \u0131.e., aquellas que comienzan por <code>check_</code>. Codifica las funciones de entrada <code>/* State machine input functions */</code>.</p> <ol> <li> <p>Codifica la funciones <code>check_on()</code>, <code>check_off()</code>, <code>check_new_measure()</code> y <code>check_pause_rgb_light()</code> como indica la API.</p> </li> <li> <p>Codifica las funciones de comprobaci\u00f3n de actividad para bajo consumo <code>check_activity()</code>, <code>check_no_activity()</code> y <code>check_activity_in_measure()</code> como indica la API. Esta \u00faltima funci\u00f3n es como <code>check_new_measure()</code>. Para que la depuraci\u00f3n sea m\u00e1s sencilla, no reutilizamos el nombre de la funci\u00f3n para saber de qu\u00e9 estado partimos.</p> </li> </ol> <p>Sigamos con las funciones de salida, \u0131.e., aquellas que comienzan por <code>do_</code>. Codifica las funciones de salida <code>/* State machine output or action functions */</code>.</p> <ol> <li> <p>Codifica las funciones <code>do_start_up_measure()</code>, <code>do_stop_simone()</code>, <code>do_pause_rgb_light()</code> y <code>do_rgb_light_intensity()</code> como indica la API.</p> </li> <li> <p>Codifica las funciones relacionadas con el bajo consumo <code>do_sleep_off()</code>, <code>do_sleep_wait_command()</code>, <code>do_sleep_while_off()</code> y <code>do_sleep_while_on()</code> como indica la API.</p> <p>Aunque todas ellas hacen lo mismo, conviene no reutilizar el nombre de la funci\u00f3n para poder realizar una depuraci\u00f3n m\u00e1s sencilla y saber de qu\u00e9 estado partimos.</p> </li> </ol> <p>Vamos a codificar la tabla de transiciones de la FSM Simone.</p> <ol> <li> <p>Codifica, justo debajo de estas funciones privadas, la tabla de transiciones de la FSM de Simone <code>fsm_trans_t fsm_trans_simone[]</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar todo el c\u00f3digo con Doxygen.</p> </li> </ol> <p>Como en las anteriores m\u00e1quinas de estado, tenemos que codificar las funciones privadas antes de que las use alguna otra \u2014ya que no est\u00e1n declaradas en la cabecera\u2014. Ya hemos codificado las funciones de entrada y salida, ahora vamos a codificar la \u00fanica que nos queda.</p> <ol> <li> <p>Codifica la funci\u00f3n <code>fsm_simone_init()</code> como se indica en la API y de forma an\u00e1loga a las anteriores m\u00e1quinas de estados.</p> <p>Inicializa los punteros a las m\u00e1quinas de estados de los elementos del sistema Simone y los tiempos de pulsaci\u00f3n del bot\u00f3n para considerar una pulsaci\u00f3n larga y corta con los datos que se pasan como argumentos. Inicializa tambi\u00e9n la variable <code>is_paused</code> a <code>false</code>.</p> </li> </ol> <p>Por \u00faltimo, como ya hemos hecho con las anteriores m\u00e1quinas de estado, vamos a implementar las funciones p\u00fablicas de la FSM declaradas en la cabecera.</p> <ol> <li> <p>Codifica la funci\u00f3n <code>fsm_simone_new()</code> como se indica en la API y de forma an\u00e1loga a las anteriores m\u00e1quinas de estados.</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_simone_fire()</code> como se indica en la API y de forma an\u00e1loga a las anteriores m\u00e1quinas de estados.</p> </li> <li> <p>Haz lo propio con la funci\u00f3n <code>fsm_simone_destroy()</code>.</p> </li> </ol> <p>Compila y comprueba que no tienes errores. Si los tienes, corr\u00edgelos. Ya solo queda enlazar todo en el <code>main.c</code> y montar el HW para tener el sistema funcionando.</p>"},{"location":"notebook/version_4_old.html#sec:v2_integration","title":"Integraci\u00f3n SW de la FSM Simone","text":"<p>Ha llegado la hora de integrar la parte SW del sistema, y depurar. Vamos a escribir las l\u00edneas de c\u00f3digo necesarias en <code>main.c</code> para probar que funciona. Procedamos:</p> <ol> <li> <p>Abre el fichero <code>main.c</code> e incluye las cabeceras necesarias.</p> </li> <li> <p>Define la macro <code>SIMONE_ON_OFF_PRESS_TIME_MS</code> como indica la API para definir una pulsaci\u00f3n larga como aquella que supere \\(1 s\\). \u00a1Ojo, porque el tiempo hay que darlo en milisegundos! Este es el tiempo que se debe mantener pulsado el bot\u00f3n para emular que se ha metido la marcha atr\u00e1s.</p> </li> <li> <p>Define la macro <code>SIMONE_PAUSE_RGB_LIGHT_TIME_MS</code> como indica la API para definir una pulsaci\u00f3n corta como aquella que supere \\(0.5 s\\). \u00a1Ojo, porque el tiempo hay que darlo en milisegundos!</p> </li> <li> <p>Despu\u00e9s de la inicializaci\u00f3n del sistema con la llamada a la funci\u00f3n <code>port_system_init()</code>, crea la m\u00e1quina de estados para el bot\u00f3n. Dale un nombre representativo (*e.g.*, <code>p_fsm_button</code>). Para ello llama a la funci\u00f3n <code>fsm_button_new()</code> con los argumentos necesarios. A continuaci\u00f3n, haz lo propio con la m\u00e1quina de estados del transceptor de ultrasonidos trasero, y con la del RGB light trasero. Dales nombres representativos.</p> </li> <li> <p>Crea la m\u00e1quina de estados para el sistema Simone, puedes darle un nombre representativo (*e.g.*, <code>p_fsm_simone</code>). \u00a1No pases los valores \"a pincho\u201d, usa los <code>#define</code> que has creado!</p> </li> <li> <p>En el bucle <code>while</code>, lanza constantemente la funci\u00f3n <code>fsm_xxx_fire()</code>, para las m\u00e1quinas de estados del bot\u00f3n, el transceptor de ultrasonidos, el RGB light y Simone.</p> <p>Conviene que el sistema sea lo \u00faltimo porque depende de la actualizaci\u00f3n del estado de las FSM de los elementos anteriores.</p> </li> <li> <p>Por \u00faltimo solo nos queda un aspecto meramente formal, casi acad\u00e9mico. Cuando creamos las m\u00e1quinas de estado con las funciones <code>fsm_xxx_new()</code> estamos reservando memoria de forma din\u00e1mica (con la funci\u00f3n <code>malloc()</code>). Cuando las m\u00e1quinas de estado dejan de usarse, esa memoria debe ser liberada para poder ser usada por otras partes del c\u00f3digo. Esa liberaci\u00f3n se har\u00e1 con la llamada a la funci\u00f3n <code>fsm_destroy()</code>.</p> <p>Despu\u00e9s del bucle <code>while</code> llama a <code>fsm_xxx_destroy()</code> para cada una de las FSM pas\u00e1ndole su tipo concreto. Esto libera la memoria de cada una de las m\u00e1quinas de estado creadas: bot\u00f3n, transceptor de ultrasonidos, RGB light, y Simone.</p> <p>Como se dec\u00eda, esto es pura ortodoxia, porque el bucle <code>while</code> del <code>main</code> es infinito, y nunca saldr\u00e1 de ah\u00ed, por lo que nuestras FSM nunca dejar\u00e1n de usarse y las l\u00edneas que acabas de escribir con <code>fsm_xxx_destroy()</code> nunca se ejecutar\u00e1n. No obstante, conviene que sepas que as\u00ed deber\u00eda hacerse.</p> </li> <li> <p>Compila y comprueba que no tiene ning\u00fan error. Si tienes, corr\u00edgelos.</p> </li> </ol>"},{"location":"notebook/version_4_old.html#test-de-integracion-de-la-simone","title":"Test de integraci\u00f3n de la Simone","text":""},{"location":"notebook/version_4_old.html#test-de-funcionalidades","title":"Test de funcionalidades","text":""},{"location":"notebook/version_4_old.html#_2","title":"Versi\u00f3n 4: modos de bajo consumo e integraci\u00f3n final","text":"<p>Ya has probado los test de ejemplo de los distintos elementos y que se os han sido proporcionado. Ahora vamos a probar el sistema Simone completo. No se os va a pedir hacer un test formal, pero con todo el trabajo que has hecho, es conveniente que compruebes que todo funciona correctamente. Monta el circuito como se muestra en la . Prueba todo el sistema como en el v\u00eddeo demostraci\u00f3n Simone. Procedamos:</p> Montaje final con el transceptor de ultrasonidos, el bot\u00f3n y el RGB light. <ol> <li> <p>Conecta la placa Nucleo-STM32\u00a0al ordenador.</p> </li> <li> <p>Compila y carga el programa <code>main</code> en la placa ( Clean and Debug). Comprueba que no tienes errores de compilaci\u00f3n.</p> </li> <li> <p>Prueba que el bot\u00f3n enciende y apaga el sistema Simone.</p> </li> <li> <p>Prueba que las distancias se muestran correctamente en la terminal del <code>gdb-server</code>, y que el RGB light se enciende de manera acorde.</p> </li> <li> <p>Prueba que una pulsaci\u00f3n corta pausa el RGB light pero se siguen imprimiendo los mensajes de log en la terminal. Prueba que estando pausado, si la distancia es menor de lo indicado se enciende el LED en rojo (colisi\u00f3n inminente).</p> </li> <li> <p>Prueba que estando pausado, puedes apagarlo.</p> </li> <li> <p>Prueba que al encenderlo ya no est\u00e1 en pausa.</p> </li> <li> <p>Prueba que, estando apagada, la Simone no responde toma medidas ni muestra nada en el RGB light.</p> </li> <li> <p>Prueba, en general, el funcionamiento correcto como en el v\u00eddeo de demostraci\u00f3n. Si encuentras alg\u00fan error, corr\u00edgelo.</p> </li> </ol>"},{"location":"notebook/version_4_old.html#comprobaci\u00f3n-de-bajo-consumo","title":"Comprobaci\u00f3n de bajo consumo","text":""},{"location":"notebook/version_4_old.html#_3","title":"Versi\u00f3n 4: modos de bajo consumo e integraci\u00f3n final","text":"<p>Comprobaremos que el modo sleep de bajo consumo se gestiona correctamente. Compila y comprueba que no tienes errores de sintaxis o de c\u00f3digo. Para comprobar que el sistema est\u00e1 dormido, podemos hacerlo de dos formas:</p> <ol> <li> <p>Lo m\u00e1s habitual \u2014si no tenemos acceso a un depurador y si tenemos que caracterizar nuestro producto\u2014 ser\u00eda hacerlo mediante la medici\u00f3n del consumo del microcontrolador (\u00a1no de los elementos HW de nuestro sistema!). Para medir el consumo, ve el punto \"6.6 JP6 (IDD)\u201d del manual de la placa\u00a0<sup>2</sup>. Si vas a medirlo, tambi\u00e9n deber\u00edas desconectar los jumpers del <code>ST-LINK</code> del conector <code>CN2</code>. Para ver el ahorro tendr\u00edamos que medirlo en ejecuci\u00f3n sobre versi\u00f3n final. Esto puedes hacerlo si deseas como funcionalidad extra en la Versi\u00f3n 5, e incluir la informaci\u00f3n en la documentaci\u00f3n del c\u00f3digo (fichero <code>README.md</code>).</p> </li> <li> <p>Lo que haremos para demostrar que el sistema alterna entre el modo despierto y dormido ser\u00e1 depurando. Contin\u00faa con la depuraci\u00f3n sin poner puntos de parada. Cuando el sistema est\u00e9 inactivo, pausa la depuraci\u00f3n y comprueba que se ha detenido en la l\u00ednea de c\u00f3digo tras la llamada a wait for interrupt (<code>__WFI()</code>), similar a como se muestra en la . Esto querr\u00e1 decir que, efectivamente, la ejecuci\u00f3n estaba detenida esperando una interrupci\u00f3n, se ha despertado, y ha pasado a la siguiente l\u00ednea de c\u00f3digo.</p> </li> </ol> Restauraci\u00f3n del modo despierto vista en depuraci\u00f3n."},{"location":"notebook/version_4_old.html#test-final","title":"Test final","text":""},{"location":"notebook/version_4_old.html#_4","title":"Versi\u00f3n 4: modos de bajo consumo e integraci\u00f3n final","text":"<p>En pro de hacer una buena documentaci\u00f3n de un proyecto \u2014tanto si es para un cliente como si es para los propios desarrolladores de una empresa\u2014, es conveniente tomar im\u00e1genes y/o v\u00eddeos y presentarlas como demostraci\u00f3n. En este caso, lo haremos mostrando una captura del osciloscopio en el que aparezca la se\u00f1al trigger que excita el transceptor de ultrasonidos, y el eco recibido. Procedamos:</p> Captura de osciloscopio de la se\u00f1al trigger y eco del transceptor de ultrasonidos, indicando la distancia. <ol> <li> <p>Toma dos cables y con las sondas del osciloscopio con\u00e9ctalos en la protoboard a los pines de echo y trigger del transceptor de ultrasonidos. No olvides conectar los cocodrilos de las sondas a la masa de la protoboard.</p> </li> <li> <p>Configura el trigger del osciloscopio para que se dispare cuando se detecte un flanco de subida en el pin de eco. Ajusta el eje de tiempos hasta que veas bien en osciloscopio ambas se\u00f1ales correctamente. Coloca un objeto fijo delate del transceptor para jugar con la distancia que se muestra en el osciloscopio.</p> </li> <li> <p>Haz que en el osciloscopio aparezcan los cursores de tiempo indicando el inicio y el fin del eco, as\u00ed como el valor de la medida, como Se muestra en la .</p> </li> <li> <p>Haz una captura del osciloscopio. Usa el programa del ordenador o conecta una memoria <code>USB</code> en el osciloscopio para descargar la se\u00f1al. \u00a1No sirven fotos con el m\u00f3vil!</p> </li> <li> <p>Edita la captura con Paint u otro editor para escribir, seg\u00fan la medida indicada, a qu\u00e9 distancia est\u00e1 el objeto. Deber\u00eda verse algo como lo de la . A\u00f1\u00e1dela a tu <code>README.md</code>.</p> </li> </ol> <p>\u00a1Ya tenemos el sistema Simone funcionando! No olvides documentarlo (v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d). En la siguiente versi\u00f3n podr\u00e1s a\u00f1adir m\u00e1s funcionalidades a tu elecci\u00f3n. Puedes incluir m\u00e1s capturas o im\u00e1genes para enriquecer la documentaci\u00f3n.</p> <p>Guarda una copia de su proyecto como <code>simone_v4</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla. Esta copia s\u00fabela al buz\u00f3n de entrega de la asignatura separada de la que hagas con la versi\u00f3n 5, que tiene otro buz\u00f3n. \u00a1\u00c1nimo!</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Universidad Polit\u00e9cnica de Madrid, 2024.\u00a0\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Um1724 user manual. stm32 nucleo-64 boards. Technical Report, STMicroelectronics, 2020. URL: https://www.st.com/resource/en/user_manual/um1724-stm32-nucleo64-boards-mb1136-stmicroelectronics.pdf.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"notebook/version_5.html","title":"Versi\u00f3n 5: funcionalidades de libre elecci\u00f3n","text":"<p>En las \u00faltimas sesiones puedes poner a punto la versi\u00f3n final del sistema e incluir diversas funcionalidades a tu elecci\u00f3n. Con ello podr\u00e1s alcanzar la m\u00e1xima nota. Recuerda que (i) el proyecto es el \\(70\\%\\) de la nota total, y (ii) que el proyecto propuesto con especificaciones m\u00ednimas obligatorias tiene un m\u00e1ximo de 8 puntos. Estas funcionalidades de libre elecci\u00f3n son un \\(20\\%\\) de la nota final, \u00a1no las dejes!</p>"},{"location":"notebook/version_5.html#posibles-funcionalidades","title":"Posibles funcionalidades","text":"<p>Las sugerencias que se muestran son orientativas. La valoraci\u00f3n de la dificultad (de dise\u00f1o y de implementaci\u00f3n) tambi\u00e9n. No obstante, se valorar\u00e1n especialmente aquellas funcionalidades que conlleven alg\u00fan tipo de esfuerzo por parte del alumno a un mayor n\u00famero de niveles. As\u00ed, se tendr\u00e1n en cuenta los 3 niveles de la arquitectura t\u00edpica de cualquier sistema embebido: (i) nivel SW o de aplicaci\u00f3n (nivel superior en verde de la pila presentada en la\u00a0), nivel HW (nivel inferior en rojo), y nivel de SW de sistema o nivel dedicado a la integraci\u00f3n HW-SW (nivel intermedio en naranja), mediante el uso de drivers (i.e.\u00a0controladores o librer\u00edas) SW para el manejo de dispositivos.</p> Niveles de valoraci\u00f3n de las posibles funcionalidades a implementar. <p>As\u00ed, el impacto de la funcionalidad se valorar\u00e1 seg\u00fan las escalas de la\u00a0, y podr\u00eda puntuar, orientativamente, como se indica:</p> <ul> <li> <p>Solo el primer nivel: BAJA valoraci\u00f3n, por tratarse de una funcionalidad que solo requiere modificar c\u00f3digo. Hasta \\(0.5\\) puntos.</p> </li> <li> <p>Solo los dos primeros niveles: valoraci\u00f3n MEDIA, por tratarse de una funcionalidad que, adem\u00e1s de modificar el c\u00f3digo, requiere del uso de alg\u00fan nuevo recurso del STM32F446RE\u00a0o la placa (como por ejemplo otro temporizador, PWM, uso de ADC, FSM) o de una configuraci\u00f3n alternativa de los ya usados (bien sean HW o SW). Entre \\(0.5\\) y \\(1.0\\) puntos.</p> </li> <li> <p>Los tres niveles: valoraci\u00f3n ALTA, por afectar a todos los niveles de dise\u00f1o del sistema, por lo que es fundamental que se incluya nuevo HW al sistema. Entre \\(1.0\\) y \\(1.5\\) puntos.</p> </li> </ul> <p>En cualquier caso, las funcionalidades aqu\u00ed propuestas o las que t\u00fa sugieras, pueden implementarse de distintas formas m\u00e1s o menos complejas y con distintos grados de perfecci\u00f3n (calidad), por lo que la calificaci\u00f3n final depender\u00e1 de ambos aspectos. Igualmente, la originalidad o la novedad de tus propuestas, ser\u00e1 tenida en cuenta para la evaluaci\u00f3n. Hacer una funcionalidad no implica necesariamente conseguir toda la puntuaci\u00f3n. Del mismo modo, podr\u00edan conseguirse m\u00e1s puntos de los previstos, si se merece.</p> <p>ATENCI\u00d3N</p> <p>Recuerda que tienes el v\u00eddeo de ayuda \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d.</p> <p>Podr\u00edas hacer uso de HW disponible en el laboratorio como teclados matriciales de 16 botones y pantallas LCD. Tambi\u00e9n puedes a\u00f1adir el tuyo. A continuaci\u00f3n se muestran algunas posibles ideas para a\u00f1adir el sistema o convertirlo en parte de otro proyecto mayor.</p> <p>Si tienes dudas sobre la implementaci\u00f3n o valoraci\u00f3n de estas u otras funcionalidades, no dudes en ponerte en contacto con cualquiera de los profesores de la asignatura.</p> <p>Guarda una copia de tu proyecto como <code>simone_v5</code> separada de la que contiene los requisitos b\u00e1sicos V1-V4, y s\u00fabelo a Moodle en el buz\u00f3n preparado para V5. No olvides incluir el v\u00eddeo demostrativo en el README.md.</p>"}]}