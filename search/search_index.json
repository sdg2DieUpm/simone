{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Portada","text":"<p>Simone Un juego de memoria visual y velocidad Reinventando el cl\u00e1sico juego Simon</p> <p></p> <p>Sistemas Digitales II Grado en Ingenier\u00eda de Tecnolog\u00edas y Servicios de Telecomunicaci\u00f3n Curso 2025-2026</p> <p>Profesores: Josu\u00e9 Pag\u00e1n Ortiz (coordinador docente) j.pagan@upm.es, Manuel Gil Mart\u00edn (coordinador administrativo) manuel.gilmartin@upm.es, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Amadeo de Gracia Herranz, Ra\u00fal Izquierdo L\u00f3pez, Juan Antonio L\u00f3pez Mart\u00edn</p> <p>Colaboradores docentes:   \u00c1lvaro Basterra Garc\u00eda,   Sergio Esteban Romero,   Ignacio Hern\u00e1ndez Abad,   Iv\u00e1n Mart\u00edn Fern\u00e1ndez</p> <p>Departamento de Ingenier\u00eda Electr\u00f3nica</p> <p>En memoria de Mario Garrido G\u00e1lvez (1981-2025), un excelente profesor y compa\u00f1ero. DEP.</p>"},{"location":"notebook/acronimos.html","title":"Acr\u00f3nimos","text":""},{"location":"notebook/acronimos.html#acronimos","title":"Acr\u00f3nimos","text":"Acr\u00f3nimo Definici\u00f3n ADC Anolog-Digital Converter (Conversor Anal\u00f3gico-Digital) AHB Advanced High-performance Bus (Bus Avanzado de Alto rendimiento) APB Advanced Peripheral Bus (Bus Avanzado de Perif\u00e9ricos) API Application Programming Interface (Interfaz de Programaci\u00f3n de Aplicaciones) ARM Advanced  Machine ASCII American Standard Code for Information Interchange, C\u00f3digo Estadounidense Est\u00e1ndar para el Intercambio de Informaci\u00f3n BOM Bill Of Materials (Lista De Materiales) CELT Circuitos Electr\u00f3nicos CISC Complex Instruction Set Computer (Computador con Conjunto de Instrucciones Complejo) CMSIS Common Microcontroller Software Interface Standard CPU Central Processing Unit (Unidad Central de Procesamiento) DIY Do It Yourself (Hazlo T\u00fa Mismo) EXTI External Interrupt/~Event Controller (Controlador de Interrupciones Externas) FSM Finite State Machine (M\u00e1quina de Estados Finitos) FPU Floating Point Unit (Unidad de Punto Flotante) FW Firmware GPIO General Purpose Input/Output (Entrada/Salida de Prop\u00f3sito General) HAL Hardware Abstraction Layer (Capa de Abstracci\u00f3n Hardware) HSE High Speed External clock HSI High Speed Internal clock HW Hardware IDE Integrated Development Environment (Entorno de Desarrollo Integrado) IoT Internet of Things ISR Interrupt Service Routine (Rutina de Servicio/Atenci\u00f3n a la Interrupci\u00f3n) ITM Instrumentation Trace Macrocell LCD Liquid-Crystal RGB light (Pantalla de Cristal L\u00edquido) LED Light-Emitting Diode (Diodo Emisor de Luz) MCU Microcontroller Unit (Unidad de Microcontrolador) NVIC Nested Vectored Interrupt Controller (Controlador de Vector de Interrupciones Anidadas) PC Personal Computer (Ordenador Personal) PCB Printed Circuit Board (Placa de Circuito Impreso) PWM Pulse Width Modulation (Modulaci\u00f3n de Ancho de Pulso) RCC Reset and Clock Controller (Controlador de Reinicio y Reloj) SDG1 Sistemas Digitales I SDG2 Sistemas Digitales II ST STMicroelectronics SW Software USB Universal Serial Bus"},{"location":"notebook/bom.html","title":"BOM","text":""},{"location":"notebook/bom.html#apndx:app_bom","title":"Lista de materiales (BOM)","text":"<p>En los enlaces podr\u00e9is encontrar algunos suministradores y tener acceso a las hojas de caracter\u00edsticas (datasheets) de los componentes.</p> Comp. Concepto Descripci\u00f3n Uds. Partida URL - Nucleo-F446RE Placa de desarrollo 1 BASE L1, L2, L3 - Cable USB A-Mini B Importante: cable de alimentaci\u00f3n y datos 1 BASE Link - Latiguillos macho-macho Cables de conexi\u00f3n para protoboard +10 BASE Link - Latiguillos macho-hembra Cables de conexi\u00f3n para protoboard +10 BASE Link - Protoboard Tama\u00f1o m\u00ednimo: \\(80 \\times 60 \\text{ mm}\\) 1 BASE Link - Teclado matricial Membrana 4x4 alfanum\u00e9rico 1 TECLADO L1, L2, L3 <code>D1</code> LED RGB c\u00e1todo com\u00fan De inserci\u00f3n. e.g. \\(60^\\circ\\) visi\u00f3n 1 DISPLAY Link <code>R_R</code> Resistencia \\(150~\\Omega\\) De inserci\u00f3n. Tol: \\(\\leq 10\\%\\). Pot: \\(\\frac{1}{4}-\\frac{1}{2}~W\\) 1 DISPLAY Link <code>R_G</code>, <code>R_B</code> Resistencia \\(91~\\Omega\\) De inserci\u00f3n. Tol: \\(\\leq 10\\%\\). Pot: \\(\\frac{1}{4}-\\frac{1}{2}~W\\) 2 DISPLAY Link Figura BOM. Materiales del proyecto Simone agrupados por partida."},{"location":"notebook/intro.html","title":"Introducci\u00f3n a SDG2","text":""},{"location":"notebook/intro.html#cha:pr_intro","title":"Introducci\u00f3n","text":"<p>En este cap\u00edtulo se presenta una introducci\u00f3n a la asignatura de laboratorio SDG2, y la descripci\u00f3n general del proyecto de la asignatura y la organizaci\u00f3n de este. Aqu\u00ed se podr\u00e1 encontrar informaci\u00f3n sobre la evaluaci\u00f3n y el calendario que se seguir\u00e1.</p>"},{"location":"notebook/intro.html#sistemas-digitales-ii","title":"Sistemas Digitales II","text":"<p>La asignatura se imparte con una metodolog\u00eda de Aprendizaje Basado en Proyectos <sup>2</sup>. Los alumnos tienen como objetivo realizar el desarrollo de un sistema electr\u00f3nico empotrado complejo basado en un microcontrolador de bajas prestaciones partiendo de una descripci\u00f3n y unas especificaciones b\u00e1sicas. Este aprendizaje requiere por tu parte el manejo de distintas fuentes de informaci\u00f3n y disciplinas necesarias para resolver problemas. Tu papel ha de ser activo, con un compromiso y responsabilidad por tu propio aprendizaje. Trabajar\u00e1s en parejas desde el principio y desarrollar\u00e1s un proyecto planificando la actuaci\u00f3n, distribuyendo las tareas, evaluando las posibles consecuencias, y previendo los \u00e9xitos.</p> <p>Como indica la Gu\u00eda de Aprendizaje Basado en Proyectos del Servicio de Innovaci\u00f3n Educativa-UPM\u00a0<sup>2</sup>, y a modo de resumen, las caracter\u00edsticas m\u00e1s relevantes a las que debe atender son (recuperado de la Gu\u00eda de Aprendizaje de la asignatura):</p> <ul> <li> <p>No existe una \u00fanica soluci\u00f3n correcta.</p> </li> <li> <p>Se presenta la situaci\u00f3n y los alumnos tienen que ampliar la informaci\u00f3n para avanzar en el proyecto.</p> </li> <li> <p>El papel del profesor es supervisar y revisar el plan de trabajo y evoluci\u00f3n de cada pareja, utilizando las clases de laboratorio y las tutor\u00edas para ayudar a resolver dudas. El profesor tiene tambi\u00e9n el papel de evaluar el progreso y trabajo final.</p> </li> <li> <p>La interacci\u00f3n con el alumno se da en las sesiones de laboratorio: orientaci\u00f3n a las dudas y problemas encontrados para seguir el progreso de los estudiantes para evitar equivocaciones, corregir errores conceptuales y orientar el aprendizaje. Se realiza un seguimiento de cada pareja. Tambi\u00e9n en las tutor\u00edas.</p> </li> <li> <p>El lugar de trabajo es el laboratorio y fuera de este.</p> </li> </ul> <p>Note</p> <p>El proyecto no se puede completar solo con las sesiones de laboratorio sin un trabajo de b\u00fasqueda de informaci\u00f3n previa y de trabajo fuera del horario de clase. 3 ECTS son unas 81 horas de esfuerzo. El laboratorio son solo \\(28\\) (un \\(35\\%\\)), por lo que en casa ha de trabajar tanto o m\u00e1s que las horas de laboratorio <sup>3</sup>.</p> <p>Las sesiones de laboratorio plantean al alumno ir consiguiendo hitos que corresponder\u00e1n a ciertos niveles de desarrollo (funcionalidad) del proyecto. El proyecto propuesto se divide en 4 versiones b\u00e1sicas m\u00e1s una versi\u00f3n final de libre elecci\u00f3n. Las versiones b\u00e1sicas son requisitos de funcionalidad obligatorios, pero para completar el proyecto y conseguir la m\u00e1xima nota las parejas deber\u00e1n implementar la versi\u00f3n final de libre elecci\u00f3n.</p> <p>IMPORTANTE</p> <p>Las sesiones de laboratorio NO SON COMO LAS DE OTRAS ASIGNATURAS DE LABORATORIO en las que cada d\u00eda es una pr\u00e1ctica tem\u00e1tica. En SDG2 t\u00fa gestionas tu tiempo dentro y fuera del laboratorio. Existe un objetivo final organizado por fases y, siendo proactivo, debes prever y prepararte para el trabajo que va a hacer cada d\u00eda en el laboratorio. Aunque existe un calendario orientativo, cada pareja avanzar\u00e1 a un ritmo. Los profesores estar\u00e1n para ayudar a resolver dudas que la pareja plantee sobre el problema al que se est\u00e1n enfrentando.</p> <p>Har\u00e1s frente a un caso real de dise\u00f1o e implementaci\u00f3n de un sistema electr\u00f3nico basado en microcontrolador de bajas prestaciones, empleando los medios disponibles en el laboratorio B-043 y componentes electr\u00f3nicos \u2014alguno de los cuales deber\u00e1 adquirir\u2014 (ver materiales en ).</p> <p>Como has venido trabajando en CELT, el laboratorio estar\u00e1 abierto durante \\(2h30'\\). Si se quiere hacer una analog\u00eda con las clases te\u00f3ricas, las horas con profesor son \\(2h\\) de supervisi\u00f3n puramente dicha. El resto del tiempo es para que inicies las m\u00e1quinas, prepares los montajes, y recojas ordenadamente al finalizar. El acceso al laboratorio est\u00e1 controlado por los maestros de laboratorio.</p> <p>Por las ma\u00f1anas habr\u00e1 acceso libre siempre que haya un maestro de laboratorio o persona responsable que abra el laboratorio y vigile. Se recomienda que lleves tu propio material, pues no se garantiza que la persona responsable pueda hacerse cargo de los pr\u00e9stamos.</p>"},{"location":"notebook/intro.html#el-proyecto-simone","title":"El proyecto Simone","text":"<p>El objetivo es desarrollar un sistema b\u00e1sico completamente funcional de una versi\u00f3n del cl\u00e1sico juego de memoria visual, Sim\u00f3n utilizando un teclado matricial y un LED RGB que permita al jugador identificar cada color que se represente por el LED con una tecla del teclado. A este sistema le vamos a llamar Simone. El sistema se basa en (i) una placa Nucleo-STM32F446RE\u00a0que har\u00e1 las veces de sistema central, (ii) un teclado matricial alfanum\u00e9rico de membrana, y (iii) un LED RGB\u00a0que cambia de color de forma aleatoria con cada secuencia de colores que crea el juego. Puede ver el video demostrativo en Demostraci\u00f3n del sistema Simone. Al sistema b\u00e1sico posteriormente el alumno debe a\u00f1adir m\u00e1s funcionalidades de su elecci\u00f3n.</p> <p>Para entender lo que vamos a construir, debemos viajar atr\u00e1s en el tiempo, hasta 1978, cuando el ingeniero Ralph Baer (conocido como el padre de los videojuegos) y Howard J. Morrison presentaron al mundo el juego Simon. Este dispositivo con forma de platillo volante se convirti\u00f3 en un icono de la cultura pop de los 80. Su funcionamiento era  simple: un juego de memoria visual y auditiva donde la m\u00e1quina generaba una secuencia progresiva de luces y sonidos aleatorios que el jugador deb\u00eda repetir.</p> Juego Simon original. <p>La mec\u00e1nica original consist\u00eda en cuatro grandes botones de colores (rojo, verde, azul y amarillo), cada uno asociado a un tono musical espec\u00edfico. El juego comenzaba con una secuencia de un solo paso. Si el usuario acertaba, la m\u00e1quina repet\u00eda la secuencia y a\u00f1ad\u00eda un nuevo paso al final. El juego terminaba cuando el usuario fallaba o tardaba demasiado en responder.</p> <p>En esta pr\u00e1ctica vamos a rendir homenaje a este cl\u00e1sico, pero elevando la complejidad t\u00e9cnica para adaptarla a un sistema embebido moderno basado en el STM32F446RE. Nuestro sistema, bautizado como Simone, mantiene la esencia del juego de memoria visual pero introduce diferencias significativas respecto al juguete original:</p> <ol> <li>Interfaz de entrada: En lugar de cuatro botones grandes dedicados, utilizaremos un teclado matricial (desarrollado en la Versi\u00f3n 2). Esto nos obliga a mapear teclas espec\u00edficas (<code>'1'</code>, <code>'2'</code>, ...) a colores.</li> <li>Interfaz de salida: Sustituimos las cuatro bombillas independientes por un \u00fanico LED RGB (desarrollado en la Versi\u00f3n 3). Esto implica que la secuencia no es espacial (luces en distintas posiciones), sino puramente crom\u00e1tica (el mismo punto de luz cambia de color).</li> <li>Complejidad crom\u00e1tica: El juego original usaba 4 colores. Simone gestiona una paleta de 6 colores (rojo, verde, azul y amarillo, turquesa y blanco), aumentando la dificultad de memorizaci\u00f3n.</li> <li>Niveles de dificultad din\u00e1micos: Implementaremos un sistema de niveles (<code>EASY</code>, <code>MEDIUM</code>, <code>HARD</code>) que no solo afecta a la velocidad de reproducci\u00f3n, sino tambi\u00e9n a la intensidad lum\u00ednica (PWM). En los niveles dif\u00edciles, los colores se mostrar\u00e1n m\u00e1s tenues y r\u00e1pidos, poniendo a prueba tanto la memoria como la agudeza visual del jugador.</li> <li>Feedback textual: Al carecer de altavoz en esta versi\u00f3n, utilizaremos la terminal de VSCode para enviar mensajes de estado, victoria o derrota, lo que nos servir\u00e1 como herramienta de realimentaci\u00f3n visual en tiempo real.</li> </ol> <p>El reto de este proyecto no es solo programar la l\u00f3gica del juego, sino orquestar los perif\u00e9ricos que construir\u00e9is a lo largo de las sesiones (bot\u00f3n, teclado, LED RGB) para que funcionen al un\u00edsono bajo el control de una m\u00e1quina de estados finitos (FSM) central.</p> <p>El alumno tiene la libertad de imaginar e implementar a trav\u00e9s de la Versi\u00f3n 5 del proyecto cualquier sistema que desee. Por ejemplo: a\u00f1adir un sistema de sonido, m\u00e1s teclados y LEDs, botones, un buzzer para generar sonidos, un LCD u otro RGB light,\u00a0\u2026\u00a0o incluso a\u00f1adir un sistema de comunicaci\u00f3n inal\u00e1mbrica para enviar la informaci\u00f3n a un dispositivo m\u00f3vil.</p> <p>El sistema correr\u00e1 sobre la plataforma Nucleo-STM32F446RE\u00a0(ver libro de fundamentos te\u00f3rico-pr\u00e1cticos de la asignatura\u00a0<sup>4</sup>). Ser\u00eda posible emplear otros modelos de placa Nucleo-STM32\u00a0si el modelo basado en el microcontrolador STM32F446RE\u00a0no est\u00e1 disponible (*e.g.*, el modelo STM32F411RE). En dicho caso deber\u00e1 realizar los pasos para adaptarse a la asignatura. Se deber\u00e1 comprar una placa por pareja o una por cada miembro, si lo desea (les dar\u00e1 m\u00e1s posibilidades de hacer pruebas y nuevas implementaciones m\u00e1s interesantes). Los componentes electr\u00f3nicos b\u00e1sicos se les prestan, pero se aconseja que consig\u00e1is los vuestros, sobre todo para la Versi\u00f3n 5 del proyecto. Para los primeros d\u00edas o en caso de olvido, habr\u00e1 placas de pr\u00e9stamo durante las sesiones de laboratorio.</p> <p>Para poder trabajar en tu ordenador personal deber\u00e1s tener instalado el entorno de compilaci\u00f3n cruzada siguiendo los pasos de instalaci\u00f3n del cap\u00edtulo de la \u201cGu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n cruzada en C\u201d <sup>5</sup>. Durante las sesiones de laboratorio no se resolver\u00e1n problemas de instalaci\u00f3n del entorno para no entorpecer al resto de compa\u00f1eros que tengan dudas del proyecto. Si se tienen problemas en la instalaci\u00f3n, se concertar\u00e1 una tutor\u00eda.</p>"},{"location":"notebook/intro.html#subsec:materiales","title":"Materiales","text":"<p>La lista de materiales que se usan se muestra en la BOM del anexo. En la puede verlos agrupados por cada una de las \"partidas\" del proyecto: los b\u00e1sicos, los de la sensorizaci\u00f3n, y los de actuaci\u00f3n.</p> <p>Lo m\u00e1s urgente de adquirir es la placa Nucleo-STM32F446RE\u00a0y el cable USB necesarios para la V1 y siguientes. El resto de HW se usar\u00e1 en las siguientes versiones. Durante las primeras sesiones podr\u00e1s trabajar con las placas que se prestan en el laboratorio, pero no podr\u00e1s llev\u00e1rtela. Cuando adquieras la tuya para trabajar en casa, ser\u00e1 la que debes traer.</p> <p>En el anexo se proporciona informaci\u00f3n de los componentes y un enlace para que tengas una orientaci\u00f3n de cu\u00e1l es. Puedes conseguirlos t\u00fa mismo. Muchos de dichos componentes quiz\u00e1s ya los tengas, como la protoboard, o los cables para la misma. El resto puedse conseguirlo en alguna tienda f\u00edsica de la ciudad, u online. F\u00edjate que algunos de los componentes no se venden por unidad en las tiendas online (quiz\u00e1s le convenga comprar con otros compa\u00f1eros o ir a una tienda f\u00edsica y comprarlos unitarios). Un miembro de la pareja se responsabilizar\u00e1 del material prestado, que ha de devolver en la fecha del examen.</p>"},{"location":"notebook/intro.html#organizacion-versiones","title":"Organizaci\u00f3n (versiones)","text":"<p>El desarrollo del sistema Simone est\u00e1 guiado como un tutorial, por puntos. El proyecto b\u00e1sico son los requisitos m\u00ednimos obligatorios, y suponen el \\(50\\%\\) del total de la calificaci\u00f3n de la asignatura. Un \\(20\\%\\) de la nota es la V5 (ver\u00a0Evaluaci\u00f3n y calendario).</p> <p>El proyecto b\u00e1sico lo podemos dividir en versiones o fases, a modo de gu\u00eda. Todos los c\u00f3digos deber\u00e1n estar documentados con Doxygen. Cada versi\u00f3n tiene un c\u00f3digo de test unitarios HW y SW que se les proporcionar\u00e1. Los c\u00f3digos corren sobre la placa y nos da una indicaci\u00f3n de si el sistema funciona correctamente.</p> <p>Las caracter\u00edsticas m\u00e1s importantes de cada versi\u00f3n son:</p> <ul> <li> <p>Versi\u00f3n 1: desarrollo de la base del sistema con (i) FSM, (ii) interrupci\u00f3n de bot\u00f3n para interactuar con el juego y (iii) temporizaci\u00f3n de la pulsaci\u00f3n con <code>SysTick</code> para poder iniciar y detener el juego. (iv) Por \u00faltimo, test unitarios y la documentaci\u00f3n del c\u00f3digo. (Estimado 2 semanas)</p> </li> <li> <p>Versi\u00f3n 2: desarrollo del subsistema de detecci\u00f3n de teclas del teclado matricial con (i) FSM, (ii) excitaci\u00f3n de las filas de manera alterna mediante interrupci\u00f3n de un temporizador, (iii) captura de entrada (input capture) de las columnas para detecci\u00f3n de tecla, (iii) montaje HW del teclado, y (iv) test unitarios y documentaci\u00f3n del c\u00f3digo. (Estimado 3 semanas)</p> </li> <li> <p>Versi\u00f3n 3: desarrollo del subsistema de visualizaci\u00f3n (i) FSM, (ii) interrupciones de temporizadores para generaci\u00f3n de PWM, (iii) montaje HW del LED RGB, y (iv) test unitarios y documentaci\u00f3n del c\u00f3digo. (Estimado 2 semanas)</p> </li> <li> <p>Versi\u00f3n 4: (i) implementaci\u00f3n de modos de bajo consumo, (ii) integraci\u00f3n de la FSM final del sistema y (iii) prueba y documentaci\u00f3n del c\u00f3digo. (Estimado 1-2 semanas)</p> </li> <li> <p>Versi\u00f3n 5: funcionalidades de libre elecci\u00f3n del alumno. (Estimado 3 semanas)</p> </li> </ul>"},{"location":"notebook/intro.html#sec:profes","title":"Profesorado y turnos de laboratorio","text":"<p>El turno que elijas para asistir al laboratorio no tiene por qu\u00e9 coincidir con el grupo de matriculaci\u00f3n. Puedes elegir el que mejor se ajuste a tu horario. El turno se elige por orden de inscripci\u00f3n en la p\u00e1gina de Moodle de la asignatura. T\u00edpicamente habr\u00e1 2-3 profesores por turno y tambi\u00e9n podremos contar con la ayuda inestimable de los colaboradores docentes que te ayudar\u00e1n en todo lo posible, aunque no tienen competencias de evaluaci\u00f3n, i.e., para consultas de gesti\u00f3n de la asignatura, mejor pregunta a un profesor del turno.</p> <p>Tradicionalmente un profesor se encarga de \"un pasillo\" del laboratorio y tiene seguimiento detallado de los alumnos de esos puestos. No obstante, siempre que sea posible se le atender\u00e1 por cualquier profesor que est\u00e9 libre.</p> <p>IMPORTANTE</p> <p>/ironic mode on/</p> <p>Ya se ha mencionado que la metodolog\u00eda es \"de Aprendizaje Basado en Proyectos\" y que el profesor est\u00e1 para resolver dudas y guiar. Sabemos que este mensaje a estas alturas de la carrera y de la vida est\u00e1 de m\u00e1s, y que t\u00fa no lo haces nunca, pero: levantar la mano y quedarse de brazos cruzados cual cliente en un bar esperando ser servido \u2014en el mejor de los casos, sino es que no se est\u00e1 viendo el \u00faltimo viral de TikTok\u2014 no es la actitud que se espera. Se lee, se prueba, se escribe, se hacen dibujos\u2026, se sacan conclusiones y, cuando se ha cavilado, si no se entiende, se pregunta con fundamento.</p> <p>/ironic mode off/</p>"},{"location":"notebook/intro.html#turnos","title":"Turnos","text":"<p>Turnos de laboratorio</p> LT MT XT JT VC AGH JPO AGH JPO MGM JLM MGM RIL JLM RCR - - - RIL - ABG SER IMF IHA - <p>Lunes-jueves (16:30\u201318:30, apertura 16:00)</p> <p>Viernes (10:30-12:30, apertura 10:00)</p> <p>Algunos profesores pueden usar la pizarra para llevar un orden de atenci\u00f3n a los alumnos que se vayan apuntando. Se podr\u00e1 asistir al laboratorio si no es tu turno y ocupas las bancadas (pasillos) libres, si las hay. No se garantiza que haya profesores o colaboradores docentes para atenderte. Los alumnos del turno tienen preferencia.</p>"},{"location":"notebook/intro.html#profesores-y-colaboradores-docentes","title":"Profesores y colaboradores docentes","text":"<p>Profesores</p> <ul> <li> <p>AGH, Amadeo de Gracia Herranz (C-229) e-mail: amadeo.degracia@upm.es</p> </li> <li> <p>JPO, Josu\u00e9 Pag\u00e1n Ortiz (coordinador) (C-221) e-mail: j.pagan@upm.es</p> </li> <li> <p>MGM, Manuel Gil Mart\u00edn (coord. administrativo) (B-111) e-mail: manuel.gilmartin@upm.es</p> </li> <li> <p>JALM, Juan Antonio L\u00f3pez Mart\u00edn (B-111) e-mail: juanantonio.lopez@upm.es</p> </li> <li> <p>RCR, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez (B-305) e-mail: r.cardenas@upm.es</p> </li> <li> <p>RIL, Ra\u00fal Izquierdo L\u00f3pez (C-206) e-mail: raul.izquierdo@upm.es</p> </li> </ul> <p>Colaboradores docentes</p> <ul> <li>ABG, \u00c1lvaro Basterra Garc\u00eda</li> <li>SER, Sergio Esteban Romero</li> <li>IHA, Ignacio Hern\u00e1ndez Abad</li> <li>IMF, Iv\u00e1n Mart\u00edn Fern\u00e1ndez</li> </ul> <p>Note</p> <p>El laboratorio se organiza por parejas por temas de espacio y gesti\u00f3n de recursos. Que pueda elegir un turno distinto del grupo de matriculaci\u00f3n es lo que permite que pueda elegir pareja. Si no tiene pareja, se le asignar\u00e1 una y un turno. No obstante, si el trabajo con la pareja asignada no funciona por x motivo, h\u00e1gaselo saber antes de la evaluaci\u00f3n parcial a un profesor. No queremos que el no-trabajo de un alumno afecte al rendimiento de otro. No se permiten tr\u00edos. Podr\u00e1 hacer el trabajo de forma individual. Le requerir\u00e1 m\u00e1s disciplina, pero es perfectamente abordable. Los requisitos del proyecto seguir\u00e1n siendo los mismos.</p>"},{"location":"notebook/intro.html#sec:eval","title":"Evaluaci\u00f3n y calendario","text":"<p>La asignatura tiene una componente pr\u00e1ctica muy importante. No obstante, en esta asignatura no solo se aplican conceptos aprendidos, sino que tambi\u00e9n se adquieren otros nuevos. La asignatura tiene 2 grandes bloques de evaluaci\u00f3n que se pueden liberar hasta la evaluaci\u00f3n extraordinaria del mismo curso:</p> <ol> <li> <p>Un proyecto por parejas que tiene 2 partes:</p> <ol> <li> <p>requisitos b\u00e1sicos obligatorios: versiones V1-V4. Es guiada. Supone un \\(50\\%\\) de la nota total. Las especificaciones b\u00e1sicas del proyecto son requisitos impuestos por la asignatura</p> </li> <li> <p>funcionalidades de libre elecci\u00f3n: V5. Desarrollo libre. Supone un \\(20\\%\\) de la nota total.</p> </li> </ol> <p>Las dos entregas de c\u00f3digo (y documentaci\u00f3n de la versi\u00f3n V5) se realizar\u00e1n en buzones de Moodle que se abrir\u00e1n cerca de la fecha de entrega. Solo un miembro de la pareja tiene que subir los ficheros fuente del proyecto. Si realiza implementaciones en V5 que incorporen HW nuevo, deber\u00e1 mostrar su funcionamiento el d\u00eda del examen pr\u00e1ctico individual o cuando se convenga con su profesor asignado. En todo caso, se grabar\u00e1 un v\u00eddeo breve demostrativo de las funcionalidades implementadas en V5.</p> <p>Dispone de una r\u00fabrica orientativa de evaluaci\u00f3n del proyecto en la .</p> </li> <li> <p>Un examen pr\u00e1ctico individual que tiene el fin de diferenciar el trabajo de cada uno de los miembros de la pareja. Supone el \\(30\\%\\) restante de la nota total.</p> <p>El examen consta t\u00edpicamente de 2 ejercicios. Se proporciona un proyecto adaptado del trabajado durante el curso pero m\u00e1s sencillo. Este proyecto no compila y se pide que (i) se depure y corrija, y (ii) se hagan modificaciones. Se realiza en el laboratorio con los ordenadores del mismo. Se dispone de 1 hora para realizarlo. Se puede consultar la documentaci\u00f3n que se proporciona. No se puede consultar internet. Se eval\u00faa la capacidad de depuraci\u00f3n de c\u00f3digo, la capacidad de an\u00e1lisis y resoluci\u00f3n de problemas, y la capacidad de implementaci\u00f3n de soluciones. Puede ver c\u00f3mo abordar esta prueba en estos v\u00eddeos de correcci\u00f3n de examen pr\u00e1ctico de 2023, de 2024, y de 2025.</p> </li> </ol> <p>Se recomienda el uso de repositorios privados de c\u00f3digo como GitHub o BitBucket para guardar el avance del proyecto cada semana. Tambi\u00e9n puedes usar una memoria USB. Es responsabilidad exclusiva del alumno conservar copias de las distintas versiones del proyecto y de tus avances parciales. Los ordenadores del laboratorio se borran diariamente. No obstante, estar\u00e1 abierto continuamente un buz\u00f3n en Moodle para que puedas subir copias de sus c\u00f3digos cuando quieras. Este buz\u00f3n no tiene copia de seguridad.</p> <p>Es responsabilidad de la pareja protegerse de copiar o ser copiados. Los c\u00f3digos pasan el anti-copy. Si se detecta una copia, la nota de los proyectos copia y copiado ser\u00e1 0. Sean honestos, insp\u00edrense, pregunten, pero nunca copien.</p> <p>Conviene recordar que, como indica la Gu\u00eda de Aprendizaje, cualquier evaluaci\u00f3n o entrega realizada podr\u00e1 requerir una evaluaci\u00f3n oral complementaria por parte del profesor para validar que se ha realizado por el alumno sin ayuda de sistemas de Inteligencia Artificial.</p> <p>Como sabr\u00e1, la normativa de la UPM\u00a0<sup>6</sup> distingue entre evaluaci\u00f3n progresiva y global. A continuaci\u00f3n se presentan los criterios de evaluaci\u00f3n en ambas modalidades.</p>"},{"location":"notebook/intro.html#evaluacion-progresiva","title":"Evaluaci\u00f3n progresiva","text":"<p>En esta modalidad hay dos periodos de evaluaci\u00f3n: uno a mitad de semestre y otro al final.</p> Distribuci\u00f3n de las calificaciones de la asignatura. <p>Puede ver el desglose de las calificaciones en la y el detalle de fechas de evaluaci\u00f3n en el calendario de la . En particular:</p> <ul> <li>La semana de ex\u00e1menes del GITST: L\u00cdMITE de entrega por parejas versiones V1 y V2 (\\(25\\%\\)). Solo se entrega un proyecto QUE COMPILE, hasta donde haya llegado. SI NO COMPILA, NO SE CORRIGE, Y LA NOTA ES 0. El profesor corrige con un HW id\u00e9ntico al tuyo y en la siguiente sesi\u00f3n habr\u00e1 realimentaci\u00f3n de los problemas encontrados. El c\u00f3digo debe compilar y cargar en la placa Nucleo-STM32F446RE. Esta fecha es el plazo l\u00edmite de entrega en Moodle, y establecida dentro del periodo de evaluaciones intermedias de la ETSIT. .</li> </ul> <p>ATENCI\u00d3N</p> <p>El montaje HW no es en s\u00ed mismo objeto de evaluaci\u00f3n, pero es indispensable que monte bien para que el sistema funcione seg\u00fan las especificaciones. Si sigues las pautas dadas no deber\u00eda existir ning\u00fan problema con el montaje usado por el profesor para la evaluaci\u00f3n. En caso de que detectes alg\u00fan problema o hagas alguna modificaci\u00f3n relevante, comun\u00edcaselo a tu profesor durante las sesiones de laboratorio (Los d\u0131\u0301as pr\u00f3ximos a la entrega no son una sesi\u00f3n de laboratorio. Salvo causas de fuerza mayor, claro \ud83d\ude42.).</p> <ul> <li> <p>\u00daltimo d\u00eda lectivo: L\u00cdMITE de entrega por parejas versiones V3 y V4 (\\(25\\%\\)), y V5 (\\(\\geq20\\%\\)). El profesor corrige con un HW id\u00e9ntico al tuyo. El c\u00f3digo debe compilar y cargar en la placa Nucleo-STM32F446RE. Esta fecha es el plazo l\u00edmite de entrega en Moodle.</p> <p>Hay que hacer 2 entregas separadas. Una para la parte obligatoria de requisitos m\u00ednimos V1-V4, y otra para V1-V5.</p> <p>Las funcionalidades de la V5 son de libre elecci\u00f3n por el alumno, pueden ser SW, FW, o HW. Las parejas que realicen alguna implementaci\u00f3n deber\u00e1n documentarlas y explicarlas con Doxygen y Markdown utilizando una plantilla proporcionada. Con estas modificaciones SW o montajes alternativos a\u00f1adidos al proyecto b\u00e1sico \u2014y dependiendo de su dificultad y realizaci\u00f3n\u2014 se podr\u00e1n sumar puntos hasta alcanzar la m\u00e1xima nota: 10 puntos (ver ).</p> </li> </ul> <p>Note</p> <p>Los alumnos pueden hacer tantas modificaciones como deseen y la suma de puntos podr\u0131\u0301a exceder el 10. No obstante, la calificaci\u00f3n m\u00e1xima en actas es 10, y el exceso se considera a efectos de poder otorgar Matr\u0131\u0301culas de Honor.</p> <p>ATENCI\u00d3N</p> <p>La evaluaci\u00f3n de las versiones V1-V2 no tiene nota m\u00ednima. Tampoco la tienen V3-V4, ni V5. No obstante, la suma de la nota de ambas evaluaciones del proyecto V1-V2\u00a0+\u00a0V3-V4-V5 ha de ser mayor de 5/10 para liberar el bloque \u201cproyecto\u201d, sino, quedar\u00e1 pendiente esta parte para extraordinaria.</p> <ul> <li> <p>En la fecha estipulada de ex\u00e1menes de la ETSIT: examen pr\u00e1ctico individual en el laboratorio (\\(30\\%\\)). De 1 hora de duraci\u00f3n aproximada. Se dividir\u00e1 a los alumnos en varios horarios de evaluaci\u00f3n que se har\u00e1n disponibles cuando se acerque la fecha.</p> <p>El examen consiste en depurar un c\u00f3digo dado, hacer que compile, y hacer modificaciones o peque\u00f1os desarrollos de c\u00f3digo. Se har\u00e1 con los ordenadores del laboratorio y no tendr\u00e1 acceso a internet. Se le proporcionar\u00e1 la documentaci\u00f3n de consulta necesaria. Puede ver c\u00f3mo abordar esta prueba en estos v\u00eddeos de correcci\u00f3n de examen pr\u00e1ctico de 2023, de 2024, y de 2025.</p> <p>La nota del examen ha de ser mayor de 5/10 y liberar el bloque \"examen pr\u00e1ctico\"\u201d\", sino, quedar\u00e1 pendiente esta parte para la convocatoria extraordinaria.</p> <p>En alg\u00fan momento de la jornada de evaluaci\u00f3n, este d\u00eda tambi\u00e9n (o cuando se convenga con el profesor), se realizar\u00e1 la demostraci\u00f3n de las funcionalidades HW a\u00f1adidas en V5, si las hay.</p> </li> </ul> <p>La gesti\u00f3n de los plazos tambi\u00e9n es parte del proyecto. No se aceptan proyectos despu\u00e9s de la fecha l\u00edmite. La fecha es no es la \u00fanica fecha de entrega, sino la fecha l\u00edmite. Si no es entrega en plazo, se va a convocatoria extraordinaria.</p>"},{"location":"notebook/intro.html#evaluacion-mediante-proyecto-innovador","title":"Evaluaci\u00f3n mediante proyecto innovador","text":"<p>Dentro de la evaluaci\u00f3n progresiva, aquellos alumnos que deseen realizar un proyecto innovador alternativo que se base en un problema o dise\u00f1o propio (o propuesto por un profesor), pueden hacerlo. Deber\u00e1n hablar con alguno de los profesores de la asignatura y presentarle durante la primera y segunda semana de curso una propuesta de proyecto donde describan, en 2 o 3 p\u00e1ginas:</p> <ul> <li> <p>Objetivos del sistema propuesto.</p> </li> <li> <p>Recursos necesarios para llevarlo a cabo.</p> </li> <li> <p>Arquitecturas HW y SW propuestas para abordar el problema.</p> </li> </ul> <p>Para poder abordar el proyecto ser\u00e1 necesario contar con la aprobaci\u00f3n de dicho profesor. No ser\u00e1 admitido ning\u00fan proyecto (por muy complejo o perfecto que sea) que no se ajuste a estas normas. En el canal de YouTube<sup>1</sup> de la asignatura puede ver v\u00eddeos de proyectos de alumnos en cursos pasados.</p> <p>Solo se aceptar\u00e1n 10 proyectos innovadores. Para poder evaluar las propuestas y que las parejas puedan comenzar a trabajar lo antes posible, disponen de no m\u00e1s de la segunda semana de clase para presentar la propuesta.</p> <p>El proyecto es libre, no obstante ha de cubrir los conceptos b\u00e1sicos de la asignatura con los que se eval\u00faa al resto de compa\u00f1eros:</p> <ul> <li> <p>Deber\u00e1 trabajar con</p> </li> <li> <p>una base del sistema programada en C,</p> </li> <li> <p>donde se demuestre el manejo de registros b\u00e1sicos (parte del programa escrito a bajo nivel: bare-metal),</p> </li> <li> <p>que contenga una o varias FSM, interrupciones, y temporizaci\u00f3n.</p> </li> <li> <p>Metodolog\u00eda de proyecto como la propuesta (divisi\u00f3n de c\u00f3digo en <code>COMMON</code> y <code>PORT</code>).</p> </li> <li> <p>Documentaci\u00f3n del c\u00f3digo con Doxygen.</p> </li> <li> <p>El lenguaje tipo Arduino no est\u00e1 permitido como base del sistema, aunque s\u00ed sobre elementos a\u00f1adidos (otros microcontroladores). Cubierto lo b\u00e1sico en C, puede trabajar sobre el lenguaje que quiera, sea de alto nivel, o no.</p> </li> <li> <p>Cubierto lo anterior, s\u00ed puede hacer uso de la HAL del fabricante.</p> </li> </ul> <p>Note</p> <p>Qui\u00e9n realice un proyecto innovador NO hace la evaluaci\u00f3n individual. En cambio, ha de hacer una entrega intermedia y final del c\u00f3digo y documentaci\u00f3n (mismas fechas que el proyecto est\u00e1ndar), y una demostraci\u00f3n del proyecto en una fecha a convenir a los profesores de la asignatura. En cualquier momento se pueden abandonar y engancharse a la evaluaci\u00f3n global.</p>"},{"location":"notebook/intro.html#evaluacion-global","title":"Evaluaci\u00f3n global","text":"<p>En la modalidad de evaluaci\u00f3n global se han de superar las mismas actividades que en la evaluaci\u00f3n progresiva y tienen los mismos pesos y criterios.</p> <p>El estudiante que no han hecho la entrega de V1-V2 puede optar a un \\(7.5\\), incluyendo V5, siempre que se cumplan los criterios de m\u00ednimos mencionados anteriormente.</p>"},{"location":"notebook/intro.html#insignias","title":"Insignias","text":"<p>En general, las insignias, o badges en ingl\u00e9s, se usan como reconocimiento digital cuando se realiza un curso o una actividad. Constan de una imagen y una descripci\u00f3n con el nombre y los criterios que hay que cumplir para obtenerla, como se muestra en la\u00a0. Sirven para reconocer logros a lo largo del curso. Est\u00e1n firmadas por un profesor y permite al alumno anexarla a su Curriculum Vitae, o almacenarlas en mochilas virtuales como Badgr, u OpenBadges. Puede conocer m\u00e1s sobre las insignias de Moodle UPM en el CanalTIC: Badges o insignias digitales. Puede leer m\u00e1s sobre insignias digitales en el manual \u201cInsignias digitales como acreditaci\u00f3n de competencias en la Universidad\u201d <sup>7</sup>.</p> Contenido de una insignia (\u201cOpen Badges Peeled\u201d de Bryan Mathers, con licencia CC-BY-ND License). <p>Los profesores, bajo criterio consensuado, podr\u00e1n otorgar insignias para reconocer alg\u00fan m\u00e9rito destacable en la asignatura. En concreto, se contemplan las siguientes insignias (ver\u00a0figura de insignias):</p> <ul> <li> <p>Para la evaluaci\u00f3n progresiva y global:</p> </li> <li> <p>Mejor dise\u00f1o HW: electr\u00f3nica adicional, dise\u00f1o de PCB, integraci\u00f3n con otras placas, etc.</p> </li> <li> <p>Mejor dise\u00f1o SW: funcionalidades FW o SW extras que sean significativas.</p> </li> <li> <p>Mejor dise\u00f1o de producto: entendido como un todo, se valorar\u00e1 la experiencia de usuario, acabado con impresi\u00f3n 3D, etc.</p> </li> <li> <p>Proyecto destacado: proyecto que cumple funcionalidades, tiene mejoras considerables, etc.\u00a0y a juicio de los profesores es un proyecto destacable.</p> </li> <li> <p>Para los proyecto innovadores:</p> </li> <li> <p>Todo proyecto innovador que lo merezca.</p> </li> <li> <p>El mejor proyecto innovador.</p> </li> </ul> Insignias del curso."},{"location":"notebook/intro.html#subsec:rubrica","title":"R\u00fabrica de evaluaci\u00f3n","text":"<p>Una r\u00fabrica \u201ces una herramienta de puntuaciones en la que se valora la calidad de un producto (proyecto, tarea, etc.) en base a los criterios establecidos, iguales para todos los estudiantes. Dichos criterios se presentan en distintos grados y se completan seg\u00fan sea el producto evaluado\u201d\u00a0<sup>2</sup>. No espere ver una nota detallada de cada aspecto, sino un grado de consecuci\u00f3n.</p> <p>Para cada \u201cNivel de calidad\u201d de la r\u00fabrica existen procesos intermedios que han de ser superados aunque no queden descritos como tal en la misma. No obstante es una gu\u00eda para que tenga siempre presente los objetivos de grano grueso del proyecto. El profesor puede tener mayor granularidad para evaluar parcialmente un criterio de la r\u00fabrica que no se haya logrado en su completitud. El muestra la r\u00fabrica del proyecto Simone.</p> Nivel de calidad Criterio Malo Regular Excelente V1 - Bot\u00f3n Solo FSM.                 El sistema no hace lo requerido.                               No funciona completamente. No cambia de modo. No gestiona bien los rebotes. No gestiona bien el <code>SysTick</code>.                               Pasa los test, funciona correctamente y est\u00e1 bien documentado.              V2 - Teclado Solo FSM.                 El sistema no hace lo requerido.                               No funciona completamente. No gestiona bien la excitaci\u00f3n de filas. No gestiona bien el input capture de columnas. No recoge bien las teclas.                               Pasa los test, funciona correctamente y est\u00e1 bien documentado.                               V3 - LED RGB Solo FSM.                 El sistema no hace lo requerido.                               No funciona correctamente. No gestiona bien el PWM para mostrar los colores. No se detiene cuando se le indica.                               Pasa los test, funciona correctamente y est\u00e1 bien documentado.              V4 - Bajo consumo Solo FSM completa.                 El sistema no hace lo requerido.                               No se gestionan comandos ON/OFF. No detiene <code>SysTick</code>. Solo duerme una vez o no duerme en todas las situaciones.                               Funciona correctamente y est\u00e1 bien documentado.              Cuadro 1. R\u00fabrica de evaluaci\u00f3n."},{"location":"notebook/intro.html#sec:cal","title":"Calendario","text":"<p>En la\u00a0se muestra el calendario de la asignatura. A la izquierda, los d\u00edas de la semana, se\u00f1alando los eventos m\u00e1s importantes, como las evaluaciones. A la derecha un gr\u00e1fico de colores para ver f\u00e1cilmente qu\u00e9 d\u00edas tiene clase cada turno. Orientativamente, se indica por qu\u00e9 versi\u00f3n del proyecto se deber\u00eda ir cada semana. Aj\u00fastate lo m\u00e1s que puedas, no te conf\u00edes.</p> Calendario de la asignatura. <p>F\u00edjate que, debido a c\u00f3mo es el calendario acad\u00e9mico, hay alteraciones de los turnos que, en algunos casos nos llevan a estar varias semanas sin clase, no te distraigas durante ese tiempo para que no te cueste retomar las sesiones de laboratorio. Todos los turnos tienen el mismo n\u00famero de horas de laboratorio. Las fechas de evaluaci\u00f3n son iguales para todos los turnos.</p> <p>En el curso 2025-26 se ha reducido una semana el semestre. Para mantener el n\u00famero de horas de laboratorio, las 2 sesiones previas a la entrega intermedia y final ser\u00e1n de \\(2h30'\\) en lugar de \\(2h\\).</p> <ol> <li> <p>Canal Youtube de la asignatura: https://www.youtube.com/channel/UCYIw_gl745WMJ1n0MamDzQw/ \u21a9</p> </li> <li> <p>Servicio de Innovaci\u00f3n Educativa de la UPM. Aprendizaje orientado a proyectos. Technical Report, Servicio de Innovaci\u00f3n Educativa de la UPM, 2008.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Comisi\u00f3n del Plan de Estudios. Memoria del t\u00edtulo de graduado en ingenier\u00eda de tecnolog\u00edas y servicios de telecomunicaci\u00f3n. Technical Report, Escuela T\u00e9cnica Superior de Ingenieros de Telecomunicaci\u00f3n, 2014.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Juan Jos\u00e9 G\u00f3mez Valverde. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/88460/.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Amadeo de Gracia Herranz, Sergio Esteban Romero, and Daniel Capell\u00e1n Mart\u00edn. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/92376/.\u00a0\u21a9</p> </li> <li> <p>Consejo de Gobierno. Normativa de evaluaci\u00f3n del aprendizaje en las titulaciones oficiales de grado y m\u00e1ster universitario de la universidad polit\u00e9cnica de madrid. Technical Report, Universidad Polit\u00e9cnica de Madrid, 2022.\u00a0\u21a9</p> </li> <li> <p>Oriol Borr\u00e1s Gen\u00e9. Insignias digitales como acreditaci\u00f3n de competencias en la universidad. \\url https://oa.upm.es/47460/1/Insignias%20digitales%20como%20acreditacion%20de%20competencias%20en%20la%20Universidad.pdf, 2017.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/sesion_introduccion.html","title":"Sesi\u00f3n de introducci\u00f3n","text":""},{"location":"notebook/sesion_introduccion.html#cha:cha2","title":"Sesi\u00f3n de introducci\u00f3n","text":"<p>Bibliograf\u00eda</p> <ul> <li> <p>\"Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>1</sup></p> </li> <li> <p>\"Tutoriales sobre los fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>2</sup></p> </li> <li> <p>\"Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C\u201d <sup>3</sup></p> </li> <li> <p>Datasheet \"STM32F446xC/E\u201d <sup>4</sup></p> </li> <li> <p>Reference manual \"RM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>5</sup></p> </li> <li> <p>\"SISTEMAS DIGITALES I: Pr\u00e1ctica de programaci\u00f3n en C\u201d</p> </li> </ul> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Clase inicial de parpadeo de un LED y manejo de proyecto con MatrixMCU</p> </li> <li> <p>Conceptos b\u00e1sicos de C (canal SDG1)</p> </li> </ul> <p>En tu primera sesi\u00f3n de laboratorio vas a trabajar con los cap\u00edtulos de ejemplo de los tutoriales del libro de la asignatura  \"Tutoriales sobre los fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>2</sup>.</p> <p>Empezar\u00e1s por el proyecto Blink donde aprender\u00e1s a configurar un proyecto para compilaci\u00f3n cruzada sobre la placa Nucleo-STM32F446RE. Luego contin\u00faa con los otros tutoriales para familiarizarte con las m\u00e1quinas de estado. Si no te da tiempo, ac\u00e1balos en casa, porque gran parte del c\u00f3digo que ah\u00ed realices te servir\u00e1 para el desarrollo del proyecto. De hecho, constituyen casi en su completitud (aunque no en forma), la versi\u00f3n 1 del sistema. Adem\u00e1s, te servir\u00e1 para familiarizarte con el entorno.</p> <p>Posteriormente, en casa, te vendr\u00e1 bien ver los v\u00eddeos recomendados de SDG1. Tanto los documentos como los v\u00eddeos es importante que los tengas siempre a mano, pues tratan de conceptos fundamentales.</p> <p>IMPORTANTE</p> <p>Ve este v\u0131\u0301deo-tutorial donde se explica c\u00f3mo manejar el LED de la placa y a\u00f1adir uno nuevo. En \u00e9l se explica en detalle c\u00f3mo elegir y configurar las GPIO bas\u00e1ndose en la documentaci\u00f3n disponible MatrixMCU Blink LED y manejo de proyecto.</p> <p>El libro de Fundamentos te\u00f3ricos <sup>1</sup> no es precisamente un libro de cabecera, pero lea los cap\u00edtulos, y aquellas partes m\u00e1s densas en las que se habla de especificidades de registros, oj\u00e9alas, para tenerlas ubicadas cuando las necesites. Esos tiempos muertos en el transporte p\u00fablico son buenos momentos para leerlo y entender qu\u00e9 partes forman la placa Nucleo-STM32, repasar de SDG1 qu\u00e9 son los modos de bajo consumo, qu\u00e9 es un reloj\u2026 \ud83d\ude00</p> <p>Para trabajar en casa sigue el Cap\u00edtulo \"Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n cruzada en C\u201d de la gu\u00eda\u00a0<sup>3</sup> o ve el v\u00eddeo [MatrixMCU] Gu\u00eda de instalaci\u00f3n toolkit MatrixMCU en YouTube. No obstante, alguno de los pasos del v\u00eddeo puede que los tengas completados de la instalaci\u00f3n de SDG1. Rep\u00e1salo igualmente.</p> <p>Esperemos que disfrutes y aprendas.</p> <p>\u00a1Adelante!</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Juan Jos\u00e9 G\u00f3mez Valverde. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/88460/.\u00a0\u21a9\u21a9</p> </li> <li> <p>Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Josu\u00e9 Pag\u00e1n Ortiz, Alberto Bosc\u00e1 Mojena, Iv\u00e1n Mart\u00edn Fern\u00e1ndez, and Sergio Esteban Romero. Tutoriales sobre los fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Rom\u00e1n C\u00e1rdenas Rodriguez, Madrid, March 2025. URL: https://oa.upm.es/88470/.\u00a0\u21a9\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Amadeo de Gracia Herranz, Sergio Esteban Romero, and Daniel Capell\u00e1n Mart\u00edn. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/92376/.\u00a0\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_0.html","title":"Versi\u00f3n 0","text":""},{"location":"notebook/version_0.html#cha:peoyecto_base","title":"Versi\u00f3n 0 y funciones de sistema","text":"<p>Antes de arrancar con la versi\u00f3n <code>V1</code> del sistema, tenemos que manejarnos con el versi\u00f3n 0. En esta configuraci\u00f3n inicial vamos a programar una serie de funciones gen\u00e9ricas que se usar\u00e1n a lo largo de todo el proyecto. Esta parte, junto con la versi\u00f3n <code>V1</code> tiene un desarrollo estimado en unas 2-3 semanas. El inicio del proyecto tiene una curva de aprendizaje mayor; por eso, se te va a guiar en los pasos y la explicaci\u00f3n ser\u00e1 m\u00e1s extensa. Al acabar este cap\u00edtulo tendr\u00e1s listas algunas de las funciones base del proyecto Simone.</p> <p>Debes tener a mano en todo momento los documentos referenciados y ver los v\u00eddeos sugeridos a fin de entender mejor c\u00f3mo tiene que escribir el c\u00f3digo o realizar montajes.</p> <p>Bibliograf\u00eda</p> <ol> <li> <p>Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32 <sup>4</sup></p> </li> <li> <p>Datasheet \u201cSTM32F446xC/E\u201d <sup>5</sup></p> </li> <li> <p>Reference manual \u201cRM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>6</sup></p> </li> <li> <p>SISTEMAS DIGITALES I: Pr\u00e1ctica de programaci\u00f3n en C</p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>[MatrixMCU - examples] Blink LED y manejo de proyecto</p> </li> <li> <p>[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen</p> </li> </ul>"},{"location":"notebook/version_0.html#version-0-simone","title":"Versi\u00f3n 0: Simone","text":"<p>En esta secci\u00f3n se muestra el esquema general del sistema, y se presenta c\u00f3mo has de configurar el proyecto en VSCode.</p> Diagrama de elementos del sistema. <p>Nuestro sistema base versiona el cl\u00e1sico juego de los 80's, Simon. Cuando se presiona el bot\u00f3n de usuario (el azul) durante un tiempo indica que se quiere encender, o apagar, el juego. En ese instante el sistema central encender\u00e1 el RGB light (LED RGB) con la primera secuencia del juego en en nivel f\u00e1cil (<code>LEVEL_EASY</code>). Cuando acaba de reproducirse (playback) la secuencia, se activa la excitaci\u00f3n de las filas del teclado matricial (4x4) de forma iterativa, y se duerme para esperar una interrupci\u00f3n en alguna de las columnas. Cuando se detecta una pulsaci\u00f3n, se comprueba si es la correcta. Si lo es, se vuelve a reproducir la secuencia con un nuevo paso a\u00f1adido. Si no lo es, se enciende el RGB light en rojo para indicar el fallo, y se vuelve a empezar desde el principio. Si se pulsa el bot\u00f3n de usuario durante un tiempo largo, el sistema se apaga. Ve el video demostrativo en Demostraci\u00f3n del sistema Simone. La figura del diagrama muestra los 4 bloques que conforman el sistema:</p> <ol> <li> <p>El sistema central con la placa Nucleo-STM32 aloja el microcontrolador STM32F446RE. Se encarga de gestionar, el encendido y apagado del sistema Simone, de interpretar las pulsaciones del usuario.</p> </li> <li> <p>La placa Nucleo-STM32\u00a0tambi\u00e9n tiene el bot\u00f3n de usuario <code>B1</code>, y el LED de usuario <code>LD2</code>. Estos conforman el sub-sistema de control b\u00e1sico. El bot\u00f3n se usar\u00e1 para detectar pulsaciones que el sistema central interpretar\u00e1 para cambiar encender/\u00a0apagar, u otras implementaciones que el quieras hacer en Versi\u00f3n 5. El LED de la placa podr\u00e1 usarse para saber si hemos realizado correctamente una operaci\u00f3n, a modo de feedback.</p> </li> <li> <p>El teclado matricial. Representa a un dispositivo HW que permite al usuario interactuar con el sistema. En este caso, el teclado matricial es de \\(4\\times4\\) teclas, y se usar\u00e1 para que el usuario introduzca la secuencia que el sistema le va indicando. Se trata de un teclado matricial de membrana en el que se excitan las filas y se ir\u00e1n leyendo las columnas para identificar qu\u00e9 tecla se ha pulsado.</p> </li> <li> <p>El m\u00f3dulo de actuaci\u00f3n. El RGB light est\u00e1 compuesto por un LED RGB que se encender\u00e1 en funci\u00f3n de la secuencia que toque reproducir en el juego, y para dar feedback al jugador de la tecla que ha pulsado.</p> </li> </ol>"},{"location":"notebook/version_0.html#proyecto-simone-en-vscode","title":"Proyecto Simone en VSCode","text":"<p>Vamos a ir construyendo el proyecto poco a poco. En esta primera fase/versi\u00f3n V1 construiremos parte del sistema central y el sub-sistema de control de encendido/\u00a0apagado. Se proporciona la estructura del proyecto sobre el que: desarrollaremos (i) las funciones b\u00e1sicas del sistema para gesti\u00f3n de las GPIO, (ii) la FSM del bot\u00f3n y para el cambio de encendido/ apagado, (iii) testearemos su funcionamiento y, en todo momento documentaremos el c\u00f3digo. Para empezar a trabajar con el proyecto:</p> <ol> <li> <p>Se asume que has hecho la primera sesi\u00f3n de introducci\u00f3n y tienes ya montada la estructura para programaci\u00f3n multiplataforma con el proyecto project_template.</p> <p>Si est\u00e1s trabajando en su ordenador, sigue los pasos para tener el entorno como indica la Gu\u00eda de instalaci\u00f3n\u00a0<sup>7</sup>.</p> </li> <li> <p>Si ya tenemos todo configurado es suficiente con descargar \u2014o clonar, si vas a trabajar con Git\u2014 del repositorio GitHub de la asignatura el versi\u00f3n 0 Simone: https://github.com/sdg2DieUpm/simone, y dejarlo en la carpeta \u201cprojects\u201d de la estructura de directorios MatrixMCU.</p> <p>Deber\u00e1 tener una estructura de directorios como la de la figura de \u00e1rbol de directorios:</p> </li> </ol> \u00c1rbol de directorios tras descargar el proyecto Simone. <p>Note</p> <p>Los puestos del laboratorio utilizan Windows 10. A priori no deber\u0131\u0301a haber conflicto con la configuraci\u00f3n del proyecto en VSCode entre m\u00e1quinas. No obstante, puedes trabajar con tu port\u00e1til en el laboratorio si te es m\u00e1s c\u00f3modo que llevar y traer el c\u00f3digo cada d\u0131\u0301a. S\u0131\u0301 es obligatorio que traigas tu placa Nucleo-STM32 y el HW necesario.</p> <ol> <li> <p>Abre <code>VSCode</code> y abre el proyecto <code>Simone</code> que est\u00e1 en la carpeta <code>projects</code>. Es muy importante que solo abras esa carpeta, \u00a1no toda la carpeta <code>projects</code>!. Tiene que ver en <code>VSCode</code> algo como lo que se muestra en la figura del proyecto en VSCode.</p> </li> <li> <p>Conviene que, si no lo has hecho ya, leas el cap\u00edtulo \u201cDesarrollando para Nucleo-STM32\u201d <sup>4</sup> y te familiarices con la estructura de proyecto y los conceptos.</p> </li> </ol> Proyecto Simone en VSCode. <p>Ver\u00e1s que el proyecto ya tiene algunos ficheros de partida. Los ficheros de cabecera (<code>.h</code>) definen nuevos tipos de variable, contienen <code>#define</code>, hacen <code>#include</code> de otros ficheros, y declaran variables. Si abres los ficheros <code>port_system.h</code> (ver figura) o <code>stm32f4_system.h</code> ver\u00e1s que son muy verbosos; casi todo son l\u00edneas de comentario. La gran mayor\u00eda son l\u00edneas de comentario interpretables por el generador de documentaci\u00f3n Doxygen. Esto se ha hecho as\u00ed para que puedas desarrollar el c\u00f3digo bas\u00e1ndote en la API disponible en la p\u00e1gina de GitHub Pages: https://sdg2dieupm.github.io/simone/. Tendr\u00e1s que tener esta p\u00e1gina siempre a mano<sup>1</sup>. Solo tiene algunos ficheros con ejemplo de documentaci\u00f3n Doxygen; t\u00fa tendr\u00e1s que completar el de cada funci\u00f3n que desarrolles fij\u00e1ndote en los <code>TODO alumnos</code> de las descripciones de funci\u00f3n. M\u00e1s adelante se te indicar\u00e1 c\u00f3mo utilizarla.</p> <p>En la carpeta <code>common</code> ver\u00e1s que hay dos ficheros <code>header.h</code> y <code>source.c</code> que indican que han de ser borrados. Est\u00e1n ah\u00ed para que veas c\u00f3mo se estructura del proyecto completo. B\u00f3rralos cuando a\u00f1adas los ficheros de la Versi\u00f3n V1.</p> Documentaci\u00f3n de una funci\u00f3n con Doxygen para generar la API. <p>Podemos empezar ahora con la gesti\u00f3n de las funciones b\u00e1sicas del sistema y las de acceso a las GPIO. En las siguientes secciones vamos a ver (i) un conjunto de funciones gen\u00e9ricas de sistema, (ii) a desarrollar alguna funci\u00f3n relacionada con la temporizaci\u00f3n del sistema, y (iii) funciones de configuraci\u00f3n y manejo de las GPIO. F\u00edjate que dividimos por puntos enumerados las acciones a realizar. Ten esto en cuenta para llevar un orden y no perderse.</p>"},{"location":"notebook/version_0.html#funciones-de-inicializacion-del-sistema","title":"Funciones de inicializaci\u00f3n del sistema","text":"<p>Como se comenta en el cap\u00edtulo \u201cArranque del sistema\u201d del libro de \u201cFundamentos pr\u00e1cticos\u201d <sup>4</sup>, antes de ir a la funci\u00f3n <code>main()</code> el microcontrolador debe realizar el boot del sistema. En dicho cap\u00edtulo se indica que una de las cosas que hace antes es llamar a la funci\u00f3n <code>SystemInit()</code>. Lea dicho cap\u00edtulo del libro.</p> <p>Las funciones de inicializaci\u00f3n no son evidentes y realizan muchas configuraciones de bajo nivel. Se te proporcionan ya codificadas. Todas se encuentran en el fichero <code>stm32f4_system.c</code>. Estas son:</p> <ul> <li> <p><code>SystemInit()</code>: es llamada directamente por <code>Reset_Handler</code> del fichero <code>startup_stm32f446xx.s</code>. En nuestra implementaci\u00f3n, inicializa la FPU (si se usa), configura la memoria externa (si la hay), re-coloca la tabla de vectores de interrupci\u00f3n (si es que la modificamos). En nuestro caso, ninguna de estas tres configuraciones se da.</p> </li> <li> <p><code>port_system_init()</code>: IMPORTANTE esta llamada debemos hacerla nosotros al inicio del programa antes de configurar cualquier perif\u00e9rico. Si no la hacemos, no funcionar\u00e1 nada que tenga que ver con el HW. Esta funci\u00f3n inicializa los perif\u00e9ricos, la memoria flash y llama a la funci\u00f3n de configuraci\u00f3n del reloj <code>system_clock_config()</code>.</p> </li> <li> <p><code>system_clock_config()</code>: IMPORTANTE esta funci\u00f3n, por seguridad, no puede ser accedida desde el exterior por lo que su declaraci\u00f3n no est\u00e1 en <code>port_system.h</code>, para que no la pueda encontrar nadie. Esta funci\u00f3n inicializa el oscilador interno <code>HSI</code> a \\(16 MHz\\) (valor puesto en el <code>#define HSI_VALUE</code>). Esta funci\u00f3n tambi\u00e9n gestiona la alimentaci\u00f3n y configura el temporizador de sistema <code>SysTick</code> a \\(1 ms\\).</p> </li> </ul>"},{"location":"notebook/version_0.html#referencia-temporal-del-sistema-systick","title":"Referencia temporal del sistema: SysTick","text":"<p>En esta secci\u00f3n vamos a hablar de las funciones:</p> <ul> <li> <p><code>port_system_delay_ms()</code></p> </li> <li> <p><code>port_system_delay_until_ms()</code></p> </li> <li> <p><code>port_system_get_millis()</code></p> </li> <li> <p><code>port_system_set_millis()</code></p> </li> </ul> <p>Y de la ISR del temporizador del sistema o <code>SysTick</code>:</p> <ul> <li><code>SysTick_Handler()</code></li> </ul> <p>El <code>SysTick</code> es el temporizador de referencia del sistema. Como se ha mencionado, est\u00e1 ya configurado para que genere una interrupci\u00f3n interna cada \\(1 ms\\). Nosotros debemos decidir qu\u00e9 hacer cada vez que se genere dicha interrupci\u00f3n. En nuestro caso queremos tener una variable que lleve la cuenta de las veces que se ha interrumpido cada \\(1 ms\\). Es lo que vamos a ver en esta secci\u00f3n.</p> <p>Conforme est\u00e1 el proyecto Simone descargado, si lo compilamos, no te dar\u00e1 errores, pero no funciona. Posteriormente, completaremos algunos detalles que faltan, aunque intercalaremos con la explicaci\u00f3n del c\u00f3digo en este cap\u00edtulo.</p> <ol> <li> <p>Compila el c\u00f3digo. Lo podemos hacer de varias maneras. T\u00edpicamente, lo haremos en depuraci\u00f3n, con la placa conectada, pero por ahora, podemos construir los binarios sin necesidad de la placa. En este orden:</p> <ol> <li> <p>Primero generamos las reglas de compilaci\u00f3n con <code>CMake</code>: Men\u00fa <code>Terminal\u2192 Run Task... \u2192 Run CMake \u2192 stm32f446re (Default) \u2192 Release (Default)</code></p> <p>Esto generar\u00e1 las carpetas <code>build/Release/</code> con todas las reglas de compilaci\u00f3n.</p> <p>Si no vas a trabajar en modo depuraci\u00f3n, es necesario que generes las reglas de compilaci\u00f3n en modo <code>Release</code> cada vez que a\u00f1adas un fichero al proyecto. Si trabajas en modo depuraci\u00f3n, no es necesario, se hace autom\u00e1ticamente tras el Clean.</p> </li> <li> <p>Seguidamente, compilamos el c\u00f3digo: Men\u00fa <code>Terminal\u2192 Run Task... \u2192 Build \u2192 stm32f446re (Default) \u2192 Release (Default) \u2192 main</code></p> </li> </ol> </li> </ol> <p>Note</p> <p>El modo <code>Release</code> se usa cuando queremos generar los ficheros binarios que se ejecutar\u00e1n en el dispositivo, pero no queremos depurar. Se usa t\u00edpicamente cuando no tenemos la placa o cuando se genera el c\u00f3digo final de un proyecto que pasa a producci\u00f3n. </p> <p>El modo <code>Debug</code> se usa cuando queremos depurar el c\u00f3digo, y necesitamos tener el dispositivo conectado. En este caso, el compilador a\u00f1ade informaci\u00f3n extra al c\u00f3digo para que el depurador pueda seguir el c\u00f3digo l\u00ednea a l\u00ednea. Esto hace que el c\u00f3digo sea m\u00e1s lento y ocupe m\u00e1s memoria. En el modo <code>Release</code> no se a\u00f1ade esta informaci\u00f3n extra. Normalmente trabajar\u00e1s en modo <code>Debug</code>.</p> <p>En el fichero <code>stm32f4_system.c</code>, tenemos la variable global <code>msTicks</code>. <code>msTicks</code> es una variable muy importante que hemos definido para llevar la cuenta (ticks) en milisegundos del sistema, y est\u00e1 controlado por <code>SysTick</code> (ver cap\u00edtulo de \u201cCircuito de reloj\u201d del libro de Fundamentos Te\u00f3ricos\u00a0<sup>4</sup>). El valor guardado en <code>msTicks</code> se actualiza cada vez que el reloj de sistema <code>SysTick</code> genera una interrupci\u00f3n. Puesto que las interrupciones podemos deshabilitarlas \u2014como en los modos de bajo consumo\u2014, el valor almacenado NO ser\u00e1 un valor absoluto desde que se inici\u00f3 el sistema, sino un valor que podremos tener en cuenta de forma relativa para contar lapsos de tiempo. Trabajaremos con esta variable en las siguientes secciones.</p>"},{"location":"notebook/version_0.html#par:system_delay_ms","title":"Funci\u00f3n <code>port_system_delay_ms</code>","text":"<p>La funci\u00f3n <code>port_system_delay_ms</code> nos podr\u00eda ser de ayuda en alg\u00fan momento. Como dice la API, esta funci\u00f3n hace una espera activa durante <code>ms</code> milisegundos, i.e., el programa se bloquea en el <code>while{}</code> que no hace nada durante un tiempo dado. Esta funci\u00f3n, para saber cu\u00e1ntos milisegundos han pasado, necesita hacer la resta entre el instante actual y la referencia que coge al inicio <code>tickstart</code>.</p> <p>\u00bfC\u00f3mo sabemos cu\u00e1l es el instante actual? Pues con el valor de la variable global <code>msTicks</code>. Esta variable es global y est\u00e1tica (<code>static uint32_t msTicks</code>), por lo que es accesible por todas las funciones de este fichero solo<sup>2</sup>. Esta \"librer\u00eda\" de sistema <code>stm32f4_system.c</code> ha de proporcionar al resto del c\u00f3digo diversas funcionalidades, y una de ellas es la de dar informaci\u00f3n del tiempo de sistema <code>msTicks</code>. Para ello \u2014y puesto que la variable no es accesible desde el exterior por ser est\u00e1tica\u2014, nos proporciona la funci\u00f3n <code>port_system_get_millis()</code>.</p>"},{"location":"notebook/version_0.html#par:system_delay_until","title":"Funci\u00f3n <code>port_system_delay_until_ms</code>","text":"<p>La funci\u00f3n <code>port_system_delay_until_ms()</code> recibe la referencia del tiempo actual y hace una espera activa hasta <code>ms</code> despu\u00e9s. Nos puede ser tambi\u00e9n de utilidad durante el proyecto. Esta funci\u00f3n toma la referencia de tiempos llamando a <code>port_system_get_millis()</code>.</p>"},{"location":"notebook/version_0.html#par:system_get_millis","title":"Funci\u00f3n <code>port_system_get_millis</code>","text":"<p>La funci\u00f3n <code>port_system_get_millis()</code> est\u00e1 declarada en <code>port_system.h</code> y, aunque est\u00e1 implementada, no hace nada. Seg\u00fan la API, dicha funci\u00f3n simplemente devuelve la cuenta del sistema en milisegundos. Sabemos que ha de devolver un entero de 32 bits sin signo (<code>uint32_t</code>), es decir, tenemos que devolver el valor de la variable <code>msTicks</code>. As\u00ed pues, modifique la funci\u00f3n para que quede como:</p> <pre><code>uint32_t port_system_get_millis()\n{\n    return msTicks; /* ms */\n}    \n</code></pre> <p>y como ya est\u00e1 documentada la funci\u00f3n en el <code>.h</code>, no tenemos que poner la documentaci\u00f3n Doxygen aqu\u00ed.</p>"},{"location":"notebook/version_0.html#par:system_set_millis","title":"Funci\u00f3n <code>port_system_set_millis</code>","text":"<p>En casi todos los lenguajes de programaci\u00f3n, cuando una librer\u00eda nos proporcione una funci\u00f3n get que devuelve un par\u00e1metro encontraremos, t\u00edpicamente, un set, para poder modificar dicho par\u00e1metro. As\u00ed pues, encontramos la funci\u00f3n <code>port_system_set_millis()</code>.</p> <p>Esta funci\u00f3n tambi\u00e9n est\u00e1 declarada en <code>port_system.h</code> e implementada, pero sin desarrollar. Seg\u00fan la API, dicha funci\u00f3n simplemente recibe la cuenta del sistema en milisegundos que queremos poner. \u00bfPor qu\u00e9 \u00edbamos a querer modificar la cuenta de tiempos del sistema? Bueno, nuestra aplicaci\u00f3n podr\u00eda tener alg\u00fan criterio relacionado con ello, pero esta funci\u00f3n existe porque es la que la ISR usa para modificar el contador <code>msTicks</code>. Ya que la ISR est\u00e1 en otro fichero (el fichero <code>interr.c</code>) y no tiene acceso al contador, ha de hacerlo llamado a una funci\u00f3n de <code>stm32f4_system.c</code> que s\u00ed pueda acceder; esta es nuestra funci\u00f3n <code>port_system_set_millis()</code>.</p> <p>Vamos a completarla:</p> <pre><code>void port_system_set_millis(uint32_t ms)\n{\n    msTicks = ms;\n}\n</code></pre> <p>Note</p> <p>En este punto te habr\u00e1s dado cuenta que hay funciones que empiezan por \"<code>port_system_</code>\u201d. Esto es una convenci\u00f3n de nomenclatura, un estilo. Si seguimos un criterio, nos puede ser f\u00e1cil identificar de d\u00f3nde vienen las funciones y qu\u00e9 hacen solo con su nombre. Estas en particular, nos indican que las funciones son \"portables\" (<code>port_</code>) \u2014por lo que estar\u00e1n en el directorio <code>port</code>, y no en el <code>common</code>\u2014, y que son funciones centrales del sistema (<code>system</code>, por abreviar). </p> <p>Como reciben y/\u00a0o devuelven variables est\u00e1ndar (<code>uint32_t</code>, <code>void</code>, \u2026), no tienen nada que ver con el microcontrolador en particular, est\u00e1n en declaradas en los ficheros <code>.h</code> de <code>port/include</code>, pero su implementaci\u00f3n est\u00e1 en <code>stm32f4_system.c</code> en <code>stm32f4/src</code>. Si tuvi\u00e9semos otro microcontrolador, podr\u00edamos reutilizar estas funciones sin modificar el prototipo y solo cambiando la implementaci\u00f3n. </p> <p>Se seguir\u00e1 un cierto estilo a la hora de programar. Se recomienda ojear el libro de estilo \u201cEmbedded C Coding Standard\u201d <sup>8</sup>. El libro es distribuido gratuitamente por los autores en https://barrgroup.com/sites/default/files/barr_c_coding_standard_2018.pdf. Accedido: 2026-01-18.</p>"},{"location":"notebook/version_0.html#par:systick_handler","title":"Funci\u00f3n <code>SysTick_Handler</code>","text":"<p><code>msTicks</code> est\u00e1 definida y se usa cuando se llama a las funciones <code>port_system_set_millis()</code> para darle un valor, y <code>port_system_get_millis()</code> para leerlo, pero \u00bfqui\u00e9n llama a estas funciones para actualizar el valor de <code>msTicks</code>? Bueno, estrictamente nadie las llama, saltan ah\u00ed por hardware, pues es la ISR del <code>SysTick</code>. Vamos a ver c\u00f3mo funciona y a completarla.</p> <p>En el documento <code>interr.c</code> encontrar\u00e1s la ISR del <code>SysTick</code>, <code>SysTick_Handler</code>. Recuerda que este nombre no lo elegimos nosotros, sino que est\u00e1 definido en el fichero de ensamblador de cada dispositivo; <code>startup_stm32f446xx.s</code> para el microcontrolador STM32F446RE. Dentro de la ISR vamos a usar las funciones <code>port_system_get_millis()</code> y <code>port_system_set_millis()</code> para leer y escribir el valor de <code>msTicks</code>.</p> <ol> <li> <p>Llama a la funci\u00f3n <code>port_system_get_millis()</code> en la ISR <code>SysTick_Handler()</code> para leer el valor actual de <code>msTicks</code> y gu\u00e1rdalo en una variable local. No olvides declarar la variable.</p> </li> <li> <p>Llama a la funci\u00f3n <code>port_system_set_millis()</code> en la ISR <code>SysTick_Handler()</code> para escribir el valor de <code>msTicks</code> con el valor anterior incrementado en 1.</p> </li> </ol> <p>Ya tenemos hecho el punto <code>1</code> de la ISR <code>SysTick_Handler()</code> (ver figura de la API), y que estaba pendiente de hacer (<code>TODO alumnos</code>).</p> Vista de la API para la ISR `SysTick_Handler`. <p>Podemos comprobar que el programa sigue compilando correctamente y viendo que se ha generado el fichero ejecutable <code>.elf</code> en la carpeta <code>bin</code>, donde se guardan los binarios generados a ejecutar por el microcontrolador. Tendremos un mensaje en la terminal similar al que se muestra en la figura de compilaci\u00f3n.</p> Compilaci\u00f3n exitosa generando el ejecutable `.elf`."},{"location":"notebook/version_0.html#sec:sys_gpio","title":"Configuraci\u00f3n y manejo de GPIOs","text":"<p>En esta secci\u00f3n vamos a comprender el c\u00f3digo de las funciones de configuraci\u00f3n y manejo de las GPIOs y a completar algunas de ellas. Con estas funciones conseguiremos inicializar el modo (i.e., entrada, salida, o alternativo) de cada pin de la GPIO, configurar interrupciones, y leer y escribir en los puertos.</p> <p>Es muy importante que tengas a mano el cap\u00edtulo \u201cConfiguraci\u00f3n de GPIOs\u201d del libro de \u201cFundamentos te\u00f3ricos\u201d <sup>4</sup>. En esta secci\u00f3n vamos a trabajar con registros. Todo lo que vamos a ver es un repaso de lo que tiene ya en los ejemplos del libro, pero debes asegurarte de entender lo que hace y saber leer las tablas que en \u00e9l se muestran. No se te va a pedir manejar el reference manual ni el datasheet del microcontrolador, aunque tambi\u00e9n puedes mirar en ellos si quieres m\u00e1s detalle sobre los registros.</p> <p>A lo largo del proyecto vamos a configurar varias GPIOs, como las del bot\u00f3n, el teclado, o los LED. As\u00ed, para no hacer el c\u00f3digo repetitivo, se proporcionan funciones gen\u00e9ricas que reciben como entrada, al menos, el puerto y el pin que quieren configurar. Para ver las funciones sit\u00faate en el fichero <code>stm32f4_system.c</code>, bajo el comentario <code>// GPIO RELATED FUNCTIONS</code>. La lista de funciones que se proporcionan y que vamos a ver es:</p> <ul> <li> <p><code>stm32f4_system_gpio_config()</code></p> </li> <li> <p><code>stm32f4_system_gpio_config_alternate()</code></p> </li> <li> <p><code>stm32f4_system_gpio_config_exti()</code></p> </li> <li> <p><code>stm32f4_system_gpio_exti_enable()</code></p> </li> <li> <p><code>stm32f4_system_gpio_exti_disable()</code></p> </li> </ul> <p>Adem\u00e1s, por otro lado vas a tener que implementar las funciones de lectura, escritura y toggle de las GPIOs**. Son:</p> <ul> <li> <p><code>stm32f4_system_gpio_read()</code></p> </li> <li> <p><code>stm32f4_system_gpio_write()</code></p> </li> <li> <p><code>stm32f4_system_gpio_toggle()</code></p> </li> </ul> <p>Note</p> <p>\u00bfPor qu\u00e9 las funciones ahora se llaman <code>stm32f4_system_gpio\\_...</code> y no <code>port_system_gpio\\_...</code>? Porque estas funciones reciben y devuelven tipos de datos (estructuras, punteros, \u2026) que son espec\u00edficas del microcontrolador STM32F446RE, y no son portables a otros microcontroladores. Por eso, est\u00e1n declaradas en el fichero <code>stm32f4/include/stm32f4_system.h</code> y no en <code>port/include/port_system.h</code>. Si tuvi\u00e9semos otro microcontrolador, tendr\u00edamos que incluirla en su carpeta correspondiente y adaptar el prototipo de la funci\u00f3n.</p>"},{"location":"notebook/version_0.html#par:gpio_config","title":"Funci\u00f3n <code>stm32f4_system_gpio_config</code>","text":"<p>Esta funci\u00f3n configura el modo de la GPIO: entrada, salida o funci\u00f3n alternativa, y el tipo de conexi\u00f3n a la que est\u00e1 el pin (conectada a resistencias de pull-up, o de pull-down). Sirva este primer punto para establecer las bases de c\u00f3mo se codifican las funciones. Tengamos a mano la entrada de la API. La figura muestra la descripci\u00f3n de la anatom\u00eda de una entrada de la API.</p> Vista de la API para la funci\u00f3n `stm32f4_system_gpio_config`. <p>Como dice el punto <code>1</code> de la API, lo primero que se hace es habilitar el reloj de las GPIO. Esto se indica en los ejemplos del cap\u00edtulo \u201cConfiguraci\u00f3n de GPIOs\u201d del libro como:</p> <pre><code>RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; /* GPIOA clock enable */\n</code></pre> <p>Esta l\u00ednea de c\u00f3digo activa el bit <code>RCC_AHB1ENR_GPIOAEN</code> (GPIOA) del registro <code>RCC_AHB1ENR</code>. Vamos por partes:</p> <ul> <li> <p>El RCC es el controlador de relojes. En el fichero <code>stm32f4xx.h</code><sup>3</sup>, CMSIS lo define como un puntero a una estructura de tipo <code>RCC_TypeDef</code>: . Esta estructura tambi\u00e9n la define CMSIS en el mismo fichero. Tiene muchos campos. Cada campo es un registro del controlador. Bien, pues uno de esos registros es el <code>RCC_AHB1ENR</code>.</p> </li> <li> <p>Recuerda de los v\u00eddeos de SDG1 que para acceder a los campos de una estructura tenemos el punto (<code>.</code>), y la flecha (<code>-&gt;</code>). Usamos punto (<code>.</code>) cuando tenemos acceso directo a la estructura, y usamos flecha (<code>-&gt;</code>) cuando lo que tenemos es un acceso indirecto, un puntero. Esta es nuestra situaci\u00f3n, porque <code>RCC</code> est\u00e1 definido como puntero, y por eso, para acceder al campo que representa al registro hacemos: <code>RCC-&gt;AHB1ENR</code>.</p> <p>Aplica toda esta l\u00f3gica para cualquier registro. Todos est\u00e1n definidos por CMSIS en el fichero <code>stm32f4xx.h</code>, y todos son punteros, por lo que siempre accederemos a los registros de los perif\u00e9ricos con <code>-&gt;</code> (flecha).</p> </li> <li> <p>El fabricante nos indica en el manual de referencia que el acceso a los registros se hace, generalmente, de 32 en 32 bits por lo que no se pueden seleccionar bits particulares de un registro \u2014como indica el libro en un ejemplo\u2014, por eso usamos m\u00e1scaras, en este caso con el operador <code>|</code> (<code>OR</code>) sobre todo el registro para activar el/los bit/s deseado/s.</p> </li> <li> <p>El <code>RCC_AHB1ENR_GPIOAEN</code> es una m\u00e1scara que est\u00e1 definida en <code>stm32f4xx.h</code>, y vale <code>0x01</code>. Gran parte de los bits de los registros, si no todos, est\u00e1n definidos en este fichero. Para cualquier registro, t\u00fa puedes decidir usarlos, o definirte tus propias m\u00e1scaras si te es m\u00e1s c\u00f3modo.</p> </li> </ul> <p>Ya estamos preparados para ver qu\u00e9 hacen las funciones. Conviene que prestes atenci\u00f3n al c\u00f3digo y a las explicaciones aqu\u00ed dadas, pues te ayudar\u00e1 en las pr\u00f3ximas versiones del proyecto. De igual modo, no dejes de leer el cap\u00edtulo \u201cConfiguraci\u00f3n de GPIOs\u201d del libro de \u201cFundamentos te\u00f3ricos\u201d <sup>4</sup>, ni de ver el v\u00eddeo [MatrixMCU - examples] Blink LED y manejo de proyecto.</p> <ol> <li> <p>En el fichero <code>stm32f4_system.h</code> encontramos el prototipo de la funci\u00f3n. En el fichero <code>stm32f4_system.c</code> encontramos su implementaci\u00f3n.</p> </li> <li> <p>Dentro de la funci\u00f3n vemos que el c\u00f3digo activa el bit <code>RCC_AHB1ENR_GPIOAEN</code>, <code>RCC_AHB1ENR_GPIOBEN</code>, o <code>RCC_AHB1ENR_GPIOCEN</code>, en funci\u00f3n de si el valor de <code>port</code> es <code>GPIOA</code>, <code>GPIOB</code>, o <code>GPIOC</code>, respectivamente. Esto completa el primer punto de la API.</p> <p>El pinout de Arduino no da acceso a ning\u00fan pin que no sea de estos tres puertos. El pinout de Morpho s\u00ed da acceso a algunos del <code>GPIOH</code>, y uno del <code>GPIOD</code>. Si en tus implementaciones de la Versi\u00f3n 5 vas a utilizar alguno de estos pines, necesitar\u00e1s incluirlos en esta funci\u00f3n de configuraci\u00f3n. Mira la secci\u00f3n \u201cConectores y z\u00f3calos de la placa\u201d para confirmarlo.</p> </li> <li> <p>Se configura el modo del puerto (registro <code>MODER</code>) como se hace en la secci\u00f3n \u201cGPIO port mode register (GPIOx_ MODER)\u201d del libro.</p> <ul> <li> <p>Limpia lo que hubiese escrito en las posiciones del registro <code>MODER</code> con la m\u00e1scara creada.</p> <p>Se usa la m\u00e1scara base <code>GPIO_MODER_MODER0</code> definida por CMSIS en el fichero <code>stm32f446xx.h</code>. Esta m\u00e1scara vale <code>0x03UL</code>, i.e., <code>0b11</code> en binario, unsigned (<code>U</code>, no tiene signo), long (<code>L</code>, de 32 bits). Es muy \u00fatil usar estas m\u00e1scaras base para limpiar los bits de los registros.</p> <p>Para limpiar los bits de un registro o variable, se hace una <code>AND</code> (&amp;) con la m\u00e1scara negada.</p> </li> <li> <p>Escribe en el registro de modo el valor de la variable <code>mode</code> \u2014que es el argumento recibido y podr\u00e1 tomar valores <code>STM32F4_GPIO_MODE_IN</code>\u2014 <code>STM32F4_GPIO_MODE_OUT</code>, <code>STM32F4_GPIO_MODE_AF</code>, o <code>STM32F4_GPIO_MODE_AN</code>. Estos son los valores que se han definido en el fichero <code>stm32f4_system.h</code>, y que valen <code>0x00</code>, <code>0x01</code>, <code>0x02</code>, y <code>0x03</code>, respectivamente.</p> <p>Para escribir en las posiciones correctas del registro, se usa el desplazamiento con la variable <code>pin</code>. La variable <code>pin</code> se multiplica por <code>2U</code> para asegurar que el desplazamiento es de 2 en 2 bits.</p> <p>Para poner a 1 los bits de un registro o variable, se hace una <code>OR</code> (<code>|</code>) con el valor deseado.</p> </li> </ul> <p>Ya se ha hecho el segundo punto de la API de esta funci\u00f3n.</p> </li> <li> <p>De la misma forma, se configura el tipo de conexi\u00f3n pull-up/\u00a0down del pin. El c\u00f3digo es m\u00e1s gen\u00e9rico que el que se explica en la secci\u00f3n \u201cGPIO port pull-up/pull-down register (GPIOx_PUPDR)\u201d del libro. Simplemente, se repite los pasos anteriores pero esta vez sobre el registro <code>PUPDR</code>: crea la m\u00e1scara, limpia y escribe en el registro.</p> <p>Ya se ha hecho el \u00faltimo punto de la API de esta funci\u00f3n.</p> </li> </ol>"},{"location":"notebook/version_0.html#par:gpio_config_alternate","title":"Funci\u00f3n <code>stm32f4_system_gpio_config_alternate</code>","text":"<p>Esta funci\u00f3n configura el modo de la GPIO como funci\u00f3n alternativa. Para ello sigue las indicaciones de la API. A saber, lo que hace es:</p> <ul> <li> <p>Define una m\u00e1scara base de 4 bits (<code>0x0F</code>) para seleccionar los bits del registro <code>AFR</code> que se van a modificar.</p> <p>Esta m\u00e1scara se desplaza 4 por el valor de la variable <code>pin</code> m\u00f3dulo 8. 4 es el ancho de cada campo del registro <code>AFR</code>. El m\u00f3dulo 8 hace que el valor de <code>pin</code> se mantenga entre 0 y 7, y as\u00ed, no nos salgamos del ancho del registro, que tiene 32 bits.</p> </li> <li> <p>Se limpian los bits del registro <code>AFR</code> con la m\u00e1scara creada.</p> <p>Se selecciona el registro <code>AFRL</code> (low) o <code>AFRH</code> (high) en funci\u00f3n de: el valor de la variable <code>pin</code> dividido entre 8. Como <code>pin</code> solo puede tomar valores entre 0 y 15, la divisi\u00f3n entre 8 nos da 0 o 1. Esto hace que el valor resultante seleccione el registro <code>AFRL</code> o <code>AFRH</code>, respectivamente.</p> </li> <li> <p>Se escribe en el registro <code>AFR</code> el valor de la variable <code>alternate</code>.</p> </li> </ul>"},{"location":"notebook/version_0.html#par:gpio_config_exti","title":"Funci\u00f3n <code>stm32f4_system_gpio_config_exti</code>","text":"<p>Vamos a ver ahora esta funci\u00f3n que configura el pin dado para generar interrupciones externas. Lee y ten a mano el cap\u00edtulo \u201cInterrupciones\u201d del libro. El ejemplo te servir\u00e1 de mucho. Esta funci\u00f3n nos servir\u00e1 para enterarnos cuando pulsemos el bot\u00f3n y realizar alguna acci\u00f3n en nuestro sistema. Vamos a seguir los cuatro puntos de la API de esta funci\u00f3n.</p> <ol> <li> <p>Lo primero que hace es habilitar el controlador de configuraci\u00f3n del sistema que, como nos indica la API, sirve para controlar la l\u00ednea de interrupciones externas hacia las GPIO. Para ello, se activa el bit <code>SYSCFGEN</code> del registro <code>APB2ENR</code> del RCC. De nuevo, podemos definir nuestra propia m\u00e1scara para dicho bit mirando el registro, o usar la <code>RCC_APB2ENR_SYSCFGEN</code> de CMSIS que nos indica la API.</p> </li> <li> <p>Lo siguiente que hace es asociar la interrupci\u00f3n externa al puerto. Este c\u00f3digo puede hacerse de muchas maneras, unas m\u00e1s eficientes que otras, aunque no nos preocupamos de eso ahora.</p> <p>Como se indica en el libro, dependiendo del pin y el puerto, tendremos que elegir un registro u otro para realizar la asociaci\u00f3n. Como se trata de una funci\u00f3n gen\u00e9rica y no sabemos qu\u00e9 valores nos van a llegar, se hace la implementaci\u00f3n para cada pin y puerto seg\u00fan sea el valor de la variable <code>pin</code> y <code>port</code>. As\u00ed pues:</p> <ul> <li>si el valor de <code>pin</code> est\u00e1 entre <code>0</code> y <code>3</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR1</code> (<code>SYSCFG-&gt;EXTICR[0]</code>),</li> <li>si el valor de <code>pin</code> est\u00e1 entre <code>4</code> y <code>7</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR2</code> (<code>SYSCFG-&gt;EXTICR[1]</code>),</li> <li>si el valor de <code>pin</code> est\u00e1 entre <code>8</code> y <code>11</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR3</code> (<code>SYSCFG-&gt;EXTICR[2]</code>), y</li> <li>si el valor de <code>pin</code> est\u00e1 entre <code>12</code> y <code>15</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR4</code> (<code>SYSCFG-&gt;EXTICR[3]</code>).</li> </ul> <p>Se define una m\u00e1scara base de 4 bits (<code>0x0F</code>) para seleccionar los bits del registro <code>EXTICRx</code> que se van a modificar.</p> <p>Esta m\u00e1scara se desplaza 4 por el valor de la variable <code>pin</code> m\u00f3dulo 4. 4 es el ancho de cada campo del registro <code>EXTICRx</code>. El m\u00f3dulo 4 hace que el valor de <code>pin</code> se mantenga entre 0 y 3 y, as\u00ed, no nos salgamos del ancho del registro, del que se usan 16 bits.</p> <p>Se limpian los bits del registro <code>EXTICRx</code> con la m\u00e1scara creada.</p> <p>Se selecciona el registro <code>EXTICR1</code>, <code>EXTICR2</code>, <code>EXTICR3</code>, o <code>EXTICR4</code> en funci\u00f3n de el valor de la variable <code>pin</code> dividido entre 4. Como <code>pin</code> solo puede tomar valores entre 0 y 15, la divisi\u00f3n entre 4 nos da 0, 1, 2 o 3. Esto hace que el valor resultante seleccione el registro <code>EXTICR1</code>, <code>EXTICR2</code>, <code>EXTICR3</code> o <code>EXTICR4</code>, respectivamente.</p> <p>Se escribe en el registro <code>EXTICRx</code> el valor que corresponda para cada puerto. Si <code>port</code> es <code>GPIOA</code>, escribimos el valor <code>0</code>, si es <code>GPIOB</code>, escribimos el valor <code>1</code>\u2026, como indica la \u201cFigura\u201d del libro.</p> </li> <li> <p>A continuaci\u00f3n se selecciona la direcci\u00f3n de disparo de la interrupci\u00f3n: en flanco de subida, de bajada, o ambos.</p> <ul> <li> <p>Se activa el bit del pin correspondiente en el registro <code>RTSR</code> (rising) si el valor de la variable <code>mode</code> es <code>0x01</code>, indicando que la interrupci\u00f3n ha de notificarse cuando ocurra un flanco de subida.</p> <p>El n\u00famero del pin, <code>pin</code>, act\u00faa como \u00edndice de una m\u00e1scara de 1 solo bit, para lo que se usa la macro dada <code>BIT_POS_TO_MASK(pin)</code> para actuar sobre los registros.</p> </li> <li> <p>Se hace lo propio con el registro <code>FTSR</code> (falling) si el valor de la variable <code>mode</code> es <code>0x02</code>, indicando que la interrupci\u00f3n ha de notificarse cuando ocurra un flanco de bajada.</p> </li> <li> <p>Si el valor es <code>0x03</code> escribe en ambos registros: subida y bajada.</p> <p>\u00bfPor qu\u00e9 estos valores? Porque as\u00ed lo hemos decidido, podr\u00edan ser otros cualquiera. \u00bfY c\u00f3mo sabemos que son dichos valores? Porque la API nos dice los valores que podemos darle a la variable <code>mode</code>:</p> <p></p>Distintos valores que podemos darle a la variable <code>mode</code>.<p></p> <p>Es un consenso con nosotros mismos. Se ha a\u00f1adido en <code>stm32f4_system.h</code> un conjunto de <code>#define</code> para estos valores a fin de que el c\u00f3digo sea m\u00e1s inteligible y no haya valores \u201ca pincho\u201d. Se usan nombres representativos como:</p> <ul> <li><code>#define STM32F4_TRIGGER_RISING_EDGE</code></li> <li><code>#define STM32F4_TRIGGER_FALLING_EDGE</code></li> <li><code>#define STM32F4_TRIGGER_BOTH_EDGE</code></li> </ul> </li> </ul> </li> <li> <p>Por \u00faltimo, de nuevo codificado en el valor de <code>mode</code>, se act\u00faa sobre los registros <code>EXTI_EMR</code> o <code>EXTI_IMR</code> activando el bit correspondiente seg\u00fan si el valor de <code>mode</code> es <code>0x04</code> o <code>0x08</code>, respectivamente. Tambi\u00e9n puede darse el caso de que se quieran activar ambos a la vez. No son excluyentes. En este caso, como en el anterior, activar\u00edamos ambos (se puede a\u00f1adir un tercer <code>#define</code> h\u00edbrido, o realizar dos llamadas a la funci\u00f3n).</p> <p>Se a\u00f1ade en <code>stm32f4_system.h</code> un conjunto de <code>#define</code> con nombres representativos como:</p> <ul> <li><code>#define STM32F4_TRIGGER_ENABLE_EVENT_REQ</code></li> <li><code>#define STM32F4_TRIGGER_ENABLE_INTERR_REQ</code></li> </ul> </li> </ol> <p>Ya hemos visto c\u00f3mo est\u00e1 programada la funci\u00f3n. Esta ha sido m\u00e1s compleja, pero esperemos que ya vaya cogiendo soltura con los registros.</p>"},{"location":"notebook/version_0.html#par:gpio_config_exti_enable","title":"Funci\u00f3n <code>stm32f4_system_gpio_exti_enable</code>","text":"<p>El objetivo de esta funci\u00f3n es establecer el nivel de prioridad y subprioridad, y a la vez habilitar la interrupci\u00f3n de una l\u00ednea externa dada. La llamaremos cuando queramos configurar un pin como entrada y que genere interrupciones. Internamente llama a una macro de CMSIS que controla los registros de interrupci\u00f3n. Estos registros no aparecen en el reference manual porque son del core de Cortex-M4. Es muy importante habilitar la interrupci\u00f3n o nunca saltar\u00e1 la ISR.</p>"},{"location":"notebook/version_0.html#par:gpio_config_exti_disable","title":"Funci\u00f3n <code>stm32f4_system_gpio_exti_disable</code>","text":"<p>El objetivo de esta funci\u00f3n es deshabilitar la interrupci\u00f3n de una l\u00ednea externa dada. La usaremos cuando no queramos que nos interrumpa un pin/\u00a0l\u00ednea configurado como entrada y previamente habilitado. Mientras est\u00e1 desactivada, no saltar\u00e1 la ISR asociada a dicha l\u00ednea.</p>"},{"location":"notebook/version_0.html#par:gpio_read","title":"Funci\u00f3n <code>stm32f4_system_gpio_read</code>","text":"<p>Esta funci\u00f3n ser\u00e1 llamada cuando queramos leer el valor digital de un pin. Leeremos un <code>\u20181\u2019</code> o un <code>\u20180\u2019</code> l\u00f3gico, por eso, la funci\u00f3n devuelve <code>bool</code>. Vamos a seguir los dos puntos de la API de esta funci\u00f3n para que la implementes t\u00fa mismo/a.</p> <ol> <li> <p>En <code>stm32f4_system.h</code> declara el prototipo de la funci\u00f3n seg\u00fan indica la API. De esta forma la funci\u00f3n se hace p\u00fablica y podr\u00e1 ser llamada desde cualquier otro fichero.</p> </li> <li> <p>En <code>stm32f4_system.c</code> escribe el prototipo de la funci\u00f3n y abre llaves. Vamos a seguir los pasos que se indican en la API.</p> </li> <li> <p>Lee el valor del registro <code>IDR</code> de la GPIO como se muestra en la secci\u00f3n \u201cGPIO port input data register (GPIOx_IDR)\u201d del libro.</p> <ul> <li> <p>El puerto es el <code>port</code> dado.</p> </li> <li> <p>Usa la macro <code>BIT_POS_TO_MASK(pin)</code> para crear la m\u00e1scara seg\u00fan el pin dado.</p> </li> <li> <p>Tenemos que devolver una variable de tipo <code>bool</code>, por lo que tendremos que hacer un cast del resultado le\u00eddo del registro, ya que el registro es una variable de 32 bits. Puedes utilizar una variable intermedia para cargar el valor del registro, o hacerlo como en el ejemplo.</p> <p>Para leer el valor de un bit en un registro hacemos el producto bit a bit (<code>&amp;</code>).</p> </li> </ul> </li> <li> <p>Devuelve el valor le\u00eddo.</p> </li> <li> <p>En <code>stm32f4_system.h</code> documenta la funci\u00f3n con <code>Doxygen</code> ayud\u00e1ndose con la API. Recuerda que tienes el v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d con las bases para documentar y generar tu propia API.</p> </li> </ol> <p>Ya tenemos la funci\u00f3n que nos permite leer valores digitales del exterior dado un puerto y un pin. Comprueba que compila sin errores: Men\u00fa <code>Terminal\u2192 Run Task... \u2192 Build \u2192 stm32f446re (Default) \u2192 Release (Default) \u2192 main</code>.</p>"},{"location":"notebook/version_0.html#par:gpio_write","title":"Funci\u00f3n <code>stm32f4_system_gpio_write</code>","text":"<p>A continuaci\u00f3n vamos a desarrollar la funci\u00f3n que ser\u00e1 llamada cuando queramos escribir un valor digital en un pin. Escribiremos <code>\u20181\u2019</code> o <code>\u20180\u2019</code> l\u00f3gicos. Vamos a seguir los dos puntos de la API de esta funci\u00f3n.</p> <ol> <li> <p>En <code>stm32f4_system.h</code> declara el prototipo de la funci\u00f3n seg\u00fan indica la API.</p> </li> <li> <p>En <code>stm32f4_system.c</code> escribe el prototipo de la funci\u00f3n y abre llaves.</p> </li> <li> <p>Escribe el valor correspondiente en el registro <code>BSRR</code> de la GPIO como se muestra en la secci\u00f3n \u201cGPIO port bit set/reset register (GPIOx_BSRR)\u201d del libro.</p> <ul> <li> <p>El puerto es el <code>port</code> dado.</p> </li> <li> <p>Si el valor de la variable <code>value</code> es <code>true</code> activamos el bit correspondiente. Puedes usar la macro <code>BIT_POS_TO_MASK(pin)</code> para crear la m\u00e1scara seg\u00fan el pin dado. Para evitar posibles condiciones de carrera, utilizamos el registro <code>GPIOx_BSRR</code> y no el <code>GPIOx_ODR</code>.</p> </li> <li> <p>Si el valor de la variable <code>value</code> es <code>false</code> limpiamos el bit correspondiente. Lo limpiamos poniendo a uno el bit correspondiente en el registro <code>GPIOx_BSRR</code>; as\u00ed funciona este registro .</p> </li> </ul> </li> <li> <p>En <code>stm32f4_system.h</code> documenta la funci\u00f3n con <code>Doxygen</code> ayud\u00e1ndote con la API.</p> </li> </ol> <p>Ya tenemos la funci\u00f3n que nos permite escribir valores digitales dado un puerto y un pin. Comprueba que compila sin errores.</p>"},{"location":"notebook/version_0.html#par:gpio_toggle","title":"Funci\u00f3n <code>stm32f4_system_gpio_toggle</code>","text":"<p>Esta funci\u00f3n es muy c\u00f3moda cuando queremos invertir el valor de un pin. Si estaba en alto (<code>\u20181\u2019</code> l\u00f3gico), que pase a bajo (<code>\u20180\u2019</code> l\u00f3gico), y viceversa. Esta funci\u00f3n usa las dos anteriores; lee el valor del pin y escribe el opuesto. Seguimos la API.</p> <ol> <li> <p>En <code>stm32f4_system.h</code> declara el prototipo de la funci\u00f3n seg\u00fan indica la API.</p> </li> <li> <p>En <code>stm32f4_system.c</code> escribe el prototipo de la funci\u00f3n y abre llaves.</p> </li> <li> <p>Lee el valor del pin y el puerto. Puedes servirte de la funci\u00f3n anteriormente implementada.</p> </li> <li> <p>Escribe en el pin y el puerto el valor contrario al le\u00eddo. Puedes servirte de la funci\u00f3n anteriormente implementada.</p> <p>Puedes definir utilizar las macros <code>HIGH</code> y <code>LOW</code> si te resulta m\u00e1s c\u00f3modo de interpretar que <code>true</code> y <code>false</code>.</p> </li> <li> <p>En <code>stm32f4_system.h</code> documenta la funci\u00f3n con <code>Doxygen</code> ayud\u00e1ndote con la API.</p> </li> </ol> <p>Ya hemos tenemos la funci\u00f3n que nos permite alternar el valor de un pin. Comprueba que compila sin errores. Podr\u00e1s probar estas funciones junto con el test unitario del PORT de la versi\u00f3n 1.</p> <p>Tambi\u00e9n hemos acabado con las funciones b\u00e1sicas del sistema. Estas funciones se usar\u00e1n en las distintas versiones del proyecto, por eso es tan importante que las hici\u00e9semos lo primero y que las entienda. Adem\u00e1s, nos ha servido para calentar en esto de la programaci\u00f3n de bajo nivel (baremetal). A continuaci\u00f3n seguiremos con la implementaci\u00f3n HW del bot\u00f3n y su m\u00e1quina de estados.</p> <ol> <li> <p>Aunque t\u00fa mismo puedes re-generar dicha API localmente como se explica en la gu\u00eda\u00a0<sup>7</sup>.\u00a0\u21a9</p> </li> <li> <p>La funci\u00f3n <code>port_system_delay_ms()</code> s\u00ed podr\u00eda acceder a la variable <code>msTicks</code> directamente, aunque con llamada a <code>port_system_get_millis()</code> es m\u00e1s ortodoxo y as\u00ed es como lo har\u00edan, inevitablemente, funciones de otros ficheros.\u00a0\u21a9</p> </li> <li> <p>El fichero <code>stm32f4xx.h</code> se encuentra en el \u00e1rbol de directorios de la toolkit MatrixMCU en: MatrixMCU/drivers/stm32f4xx/CMSIS/Device/ST/STM32F4xx/Include/stm32f446xx.h \u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Juan Jos\u00e9 G\u00f3mez Valverde. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/88460/.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Amadeo de Gracia Herranz, Sergio Esteban Romero, and Daniel Capell\u00e1n Mart\u00edn. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/92376/.\u00a0\u21a9\u21a9</p> </li> <li> <p>Michael Barr. Embedded C Coding Standard. Netrino, 2009.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_1.html","title":"Versi\u00f3n 1","text":""},{"location":"notebook/version_1.html#cha:version1","title":"Versi\u00f3n 1: bot\u00f3n de usuario","text":"<p>Ya estamos en disposici\u00f3n de programar el bloque que controla la pulsaci\u00f3n del bot\u00f3n para encender y apagar el sistema Simone, y para pausarlo. Debes tener a mano en todo momento los documentos referenciados y ver los v\u00eddeos sugeridos a fin de entender mejor c\u00f3mo tienes que escribir el c\u00f3digo o realizar montajes. tt</p> <p>Bibliograf\u00eda</p> <ol> <li> <p>\u201cFundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>3</sup></p> </li> <li> <p>Datasheet \u201cSTM32F446xC/E\u201d <sup>4</sup></p> </li> <li> <p>Reference manual \u201cRM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>5</sup></p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Demostraci\u00f3n Simone</p> </li> <li> <p>Blink LED y manejo de proyecto</p> </li> <li> <p>Conceptos b\u00e1sicos de C (canal SDG1)</p> </li> <li> <p>[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen</p> </li> </ul> <p>Vamos a desarrollar el bot\u00f3n de control del sistema Simone. Vamos a trabajar con el timer del sistema y m\u00e1quinas de estado. En esta secci\u00f3n explicaremos los fundamentos de esta librer\u00eda y posteriormente seguiremos los pasos para desarrollarla. Para desarrollar esta librer\u00eda vamos a contar con la API.</p> <p>En esta versi\u00f3n 1, el sistema solo trabaja con el bot\u00f3n de usuario. Las caracter\u00edsticas a destacar de este montaje se muestran en el\u00a0. El bot\u00f3n de usuario est\u00e1 conectado al pin <code>PC13</code>, por lo que usaremos la interrupci\u00f3n externa <code>EXTI13</code> para detectar cuando pulsamos y soltamos el bot\u00f3n. La prioridad de la interrupci\u00f3n ser\u00e1 1, la m\u00e1s alta, para poder parar el sistema en cualquier momento.</p> Par\u00e1metro Valor Pin <code>PC13</code> Modo Entrada Pull up/ down No push no pull EXTI <code>EXTI13</code> ISR <code>EXTI15_10_IRQHandler()</code> Prioridad 1 Subprioridad 0 Tiempo anti-rebotes \\(100-200 ms\\)"},{"location":"notebook/version_1.html#caracteristicas-del-boton-de-usuario-en-version-1","title":"Caracter\u00edsticas del bot\u00f3n de usuario en Versi\u00f3n 1","text":"<p>Estudia y practica con las m\u00e1quinas de estado. Entiende c\u00f3mo se definen los estados, las tablas de transiciones, y qu\u00e9 son las funciones de entrada/\u00a0comprobaci\u00f3n y salida/\u00a0actuaci\u00f3n. Para ello vuelve a leer  el cap\u00edtulo \u201c2. Introducci\u00f3n a las m\u00e1quinas de estados en C\u201d <sup>6</sup>.</p> <p>Si tienes la oportunidad de abrir un bot\u00f3n pulsador<sup>1</sup>, seguramente encuentres un dise\u00f1o mec\u00e1nico como el de la figura. Se trata de una chapa met\u00e1lica pegada a un aislante (donde toca el usuario) y colocada sobre un muelle. En la parte inferior, los pines del bot\u00f3n est\u00e1n tambi\u00e9n en contacto con una chapa met\u00e1lica. Al presionar, la chapa superior entra en contacto con la inferior y cierra el circuito (cortocircuito), circulando la corriente a trav\u00e9s del bot\u00f3n. Cuando se suelta, la corriente deja de pasar (circuito abierto).</p> Representaci\u00f3n mec\u00e1nica de un bot\u00f3n. <p>En la figura del esquema vemos el esquem\u00e1tico del bot\u00f3n de usuario <code>B1</code> en la placa Nucleo-STM32. Cuando pulsamos el bot\u00f3n, este hace cortocircuito con <code>GND</code>, por lo que la tensi\u00f3n en el puerto <code>PC13</code> del microcontrolador pasa de alto a bajo (flanco de bajada).</p> Esquema del circuito del bot\u00f3n en la placa Nucleo-STM32F446RE. <p>Como habr\u00e1s podido intuir, el muelle genera inestabilidades cuando se pulsa, esto es a lo que llamamos rebotes (bounces en ingl\u00e9s). Estos rebotes son molestos porque se pueden interpretar como m\u00faltiples pulsaciones del usuario, por lo que hay que poner alg\u00fan mecanismo para filtrarlos. Se pueden hacer mecanismos HW como un filtro paso bajo o, como en nuestro caso, se pueden implementar mecanismos SW.</p> <p>En SW hay varias formas de implementar dicho mecanismo. En nuestra propuesta lo haremos a trav\u00e9s de la definici\u00f3n de un tiempo de guarda que obliga a ignorar todo lo que pasa en ese intervalo. F\u00edjate en el supuesto de la\u00a0figura de rebotes. Para el proyecto vamos a considerar que la pulsaci\u00f3n empieza cuando la ISR detecta el flanco de bajada, y hasta que se detecta un flanco de subida v\u00e1lido. En la figura, hay una pulsaci\u00f3n de usuario, y la mec\u00e1nica del bot\u00f3n hace que haya 2 rebotes bien definidos. El primer rebote no se detecta porque est\u00e1 dentro del tiempo de guarda. No obstante, este tiempo no es lo suficiente grande y se nos cuela el segundo rebote. Esta figura nos servir\u00e1 como ejemplo para entender el desarrollo de la FSM.</p> Ejemplo de 2 rebotes en una pulsaci\u00f3n con tiempo de anti-rebotes bajo. <p>Salvo que tengamos mucha experiencia jugando a videojuegos\u00a0\ud83d\ude05, no seremos muy r\u00e1pidos pulsando el bot\u00f3n. Dejando un tiempo de guarda entre \\(100-200 ms\\) deber\u00eda ser suficiente, pero depende del deterioro de nuestro bot\u00f3n y quiz\u00e1s debamos ajustarlo haciendo pruebas en el laboratorio con el osciloscopio. Ya estamos preparados para implementar la FSM.</p> <p>Tenemos que entender que estamos desarrollando una librer\u00eda. As\u00ed lo vamos a hacer con todos los bloques del sistema. \u00bfQu\u00e9 quiere decir esto? Tenemos que pensar que una librer\u00eda es una entidad superior que me proporciona \u201ccosas\u201d. Pueden ser funciones, o elementos (estructuras). Me puede proporcionar tantos como necesite. El desarrollo de la librer\u00eda es ajeno al bot\u00f3n que vamos a usar (ir\u00e1 en el <code>COMMON</code>, es una l\u00f3gica com\u00fan, gen\u00e9rica, independiente del HW). Puedo tener \\(1\\) bot\u00f3n, o \\(N\\) botones. Cada vez que quiera usar un bot\u00f3n, a este le asociar\u00e9 una FSM de bot\u00f3n. Las particularidades de d\u00f3nde est\u00e1 conectado este nuevo bot\u00f3n, sus caracter\u00edsticas f\u00edsicas (tiempo de rebote), etc., son cosas espec\u00edficas del HW, por lo que estar\u00e1n en <code>PORT</code>. La l\u00f3gica la vamos a hacer, siempre que se pueda, con m\u00e1quinas de estado. El bot\u00f3n implementa su propia m\u00e1quina de estados. Esta filosof\u00eda es la que mantendremos a lo largo de todo el proyecto.</p> <p>Note</p> <p>Vamos a empezar por la parte portable <code>PORT</code> de control y acceso al HW. Empezaremos con las cabeceras <code>.h</code>y seguiremos con la implementaci\u00f3n de las funciones de los ficheros fuente <code>.c</code>. Para comprobar que todo funciona correctamente, pasaremos el test unitario de la parte <code>PORT</code>. Luego, pasaremos a la parte <code>COMMON</code> de la librer\u00eda, que es la l\u00f3gica com\u00fan a todos los sistemas. Empezaremos con las cabeceras y seguiremos con la implementaci\u00f3n de las funciones de los ficheros fuente. Para comprobar que todo funciona correctamente, pasaremos el test unitario de la parte <code>COMMON</code>, y finalizaremos con el ejemplo de uso de la librer\u00eda. </p> <p>Las cabeceras <code>.h</code> van a se nuestro \u201ccontrato con el usuario\u201d, y en los ficheros fuente <code>.c</code> implementaremos las funciones. Este es el ciclo de desarrollo que vamos a seguir en todo el proyecto.</p> (a) Estructura del HW del bot\u00f3n en PORT, (b) Estructura de la FSM del bot\u00f3n en COMMON. <p>Las figuras de estructuras HW y SW muestran las estructuras que vamos a necesitar para el bot\u00f3n. La estructura del HW del bot\u00f3n en <code>PORT</code>. El <code>PORT</code> de otro microcontrolador podr\u00eda implementar internamente una estructura diferente, por eso est\u00e1 dentro de la carpeta <code>stm32f4</code>. Por ejemplo, al portar el c\u00f3digo para PC no tendr\u00eda sentido definir la estructura de una GPIO. La estructura de la FSM del bot\u00f3n en <code>COMMON</code> se muestra en la figura de la FSM.</p> <p>Ahora s\u00ed, comencemos. Preparemos el proyecto para poder a\u00f1adir el bot\u00f3n:</p> <ol> <li> <p>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT de la librer\u00eda del bot\u00f3n correspondientes a la versi\u00f3n <code>V1</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v1. Solo descarga por ahora: <code>port_button.h</code>, <code>stm32f4_button.h</code> y <code>stm32f4_button.c</code> y col\u00f3calos en las carpetas correspondientes de tu proyecto. No a\u00f1adas los ficheros de la parte COMMON.</p> </li> <li> <p>Coloca cada uno donde corresponde: <code>include</code>, o <code>src</code>. Ten en cuenta que algunos ficheros de <code>PORT</code> est\u00e1n en la carpeta <code>stm32f4</code> porque sus funciones reciben o devuelven estructuras espec\u00edficas de la Nucleo-STM32F446RE.</p> <p>Ver\u00e1s que no compila, y es que solo se te proporciona cierta parte del c\u00f3digo. Los prototipos de gran parte de las funciones p\u00fablicas no est\u00e1n definidos.</p> </li> </ol>"},{"location":"notebook/version_1.html#sec:headers_button","title":"<code>PORT</code>: cabeceras de la librer\u00eda del bot\u00f3n","text":"<p>Vamos a implementar el contrato con el usuario de la parte dependiente del HW de librer\u00eda del bot\u00f3n. Esto es, qu\u00e9 interfaz vamos a proporcionar al usuario para que pueda usar la librer\u00eda y crear tantos botones como necesite. Lo haremos, c\u00f3mo no, para la placa Nucleo-STM32F446RE.</p> <p>Durante todo el desarrollo del proyecto, si detectas que falta alg\u00fan <code>#define</code>, o <code>#include</code>, o declaraci\u00f3n de variable que sea necesaria o que necesite, hazlo. Lo que aqu\u00ed se expone no es algo inmutable, aunque sigue unas buenas pr\u00e1cticas.</p> <p>La figura de plantilla representa las secciones de una plantilla gen\u00e9rica de cabecera que puede utilizar a lo largo del proyecto. El orden no es un est\u00e1ndar, ni las secciones que ah\u00ed aparecen. No obstante, s\u00ed es muy conveniente ser ordenado y met\u00f3dico en programaci\u00f3n. S\u00ed es importante el orden en los siguientes casos:</p> <ul> <li> <p>La inclusi\u00f3n de cabeceras ha de ser lo primero. Es importante el orden en caso de existir dependencias entre ellas.</p> </li> <li> <p>Es aconsejable definir las etiquetas, macros, enumerados\u2026\u00a0justo despu\u00e9s para que puedan ser utilizados en la declaraci\u00f3n y definici\u00f3n de variables. Solo pondremos en el <code>.h</code> aqu\u00e9llas que queramos que sean visibles y utilizadas por otros ficheros. En caso contrario, lo colocaremos en el <code>.c</code>.</p> </li> <li> <p>Si se declara alg\u00fan tipo nuevo de variable, hay que hacerlo antes de que se use en el prototipo de alguna funci\u00f3n. Las funciones que no queramos que sean accesibles por otros ficheros no tendr\u00e1n prototipo, y escribiremos y documentaremos directamente en el <code>.c</code>, adem\u00e1s, se definir\u00e1n como <code>static</code>.</p> </li> </ul> Sugerencia de plantilla gen\u00e9rica de una cabecera. <p>Nuestro bot\u00f3n es el bot\u00f3n de usuario <code>B1</code> de la placa (el azul) ser\u00e1 el bot\u00f3n para arranque y parada del juego. Est\u00e1 conectado a la GPIO PC13. Si lo queremos ver en el osciloscopio, tendremos que pinchar en el pin indicado en el header-Morpho izquierdo, como marca la figura \u201cPinout y funciones header -Morpho izquierdo.\u201d del libro de fundamentos te\u00f3ricos\u00a0<sup>3</sup>. El esquem\u00e1tico del circuito del bot\u00f3n es el que se mostr\u00f3 en la figura del esquem\u00e1tico.</p>"},{"location":"notebook/version_1.html#cabecera-port_buttonh","title":"Cabecera port_button.h","text":"<p>Esta cabecera depende del HW pero no de las particularidades del microcontrolador STM32F446RE. En ella vamos a definir las funciones que el usuario podr\u00e1 usar para gestionar el bot\u00f3n. F\u00edjate que todas las funciones reciben el identificador del bot\u00f3n y solo pueden recibir o devolver variables que NO dependan del microcontrolador. Vamos a seguir los siguientes pasos:</p> <ul> <li> <p>Vamos a definir (<code>#define</code>) dos valores que nombraremos en un consenso con nosotros mismos. Puede cambiarlos si lo desea, pero deber\u00e1n ser los mismos que luego use en el resto del proyecto \u00a1y en los test, si los cambias, tendr\u00e1s que tocar los ficheros de test tambi\u00e9n! Los valores son:</p> </li> <li> <p><code>PORT_USER_BUTTON_ID</code>: valor num\u00e9rico natural que ser\u00e1 el identificador del bot\u00f3n para indicar arranque y parada del juego Simone. Si es nuestro primer y/\u00a0o \u00fanico bot\u00f3n del sistema, le asignaremos el <code>0</code>.</p> </li> <li> <p><code>PORT_USER_BUTTON_DEBOUNCE_TIME_MS</code>: tiempo del anti-rebotes del bot\u00f3n en \\(ms\\).</p> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_button.h</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen. Para que aparezca en la API el campo y su definici\u00f3n, hay que poner <code>/*!&lt; aqui_la_definicion */</code> junto al nombre del campo como muestra la figura de ejemplo de Doxygen en enumerados.</p> <p></p>Comentario de Doxygen en las claves de un enumerado.<p></p> <p>Puedes partir de los ejemplos dados en el fichero <code>port_system.h</code> y ayudarse con extensa documentaci\u00f3n online. Puede hacerlo en espa\u00f1ol o ingl\u00e9s<sup>2</sup>.</p> </li> </ul> <p>Note</p> <p>Podemos tener ayuda para autocomentar parcialmente el c\u00f3digo con Doxygen. Compruea si tienes instalada la extensi\u00f3n llamada Doxygen Documentation Generator \u2014a veces se instala junto con otras extensiones\u2014; si no la tienes, puedes instalarla. Con esta extensi\u00f3n, si te colocas justo en la l\u0131\u0301nea encima del nombre de la funci\u00f3n y escribes: barra, asterisco, asterisco, enter , colocando el cursor en la tercera posici\u00f3n, como en la imagen, para darle a enter, se genera autom\u00e1ticamente un esqueleto para poder completarlo. Tambi\u00e9n se puede hacer si, colocados justo encima de la funci\u00f3n, damos bot\u00f3n derecho \u2192 Generate Doxygen Comment.</p> <p>Ya hemos acabado con el encabezado que interact\u00faa con el HW del bot\u00f3n y que no depende del microcontrolador. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a programar la cabecera que s\u00ed depende del microcontrolador <code>stm32f4_button.h</code>.</p>"},{"location":"notebook/version_1.html#cabecera-stm32f4_buttonh","title":"Cabecera stm32f4_button.h","text":"<p>Esta cabecera depende del HW y del microcontrolador STM32F446RE. En ella vamos a definir la funci\u00f3n que permitir\u00e1 al usuario asignar una GPIO al bot\u00f3n. En la versi\u00f3n V5, si lo necesitas, puedes a\u00f1adir m\u00e1s funciones que dependan del microcontrolador. Vamos a seguir los siguientes pasos:</p> <ul> <li> <p>Como vamos a hacer uso de funciones de control de las GPIO, vamos a incluir <code>stm32f4xx.h</code>, que nos da acceso a los registros.</p> </li> <li> <p>Vamos a definir (<code>#define</code>) los valores de la GPIO y el pin al que est\u00e1 conectado el bot\u00f3n, y que se indican en la tabla resumen del bot\u00f3n:</p> </li> <li> <p><code>STM32F4_USER_BUTTON_GPIO</code>: GPIO a la que est\u00e1 conectada el bot\u00f3n de usuario en la placa. Pon el nombre de la GPIO. Por ejemplo: <code>GPIOH</code>, si estuviese conectado a la GPIO H. Este nombre, es el de la estructura de <code>CMSIS</code> y se define en <code>stm32f4xx.h</code>. Puedes hacer <code>CTRL + click</code> sobre el nombre de la GPIO para ir a su definici\u00f3n.</p> </li> <li> <p><code>STM32F4_USER_BUTTON_PIN</code>: pin/\u00a0l\u00ednea de la GPIO del bot\u00f3n. Es un n\u00famero entero que va de 0 a 15.</p> </li> <li> <p>En el fichero tenemos que declarar tambi\u00e9n una estructura llamada <code>stm32f4_button_hw_t</code> (ver la figura del struct). Esta estructura se pone en el <code>.h</code> y se hace p\u00fablica para que pueda ser usada por la ISR del bot\u00f3n en el fichero <code>interr.c</code>. Esto es as\u00ed porque a las ISR no se les puede pasar argumentos. En ella se definen los campos que se muestran en la figura.</p> <p>Esta estructura es gen\u00e9rica para cualquier bot\u00f3n que vayamos a usar, no solo el de usuario <code>B1</code>, sino cualquiera que desee a\u00f1adir m\u00e1s tarde.</p> <p>El campo <code>flag_pressed</code> nos indica si el bot\u00f3n se ha pulsado, o no. Ya vimos que cuando pulsamos nuestro bot\u00f3n se produce un flanco de bajada por c\u00f3mo est\u00e1n conectados sus pines (ver figura de rebotes). Son las ISR las que hacen esta interpretaci\u00f3n.</p> </li> <li> <p>Vamos declarar un array de estructuras de tipo <code>stm32f4_button_hw_t</code> como <code>extern</code> que se definir\u00e1 en el fichero fuente <code>stm32f4_button.c</code>. Este array contendr\u00e1 las caracter\u00edsticas de todos los botones que tengamos en el sistema.</p> </li> </ul> <pre><code>extern stm32f4_button_hw_t buttons_arr[];\n</code></pre> <ul> <li>Puede ser buen momento ahora para documentar la funci\u00f3n, la estructura y sus campos, y los <code>#define</code> con Doxygen.</li> </ul> <p>Ya hemos acabado con el encabezado (header) que interact\u00faa con el HW del bot\u00f3n y depende del microcontrolador. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a implementar todas las funciones prototipadas aqu\u00ed y en <code>port_button.h</code>.</p>"},{"location":"notebook/version_1.html#sec:port_button","title":"<code>PORT</code>: fuente de la librer\u00eda del bot\u00f3n","text":"<p>Si observas la API, ver\u00e1s que la FSM del bot\u00f3n hace llamadas a funciones que empiezan por <code>port_</code>. Estas son funciones portables, y el usuario que quiera usar la librer\u00eda de la FSM del bot\u00f3n debe programarlas y adaptarlas a su HW.</p> <p>Vamos a portar las funciones necesarias para usar la librer\u00eda bot\u00f3n y comprobar que la parte HW est\u00e1 bien programada. Lo haremos, c\u00f3mo no, para la placa Nucleo-STM32F446RE. Ya tenemos las cabeceras HW del bot\u00f3n: las que no dependen del microcontrolador (<code>port_button.h</code>) y las que s\u00ed (<code>stm32f4_button.h</code>). Vamos a programar los ficheros fuente de la parte <code>PORT</code>, que todos estar\u00e1n en el fichero <code>stm32f4_button.c</code>. Deber\u00e1s implementar o completar todas las funciones p\u00fablicas de las que ya has declarado el prototipo en el encabezado. Posteriormente completar\u00e1s la ISR asociada al pin del bot\u00f3n que aparece en la API del fichero <code>interr.c</code>.</p>"},{"location":"notebook/version_1.html#fuentes-stm32f4_buttonc","title":"Fuentes stm32f4_button.c","text":"<ol> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Vamos a definir la variable global <code>stm32f4_button_hw_t buttons_arr[]</code> que se declar\u00f3 en el <code>.h</code>. Se trata de un array que no especifica el n\u00famero de elementos que tiene, pero cada uno ser\u00e1 de tipo <code>stm32f4_button_hw_t</code>, que representa al HW de cada bot\u00f3n que tengamos en nuestro sistema.</p> <p>La declaraci\u00f3n e inicializaci\u00f3n de este array podemos hacerla a la vez, que ser\u00e1 lo m\u00e1s aconsejable. Tambi\u00e9n podr\u00edamos hacer solo la declaraci\u00f3n e inicializar los valores de cada bot\u00f3n en una funci\u00f3n aparte \u2014que ahora mismo no tenemos definida\u2014. Convendr\u00eda recordar las secciones correspondientes de los v\u00eddeos de SDG1: inicializaci\u00f3n de arrays y arrays de estructuras.</p> <p>Asigna los valores del bot\u00f3n <code>PORT_USER_BUTTON_ID</code> utilizando los <code>#define</code> de <code>stm32f4_button.h</code>. Deber\u00e1 quedarte algo como lo de la figura de arrays. Si tienes m\u00e1s botones en el sistema, simplemente a\u00f1adir\u00edas una fila para cada bot\u00f3n con sus caracter\u00edsticas correspondientes.</p> <p></p>Array de botones con las caracter\u00edsticas del bot\u00f3n de usuario.<p></p> </li> <li> <p>Se os proporciona ya codificada la funci\u00f3n <code>_stm32f4_button_get()</code>. Se trata de una funci\u00f3n privada que devuelve un puntero a la estructura del bot\u00f3n que se le pasa como argumento. Esta funci\u00f3n, aunque prescindible, es \u00fatil para poder hacer un c\u00f3digo m\u00e1s legible y acceder a los campos de la estructura del bot\u00f3n de forma m\u00e1s sencilla desde otras funciones del fichero <code>stm32f4_button.c</code>. \u00a1Recuerda que esta funci\u00f3n es privada y por tanto debe aparecer codificada antes de cualquier funci\u00f3n que la utilice!</p> <p>Si el bot\u00f3n no existe, la funci\u00f3n devuelve <code>NULL</code>. Esto es habitual en funciones que devuelven punteros y es muy \u00fatil para detectar errores en la programaci\u00f3n.</p> </li> <li> <p>Completa la funci\u00f3n <code>port_button_init()</code> como se indica en la API. F\u00edjate c\u00f3mo la parte de c\u00f3digo proporcionada define la variable local <code>\\*p_button</code> que nos permite acceder al bot\u00f3n. Tambi\u00e9n podr\u00eda haberse hecho con acceso directo al elemento del array de botones <code>buttons_arr[button_id]</code>, pero es m\u00e1s elegante, seguro, y legible hacerlo con la funci\u00f3n <code>_stm32f4_button_get()</code>.</p> <p>Recuerda que es muy importante indicar en el modo de la interrupci\u00f3n del bot\u00f3n que, adem\u00e1s de detectar ambos flancos (subida y bajada), debe habilitar la petici\u00f3n de interrupci\u00f3n (registro <code>EXTI_IMR</code>).</p> </li> <li> <p>Codifica la funci\u00f3n p\u00fablica declarada en el fichero <code>port_button.h</code> siguiendo la API: <code>port_button_get_pressed()</code>.</p> <p>\u00a1Ya hemos acabado con la implementaci\u00f3n de la parte HW <code>stm32f_button.c</code>! Ahora solo queda la ISR asociada al pin del bot\u00f3n para poder probarlo. Vamos a ello.</p> </li> </ol>"},{"location":"notebook/version_1.html#sec:interr_button","title":"interr.c","text":"<p>Abre el fichero <code>interr.c</code> e implementa la ISR <code>EXTI15_10_IRQHandler</code>. Hay que implementar la parte correspondiente a la Versi\u00f3n 1 que indica la API solo.</p> <ol> <li> <p>Copia este esqueleto en el documento:</p> <pre><code>void EXTI15_10_IRQHandler(void)\n{\n    /* ISR user button */\n    if (EXTI-&gt;PR &amp; BIT_POS_TO_MASK(buttons_arr[PORT_USER_BUTTON_ID].pin))\n    {\n\n\n    }\n}\n</code></pre> </li> <li> <p>Completa la ISR <code>EXTI15_10_IRQHandler</code> como se indica en la API.</p> <p>Esta ISR es la misma para cualquier elemento que se conecte en las l\u00edneas <code>10-15</code>, y por ello debe identificar cu\u00e1l de ellas ha sido. Es por eso que tenemos la l\u00ednea <code>EXTI-&gt;PR &amp; BIT_POS_TO_MASK(buttons_arr[PORT_USER_BUTTON_ID].pin)</code>, para asegurar que es el bot\u00f3n de usuario.</p> <p>Esta l\u00ednea comprueba si el bit de la posici\u00f3n del pin del bot\u00f3n est\u00e1 activo en el registro Pending Register <code>EXTI_PR</code>. Si es as\u00ed, es porque se ha producido una interrupci\u00f3n en el pin del bot\u00f3n. Es muy importante que borremos el flag de interrupci\u00f3n escribiendo un 1 en el bit correspondiente del registro <code>EXTI_PR</code>.</p> <p>Debemos identificar si el flanco que ha producido la interrupci\u00f3n es de subida o bajada, pues el montaje HW de cada bot\u00f3n puede ser distinto.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>Si ahora compila, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado del bot\u00f3n!. Vamos a probarlo con el test unitario de la parte <code>PORT</code>.</p>"},{"location":"notebook/version_1.html#sec:test_port_v1","title":"<code>PORT</code>: Test unitario del bot\u00f3n","text":"<p>Veremos que la l\u00f3gica de las m\u00e1quinas de estado hacen uso de las funciones portables que acceden al HW del dispositivo. Es por ello que es importante comprobar primero que la parte <code>PORT</code> funciona correctamente. Vamos a hacer el test de HW del c\u00f3digo que hemos desarrollado de la librer\u00eda del bot\u00f3n y probar que funciona antes de continuar con la implementaci\u00f3n de la l\u00f3gica de la parte de la FSM.</p> <p>\u00a1Importante! Los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente. \u00a0Ten a mano y revisa el cap\u00edtulo \u201cTest unitarios y ejemplos de integraci\u00f3n\u201d del libro de fundamentos te\u00f3ricos\u00a0<sup>3</sup>.</p> <p>En esta secci\u00f3n vamos a practicar con el concepto de depuraci\u00f3n (debugging) ( recordar ejercicio de clase en SDG1 y las pruebas de la Gu\u00eda de instalaci\u00f3n con blink <sup>7</sup>).</p> <p>La herramienta m\u00e1s importante y c\u00f3moda que tenemos para depurar es el IDE que usemos. En nuestro caso, como VSCode no es un IDE en s\u00ed mismo, sino un editor de texto vitaminado, tenemos que usar extensiones. La extensi\u00f3n Cortex-Debug para VSCode es la que nos ayudar\u00e1 a depurar.</p> <p>A veces no nos queda otra forma para depurar que imprimir texto por pantalla (cuando esta existe). Recuerde de la Gu\u00eda de instalaci\u00f3n <sup>7</sup> que algunos dispositivos basados en ARM proporcionan una consola de ITM. ITM es una aplicaci\u00f3n de ARM que permite, entre otras cosas, el uso de la funci\u00f3n <code>printf()</code> en depuraci\u00f3n con la placa. Tambi\u00e9n existen alternativas como el semihosting, que env\u00eda mensajes a trav\u00e9s de la pesta\u00f1a de Debug Console de VSCode. Esta es la opci\u00f3n que tenemos configurada en nuestro proyecto. No hay que abusar de ellas, porque no vale para todo. Tendremos que acudir inevitablemente a ver los valores de los registros en alg\u00fan momento. Bien es cierto que, una vez el proyecto est\u00e1 funcionando en producci\u00f3n, puede ser \u00fatil tener trazas (impresas, LEDs, ficheros de log\u2026) para saber qu\u00e9 est\u00e1 pasando en caso de fallo.</p> <p>Descarga el fichero de test HW del bot\u00f3n <code>test_port_button.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v1_test. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto. Puedes eliminar el fichero plantilla <code>test_template.c</code></p> <ol> <li> <p>Conecta la placa Nucleo-STM32\u00a0al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_port_button</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Inmediatamente se habr\u00e1 parado en la primera l\u00ednea del test. Contin\u00faa la depuraci\u00f3n () para ejecutar el test por completo, o pon puntos de parada si deseas ir paso a paso.</p> </li> <li> <p>Se habr\u00e1 impreso por la terminal del <code>gdb-server</code> el resultado de las pruebas de los tests. Deber\u00eda haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu c\u00f3digo hasta que pasen todas las pruebas. Si no pasan las pruebas, no contin\u00faes.</p> </li> <li> <p>La depuraci\u00f3n se queda en bucle en la instrucci\u00f3n <code>exit(UNITY_END())</code>. Para terminar la depuraci\u00f3n pulsa () y repite el proceso hasta que pasen todos los test.</p> <p>Si alg\u00fan test genera una situaci\u00f3n de comportamiento inesperado, puede ser que no termine de ejecutarse. Comprueba d\u00f3nde se queda pausando la depuraci\u00f3n, y lee los mensajes de error que te proporciona el test.</p> </li> </ol> <p>Un ejemplo de ejecuci\u00f3n del test se muestra en la ejecuci\u00f3n de test de la figura. En este caso, la segunda comprobaci\u00f3n ha fallado indic\u00e1ndonos que la GPIO elegida para el bot\u00f3n no es la correcta. Luego aparecen m\u00e1s errores, pero son derivados de este. Corrigi\u00e9ndolo, pasan todos los test correctamente. Por eso, se recomienda arreglar los errores en el orden en que aparecen.</p> Ejecuci\u00f3n de los test unitarios de la parte `PORT` del bot\u00f3n. <p>\u00a1Ya hemos acabado con la parte <code>PORT</code> del bot\u00f3n! Vamos ahora a implementar la parte <code>COMMON</code> de la librer\u00eda del bot\u00f3n.</p>"},{"location":"notebook/version_1.html#common-cabecera-de-la-fsm-del-boton","title":"<code>COMMON</code>: cabecera de la FSM del bot\u00f3n","text":""},{"location":"notebook/version_1.html#sec:consideraciones_fsm_button","title":"Consideraciones de la FSM del bot\u00f3n","text":"<p>Antes de empezar vamos a partir de una serie de consideraciones.</p> <ul> <li> <p>La FSM almacena la duraci\u00f3n de la \u00faltima pulsaci\u00f3n de bot\u00f3n.</p> </li> <li> <p>El usuario debe solicitar/\u00a0comprobar la duraci\u00f3n mediante la funci\u00f3n <code>fsm_button_get_duration()</code>.</p> </li> <li> <p>El valor de inicio de duraci\u00f3n al arrancar la FSM, y el de reinicio, debe ser \\(0 ms\\).</p> </li> <li> <p>Un valor de \\(0 ms\\) significa que no ha habido una nueva pulsaci\u00f3n del bot\u00f3n.</p> </li> <li> <p>El usuario debe reiniciar el valor de duraci\u00f3n una vez le\u00eddo, de lo contrario, este valor puede ser malinterpretado por el usuario si se realizan sucesivas comprobaciones sin haber pulsado el bot\u00f3n. En tal caso estar\u00edamos leyendo informaci\u00f3n del pasado. Para reiniciar el valor se debe llamar a la funci\u00f3n <code>fsm_button_reset_duration()</code>.</p> <p>Visto de otro modo, el \u201cflag\u201d de estado de esta FSM es la variable duraci\u00f3n. Una duraci\u00f3n de 0 significa que no ha habido ninguna nueva pulsaci\u00f3n de bot\u00f3n. Un valor distinto de 0 representa que ha sido pulsado y el valor es su duraci\u00f3n. Es por tanto responsabilidad del usuario borrar este \u201cflag\u201d de estado.</p> </li> <li> <p>La FSM contiene informaci\u00f3n del identificador (<code>ID</code>) del bot\u00f3n. Este <code>ID</code> es \u00fanico y gestionado por el usuario en el <code>PORT</code>. Ah\u00ed es donde el usuario proporciona identificadores e informaci\u00f3n HW (GPIO a la que est\u00e1 conectado y tiempo de anti-rebotes) para todos los botones de su sistema.</p> </li> </ul> M\u00e1quina de estados del bot\u00f3n. <p>Nuestra librer\u00eda implementa la l\u00f3gica de la FSM mostrada en la FSM de la figura y que llamaremos <code>fsm_button</code> (en los ficheros <code>.c</code> y <code>.h</code>). Tiene 4 estados porque implementa un mecanismo anti-rebotes SW. Los rebotes de bot\u00f3n o pulsaciones muy r\u00e1pidas que duren menos que el tiempo de anti-rebote (<code>debounce_time</code>), se filtran. Los estados, como muestran la figura, son:</p> <ul> <li> <p><code>BUTTON_RELEASED</code>: es el estado inicial de la FSM. En este estado la FSM est\u00e1 comprobando constantemente si se ha producido un flanco de bajada, i.e., si se ha pulsado el bot\u00f3n. Cuando este se produce, guarda el instante actual y calcula el timeout del tiempo de guarda.</p> </li> <li> <p><code>BUTTON_PRESSED_WAIT</code>: se queda esperando en este estado hasta que ha pasado el tiempo de guarda de anti-rebotes, i.e., hasta que el instante actual es mayor que el timeout. Este es el anti-rebote de bajada. Al salir, no hace nada (funci\u00f3n, <code>NULL</code>).</p> </li> <li> <p><code>BUTTON_PRESSED</code>: en este estado se queda mientras no se suelte el bot\u00f3n. Saldr\u00e1 de \u00e9l cuando se haya detectado un flanco de subida. Ya ha pasado el tiempo de guarda, por lo que si es un rebote, se detectar\u00e1 como falso (ver ). Cuando el flanco de subida se produce, se calcula la duraci\u00f3n de la pulsaci\u00f3n.</p> </li> <li> <p><code>BUTTON_RELEASED_WAIT</code>: se queda esperando en este estado hasta que ha pasado el tiempo de guarda de anti-rebotes, i.e., hasta que el instante actual es mayor que el timeout. Este es el anti-rebote de subida. Al salir, no hace nada (funci\u00f3n, <code>NULL</code>).</p> </li> </ul> <p>La parte <code>COMMON</code> de nuestra librer\u00eda trabaja con la estructura (<code>struct</code>) p\u00fablica que se muestra en la figura (b) de estructuras. Con p\u00fablica queremos decir que est\u00e1 declarada en el fichero <code>.h</code> y no el el <code>.c</code>, por lo que otros ficheros pueden declarar variables de este tipo.</p> <ol> <li> <p>Lo primero, descarga del repositorio de la asignatura los ficheros correspondientes a la parte COMMON de la librer\u00eda del bot\u00f3n correspondientes a la versi\u00f3n <code>V1</code>: https://github.com/sdg2DieUpm/Simone/tree/simone_v1. Solo descarga lo que faltaba por implementar, es decir, los ficheros <code>fsm_button.h</code> y <code>fsm_button.c</code> y ponlos en las carpetas correspondientes de tu proyecto.</p> <p>Ahora, vamos a completar la cabecera de la FSM del bot\u00f3n, <code>fsm_button.h</code>.</p> </li> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Ahora vamos a definir el enumerado con los nombres de los 4 estados de la FSM. Escribe un <code>enum</code> <code>FSM_BUTTON</code> con los nombres de los estados del diagrama de la separados por <code>,</code>. No olvides poner un <code>;</code> al final del <code>enum</code>.</p> </li> <li> <p>Seguidamente declararemos la estructura <code>fsm_button_t</code> para hacerla p\u00fablica como indica la figura de la estructura de la FSM.</p> </li> <li> <p>Es buen momento para aprovechar a documentar la estructura, del mismo modo que se hizo anteriormente y se muestra en la figura de comentario.</p> <p></p>Comentario de Doxygen en un campo de una estructura.<p></p> <p>Continuamos con las declaraciones de funciones p\u00fablicas de la librer\u00eda. Procedamos:</p> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>fsm_button.h</code>.</p> <p>Como puedes intuir, estas no son todas las funciones de la librer\u00eda, sino solo aquellas que podr\u00e1n ser llamadas desde el exterior. Hemos establecido un criterio general por el que diremos que, si una funci\u00f3n va a ser accesible desde el exterior, el nombre de la funci\u00f3n debe empezar por <code>fsm_</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen. En este caso, la documentaci\u00f3n va encima del nombre de cada funci\u00f3n.</p> </li> </ol> <p>Ya hemos acabado con el encabezado. Quiz\u00e1s de errores al compilar. Vamos ahora a programar el fichero fuente <code>fsm_button.c</code>.</p>"},{"location":"notebook/version_1.html#sec:fsm_button_c","title":"<code>COMMON</code>: fuente de la FSM del bot\u00f3n","text":"<p>Vamos a proceder con la implementaci\u00f3n de las funciones del bot\u00f3n. Deber\u00e1s implementar todas las funciones p\u00fablicas de las que ya has declarado el prototipo en el encabezado, y el resto de funciones privadas que aparecen en la API del fichero <code>fsm_button.c</code>. Tambi\u00e9n definiremos las variables globales y estructuras que sean necesarias. \u00a1Recuerda que las funciones privadas no se declaran en el <code>.h</code>!</p> <ol> <li> <p>Lo primero que debe aparecer es la inclusi\u00f3n de cabeceras; en nuestro caso <code>fsm_button.h</code>, <code>port_button.h</code>, y <code>port_system.h</code> como indica la API.</p> <p>Ahora empezamos a codificar las funciones privadas de la FSM. Empezaremos con las funciones de entrada o comprobaci\u00f3n de la FSM. Hemos establecido un criterio general por el que, si una funci\u00f3n es de entrada o comprobaci\u00f3n, ser\u00e1 privada y est\u00e1tica, y el nombre de la funci\u00f3n va empezar por <code>check_</code> (porque comprueba la condici\u00f3n de salto de la m\u00e1quina de estados). Es muy importante aqu\u00ed que hayas entendido bien los ejemplos con FSM de los tutoriales  \u201cCap\u00edtulo 2. Introducci\u00f3n a las m\u00e1quinas de estados en C\u201d y \u201cCap\u00edtulo 3. M\u00e1quinas de Estados Combinadas\u201d.</p> <p>IMPORTANTE</p> <p>Si te fijas en la API, todas las funciones de la m\u00e1quina de estados reciben el mismo argumento: <code>fsm_t*</code>, un puntero a una m\u00e1quina de estados.</p> <p><code>fsm_button_t *p_fsm = (fsm_button_t *)(p_this);</code></p> <p>Esto es as\u0131\u0301 porque la librer\u0131\u0301a <code>fsm.c</code> no sabe qu\u00e9 tipo de m\u00e1quina de estados es. Nosotros sabemos que esta m\u00e1quina de estados es una m\u00e1quina con esteroides porque incluye, adem\u00e1s, la estructura del bot\u00f3n. En realidad es tipo <code>fsm_button_t*</code>, un puntero a una m\u00e1quina de estados de la estructura del bot\u00f3n, que por tener en su primer campo una <code>fsm_t*</code>, podemos hacer un cast y convertirla. As\u0131\u0301 pues, en las funciones de la m\u00e1quina de estados, siempre tendremos que recuperar nuestro tipo haciendo este cast como nos dice la API y hace, por ejemplo, la funci\u00f3n <code>fsm_button_init()</code>. En el resto de funciones que no se pasen a la librer\u0131\u0301a <code>fsm.c</code>, trabajaremos directamente con el tipo <code>fsm_button_t*</code> que hemos creado.</p> </li> <li> <p>Codifica la funci\u00f3n <code>check_button_pressed()</code> como se indica en la API.</p> </li> <li> <p>Codifica la funci\u00f3n <code>check_button_released()</code> como se indica en la API.</p> </li> <li> <p>Codifica la funci\u00f3n <code>check_timeout()</code> como se indica en la API.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen. En este caso, como las funciones no est\u00e1n declaradas en el encabezado, la documentaci\u00f3n ir\u00e1 en el <code>.c</code>, encima del nombre de cada funci\u00f3n.</p> <p>Seguiremos con las funciones de salida o actualizaci\u00f3n de la FSM. Hemos establecido el criterio de que, una funci\u00f3n de salida o actualizaci\u00f3n ser\u00e1 privada y est\u00e1tica, y el nombre de la funci\u00f3n empezar\u00e1 por <code>do_</code> (porque va a hacer algo). Hay veces que no hay que hacer nada, por lo que para la librer\u00eda <code>fsm.c</code> ser\u00e1 suficiente que apunte a <code>NULL</code>. Esto en el diagrama de la se ha representado como <code>n/a</code>.</p> </li> <li> <p>Codifica la funci\u00f3n <code>do_store_tick_pressed()</code> como se indica en la API.</p> </li> <li> <p>Codifica la funci\u00f3n <code>do_set_duration()</code> como se indica en la API.</p> </li> <li> <p>Documenta las funciones con Doxygen. En este caso, igual que antes, la documentaci\u00f3n ir\u00e1 en el <code>.c</code>, encima del nombre de cada funci\u00f3n.</p> <p></p>Error de compilaci\u00f3n durante el desarrollo de <code>fsm_button.c</code>.<p></p> <p>Todav\u00eda no hemos acabado con el desarrollo, pero vamos a compilar para ir depurando errores. Compile el programa. Ver\u00e1 errores parecidos a los que se muestran en la figura de error. El compilador a veces nos da alguna sugerencia de correcci\u00f3n, pero no tienen por qu\u00e9 ser correctas. Nos dice que:</p> <ul> <li> <p>Hay una variable que no est\u00e1 declarada y que se llama <code>fsm_trans_button</code>. Se trata de la tabla de transiciones. A\u00fan tenemos que escribirla.</p> </li> <li> <p>Todas nuestras funciones <code>check_</code> y <code>do_</code> est\u00e1n declaradas pero no se usan.</p> <p>\u00bfPor qu\u00e9 no dice lo mismo de las funciones p\u00fablicas que est\u00e1n declaradas en el <code>.h</code> y tampoco se usan? Pues porque son p\u00fablicas. El compilador no sabe qui\u00e9n las podr\u00e1 usar y ah\u00ed est\u00e1n declaradas para qui\u00e9n la pueda llamar. \u00bfPor qu\u00e9 en el <code>.c</code> da error? Porque en el <code>Makefile</code> \u2014donde est\u00e1n las reglas de compilaci\u00f3n\u2014, igual que tenemos el flag para que nos d\u00e9 error si la variable no se usa, lo mismo pasa con las funciones. Esto es \u00fatil para evitar generar c\u00f3digos sucios con funciones que no sirven.</p> <p>\u00bfQui\u00e9n va a usar las funciones de la m\u00e1quina de estados? Pues las va a usar, mediante indirecci\u00f3n, la librer\u00eda <code>fsm.c</code>. \u00bfC\u00f3mo? Porque le vamos a pasar a la funci\u00f3n <code>fsm_fire()</code> la tabla de transiciones. Y es ah\u00ed, donde vamos a \u201cusar\u201d estas funciones. \u00bfY d\u00f3nde se llama a <code>fsm_fire</code>? Ya lo haremos, pero se hace en <code>fsm_button_fire()</code>, que a su vez es llamada por el <code>main</code>.</p> </li> <li> <p>Si las us\u00e1semos, aparecer\u00eda el error de que hay funciones que no est\u00e1n declaradas (implicit declaration). Son las llamadas a funciones del <code>PORT</code>, que m\u00e1s tarde codificaremos.</p> </li> </ul> <p>Mucha informaci\u00f3n hasta ahora, pero ver\u00e1 c\u00f3mo se aclara todo enseguida. Vamos a codificar la tabla (array) de transiciones de la FSM del bot\u00f3n.</p> </li> <li> <p>Definimos <code>static fsm_trans_t fsm_trans_button[] = ...</code> justo despu\u00e9s de la funci\u00f3n <code>do_set_duration()</code>.</p> <p>Recuerda que cada fila de la tabla de transiciones tiene la forma: <code>EstadoIni, FuncCompruebaCondicion, EstadoSig, FuncAccionesSiTransicion</code>. No olvides a\u00f1adir la fila <code>-1, NULL, -1, NULL</code> que sirve a la librer\u00eda <code>fsm.c</code> para detectar el fin de la tabla.</p> <p>\u00bfPor qu\u00e9 es importante haber colocado la tabla en este punto? Bueno, puede ser en cualquier punto despu\u00e9s de las funciones <code>check_</code> y <code>do_</code>, porque de lo contrario, de estar m\u00e1s arriba, al compilar, la tabla de transiciones estar\u00eda haciendo referencia a funciones que todav\u00eda no se sabe que existen (\u00a1porque son privadas y no est\u00e1n en el <code>.h</code>!).</p> <p>Si ahora compilas, ver\u00e1s que han desaparecido muchos errores. Ya queda menos para acabar la implementaci\u00f3n de la librer\u00eda de la m\u00e1quina de estados. Prosigamos:</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_button_get_duration()</code> como se indica en la API. Esta funci\u00f3n nos servir\u00e1 en el programa principal para preguntar cu\u00e1nto tiempo ha durado la pulsaci\u00f3n.</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_button_reset_duration()</code> como se indica en la API. Con esta, reiniciaremos el valor de la duraci\u00f3n a \\(0 ms\\) tras leerlo.</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_button_get_debounce_time_ms()</code> como se indica en la API. Esta funci\u00f3n ser\u00e1 usada en los test unitarios.</p> </li> <li> <p>Completa la funci\u00f3n <code>fsm_button_init()</code> como se indica en la API.</p> <p>F\u00edjate en las funciones <code>fsm_button_fire()</code> dada, que implementaremos tambi\u00e9n sucesivas versiones. Esta funci\u00f3n sirve para lanzar la m\u00e1quina de estados (<code>f</code>). Ser\u00e1 usadas en el test unitario de la m\u00e1quina de estados, en e\u00f1 <code>main.c</code>, y son \u00fatiles para depurar.</p> <p>Ya hemos acabado con la programaci\u00f3n de la librer\u00eda del bot\u00f3n. Toda esta l\u00f3gica <code>COMMON</code> puede ser usada en cualquier sistema, est\u00e9 basado en microcontrolador, o sea un PC. Hemos hecho una librer\u00eda de un bot\u00f3n que tiene un anti-rebotes y nos devuelve la duraci\u00f3n de la \u00faltima pulsaci\u00f3n. As\u00ed pues, si compilas, no deber\u00e1n aparecer errores.</p> </li> <li> <p>Documenta el c\u00f3digo que est\u00e9 sin comentar.</p> </li> </ol>"},{"location":"notebook/version_1.html#sec:test_fsm_v1","title":"<code>COMMON</code> Test unitario de la FSM del bot\u00f3n","text":"<p>Vamos a probar el test del c\u00f3digo que hemos desarrollado de la librer\u00eda de la m\u00e1quina de estados del bot\u00f3n y probar que funciona antes de continuar con la siguiente versi\u00f3n. \u00a1Importante! Recuerda que los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente.</p> <p>Descarga el fichero de test de la FSM del bot\u00f3n <code>test_fsm_button.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v1_test. Ponlo en la carpeta <code>test/</code> de tu proyecto. \u00a1No lo metas en stm32f4/, pues no es un test espec\u00edfico del microcontrolador!</p> <ol> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_fsm_button</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso.</p> </li> <li> <p>Se habr\u00e1 impreso por la terminal del <code>gdb-server</code> el resultado de las pruebas de los tests. Deber\u00eda haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu c\u00f3digo hasta que pasen todas las pruebas. Si no pasan las pruebas, no contin\u00faes.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pasen todos los test.</p> </li> </ol>"},{"location":"notebook/version_1.html#ejemplo-de-uso-de-la-version-1","title":"Ejemplo de uso de la Versi\u00f3n 1","text":"<p>Com\u00fanmente llamado test de integraci\u00f3n, es un c\u00f3digo de ejemplo que consiste en probar la librer\u00eda en el sistema final, o en una versi\u00f3n particular, con el resto de librer\u00edas y m\u00f3dulos. El test de integraci\u00f3n no hace uso de la librer\u00eda <code>unity</code>, sino que es como un peque\u00f1o programa de prueba sobre las funciones que hemos implementado. Tiene su propio <code>main</code>.</p> <p>En los test de integraci\u00f3n es responsabilidad del alumno comprobar que la funcionalidad es la esperada, porque aqu\u00ed no hay test unitarios que nos ayuden.</p> <p>Nuestra librer\u00eda de bot\u00f3n devuelve la duraci\u00f3n de la \u00faltima pulsaci\u00f3n. As\u00ed pues, algunas de las comprobaciones que podemos hacer son: que la duraci\u00f3n de la pulsaci\u00f3n es la que esperamos, que se reinicia adecuadamente el valor, que funciona el anti-rebotes\u2026</p> <p>Descarga el fichero de ejemplo <code>example_v1.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v1_test. Ponlo en la carpeta <code>example/</code> de tu proyecto.</p> <p>Procedamos:</p> <ol> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>example_v1</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Se parar\u00e1 en la primera l\u00ednea del <code>main()</code>. Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso. Este c\u00f3digo no termina, pues es un bucle <code>while</code> infinito.</p> </li> <li> <p>Abre la terminal del <code>gdb-server</code> para ver los mensajes que se van imprimiendo.</p> </li> <li> <p>Pulsa el bot\u00f3n de usuario <code>B1</code> de la placa. Deber\u00edas ver que se imprime por pantalla la duraci\u00f3n de la pulsaci\u00f3n. Si no es as\u00ed, revisa tu c\u00f3digo.</p> </li> <li> <p>Haz distintas pruebas y aseg\u00farate de que el comportamiento es el adecuado.</p> </li> </ol> <p>\u00a1Hemos creado nuestra primera librer\u00eda! F\u00edjate que es portable a cualquier plataforma solo con adaptar las funciones del <code>PORT</code>.</p> <p>No dejes de documentar el c\u00f3digo. Comprueba que la documentaci\u00f3n del c\u00f3digo se ha generado correctamente como se explica en la \u201cGu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C\u201d <sup>7</sup>., o en el v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d.</p> <p>Guarda una copia de su proyecto como <code>simone_v1</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla.</p> <ol> <li> <p>No nos hacemos responsables de posibles da\u00f1os que puedas ocasionar\u00a0.\u00a0\u21a9</p> </li> <li> <p>Se recomienda documentar sus c\u00f3digos siempre en ingl\u00e9s, aunque su nivel no sea muy bueno, porque si trabajamos en una empresa, no sabemos qui\u00e9n lo tendr\u00e1 que leer.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Juan Jos\u00e9 G\u00f3mez Valverde. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/88460/.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> <li> <p>Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Josu\u00e9 Pag\u00e1n Ortiz, Alberto Bosc\u00e1 Mojena, Iv\u00e1n Mart\u00edn Fern\u00e1ndez, and Sergio Esteban Romero. Tutoriales sobre los fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Rom\u00e1n C\u00e1rdenas Rodriguez, Madrid, March 2025. URL: https://oa.upm.es/88470/.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Amadeo de Gracia Herranz, Sergio Esteban Romero, and Daniel Capell\u00e1n Mart\u00edn. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/92376/.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"notebook/version_2.html","title":"Versi\u00f3n 2","text":""},{"location":"notebook/version_2.html#cha:version2","title":"Versi\u00f3n 2: teclado matricial","text":"<p>En la Versi\u00f3n 1 aprendimos a gestionar un \u00fanico bot\u00f3n mediante interrupciones. Sin embargo, \u00bfqu\u00e9 ocurre si nuestro sistema necesita 12, 16 o m\u00e1s botones? Si utiliz\u00e1ramos la estrategia anterior, necesitar\u00edamos una l\u00ednea de interrupci\u00f3n y un pin GPIO por cada bot\u00f3n, agotando r\u00e1pidamente los recursos del microcontrolador.</p> <p>Para solucionar esto, utilizamos la t\u00e9cnica del barrido o scanning en un teclado matricial. Esta t\u00e9cnica aprovecha la persistencia temporal para leer muchos pulsadores utilizando pocos pines, organiz\u00e1ndolos en filas y columnas.</p> <p>Bibliograf\u00eda</p> <ol> <li> <p>\u201cFundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>3</sup></p> </li> <li> <p>Datasheet \u201cSTM32F446xC/E\u201d <sup>4</sup></p> </li> <li> <p>Reference manual \u201cRM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>5</sup></p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Demostraci\u00f3n Simone</p> </li> <li> <p>Blink LED y manejo de proyecto</p> </li> <li> <p>Conceptos b\u00e1sicos de C (canal SDG1)</p> </li> <li> <p>[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen</p> </li> </ul> <p>En este cap\u00edtulo vamos a crear una librer\u00eda que nos permita gestionar un teclado matricial 4x4 (16 teclas) como el de la figura. A diferencia del bot\u00f3n, que funcionaba solo ten\u00edamos una interrupci\u00f3n, aqu\u00ed utilizaremos un temporizador que nos interrumpe para realizar una excitaci\u00f3n peri\u00f3dica de las filas y esperaremos interrupciones de las columnas.</p> Teclado matricial de membrana 4x4 usado en el proyecto Simone. <p>Como ya hicimos en las versiones anteriores, (i) vamos a implementar la parte portable <code>PORT</code> dependiente del HW para gestionar los niveles l\u00f3gicos de las filas y la lectura de las columnas, y lo probaremos con un test unitario. (ii) Despu\u00e9s, vamos a crear la l\u00f3gica de la FSM para gestionar el barrido y el anti-rebotes (la parte <code>COMMON</code>), y lo probaremos con un test unitario. (iii) Por \u00faltimo, montaremos el HW y probaremos el funcionamiento con un programa de ejemplo.</p> <p>El teclado matricial es un array de pulsadores conectados en intersecciones de filas y columnas. Cuando no se pulsa ninguna tecla, no hay conexi\u00f3n entre filas y columnas. Al pulsar una tecla, se cortocircuita una fila con una columna espec\u00edfica. Las caracter\u00edsticas a destacar del sistema de la Versi\u00f3n 2 se muestran en la siguiente tabla.</p> Par\u00e1metro Valor Pin fila 1 <code>PA0</code> Pin fila 2 <code>PA1</code> Pin fila 3 <code>PA4</code> Pin fila 4 <code>PB0</code> Modo filas Salida Pull up/ down filas No push, no pull Timeout de excitaci\u00f3n de filas \\(25 ms\\) Pin/ EXTI/ ISR columna 1 <code>PA8</code>/ <code>EXTI8</code>/ <code>EXTI9_5_IRQHandler</code> Pin/ EXTI/ ISR columna 2 <code>PB10</code>/ <code>EXTI10</code>/ <code>EXTI15_10_IRQHandler</code> Pin/ EXTI/ ISR columna 3 <code>PB4</code>/ <code>EXTI4</code>/ <code>EXTI4_IRQHandler</code> Pin/ EXTI/ ISR columna 4 <code>PB5</code>/ <code>EXTI5</code>/ <code>EXTI9_5_IRQHandler</code> Modo columnas Entrada Pull up/ down columnas Pull down Prioridad todas las columnas 1 Subprioridad todas las columnas 1 Tiempo anti-rebotes todas las columnas \\(100-200 ms\\)"},{"location":"notebook/version_2.html#caracteristicas-del-teclado-matricial-en-version-2","title":"Caracter\u00edsticas del teclado matricial en Versi\u00f3n 2","text":"(a) Circuio de un teclado matricial de membrana, (b) Esquema de conexiones. <p>Si tiene la oportunidad de abrir en casa cualquier sistema que tenga un teclado o botonera<sup>1</sup>, seguramente encuentre una circuiter\u00eda como la de la figura (a). La goma gris es la cara interna de los botones, que est\u00e1 sobre la PCB verde. Las almohadillas negras que ve son contactos met\u00e1licos que, cuando se pulsa el bot\u00f3n, se cortocircuitan con el metal de la PCB y cierran el circuito<sup>2</sup>.</p> <p>La idea de colocar los botones as\u00ed, haciendo una rejilla, es muy inteligente. Haciendo un enrejillado no es necesario tener un cable para cada bot\u00f3n, porque un cable por cada bot\u00f3n implicar\u00eda tener un pin de entrada en nuestro microcontrolador por cada uno (si no se usan multiplexores, claro), y los pines no es algo que sobre, generalmente, en los encapsulados de los chips. Por ejemplo, en el teclado de la figura (a) se usan 10 cables para 24 botones (ahorro del \\(58.3\\%\\) de conexiones/pines), y en el del teclado del laboratorio se usar\u00e1n 8 conexiones para 16 botones (ahorro del \\(50.0\\%\\)).</p> <p>Pero esta idea no sale gratis. A cambio de reducir el hardware necesario, tenemos que complicar el software un poquito. Debemos ir excitando \u2014poniendo tensi\u00f3n\u2014 las filas o columnas de forma c\u00edclica para poder detectar qu\u00e9 bot\u00f3n se ha pulsado (lo hacemos leyendo las columnas o filas respectivamente). Si alguna columna detecta esa tensi\u00f3n, sabemos qu\u00e9 tecla exacta (intersecci\u00f3n fila-columna) se ha pulsado. Este proceso se repite para todas las filas r\u00e1pidamente. En nuestro caso excitaremos filas. F\u00edjate que solo podemos tener una fila con tensi\u00f3n a la vez porque, de otro modo, no ser\u00edamos capaces de distinguir entre los botones de una misma columna. Si haces un dibujo, lo ver\u00e1s f\u00e1cilmente.</p> <p>No te preocupes, la gesti\u00f3n de filas y columnas tiene f\u00e1cil soluci\u00f3n si trabajamos con las m\u00e1quinas de estado; pues para controlar la excitaci\u00f3n de las filas del teclado matricial tendremos la FSM del teclado.</p> Diagrama de temporizaci\u00f3n de excitaci\u00f3n de filas. <p>El diagrama de temporizaci\u00f3n muestra c\u00f3mo se excitan las filas del teclado. Cada \\(25 ms\\) se excita una fila diferente poniendo un nivel l\u00f3gico alto en el pin correspondiente. Durante ese tiempo que est\u00e1 la fila en alto, se puede producir interrupci\u00f3n si se pulsa alguna tecla de esa fila. Luego, se desactiva la fila (nivel l\u00f3gico bajo) y se excita la siguiente fila. As\u00ed, en un per\u00edodo de \\(100 ms\\) se excitan todas las filas del teclado. Este tiempo es suficientemente r\u00e1pido para que el usuario no note que las filas se excitan de forma secuencial.</p> Ejemplo de excitaci\u00f3n de fila R1, pulsando tecla 3, generando interrupci\u00f3n en pin conectado a columna C3. <p>La figura de ejemplo muestra un ejemplo de c\u00f3mo funcionar\u00e1 el sistema. En este caso, la FSM del teclado est\u00e1 excitando la fila R1 poniendo un nivel l\u00f3gico alto en el pin correspondiente (cada \\(25 ms\\) excita una fila). Cuando se pulsa la tecla '3', se cierra el circuito entre la fila R1 y la columna C3, lo que hace que el pin conectado a C3 detecte un nivel l\u00f3gico alto (\\(3.3 V\\)).</p> <p>En este circuito vamos a activar las resistencias de pull-down \u00a1internas! de los pines del microcontrolador conectados a las columnas, por lo que cuando no se pulsa ninguna tecla, las columnas estar\u00e1n a nivel l\u00f3gico bajo (\\(0 V\\)). Al pulsar la tecla '3', la columna C3 pasa a nivel l\u00f3gico alto debido a la conexi\u00f3n con la fila R1 que est\u00e1 excitada. Pasa lo contrario que con el circuito del bot\u00f3n, que ten\u00eda una resistencia de pull-up \u00a1externa! Esto genera una interrupci\u00f3n en el microcontrolador, que puede entonces identificar qu\u00e9 tecla se ha pulsado bas\u00e1ndose en la fila actualmente excitada y la columna que ha generado la interrupci\u00f3n.</p> <p>Recuerda que, como hicimos con el bot\u00f3n, estamos desarrollando una librer\u00eda. El teclado matricial no tiene por qu\u00e9 saber nada de las acciones que hace el sistema cuando se pulsa una tecla. Es por eso que en nuestro proyecto, el teclado se encargar\u00e1 solo de guardar la tecla pulsada y de avisar de que ha habido una pulsaci\u00f3n. El sistema que use esta librer\u00eda \u2014sea en este proyecto u otro\u2014 deber\u00e1 comprobar dicho valor guardado con un get. La idea es exactamente la misma que la que implement\u00f3 en el bot\u00f3n. As\u00ed, cada vez que se quiera a\u00f1adir un teclado, le asociaremos una FSM. Las particularidades de d\u00f3nde est\u00e1n conectadas las filas y columnas son cosas espec\u00edficas del HW, por lo que estar\u00e1n en <code>PORT</code>.</p> (a) Estructura del HW del teclado en PORT, (b) Estructura de la FSM del teclado en COMMON. <p>Las figuras de estructuras HW y SW muestran las estructuras que vamos a necesitar para el teclado. La estructura del HW del teclado en <code>PORT</code>. El <code>PORT</code> de otro microcontrolador podr\u00eda implementar internamente una estructura diferente, por eso est\u00e1 dentro de la carpeta <code>stm32f4</code>. Por ejemplo, al portar el c\u00f3digo para PC no tendr\u00eda sentido definir la estructura de una GPIO. La estructura de la FSM del teclado en <code>COMMON</code> se muestra en la figura de la FSM.</p> <p>Como en el caso del bot\u00f3n aqu\u00ed, aunque no hay muelles, puede haber igualmente inestabilidades en la pulsaci\u00f3n, rebotes, por lo e vamos a implementar, igualmente, un mecanismo antirebotes. Dejaremos unos tiempos de guarda de antirebotes tambi\u00e9n entre \\(100-200 ms\\).</p> <p>En el caso del teclado matricial no tenemos circuito preestablecido, por lo que podemos elegir libremente si queremos usar resistencias de pull-up o pull-down en las columnas. En este caso, usaremos resistencias de pull-down en las columnas y excitaremos las filas poniendo un nivel l\u00f3gico alto. As\u00ed, cuando se pulsa una tecla, la columna correspondiente pasa a nivel alto. Esto es al rev\u00e9s de como pasaba en el bot\u00f3n.</p> <p>Ahora s\u00ed, comencemos. Preparemos el proyecto para poder a\u00f1adir el teclado matricial:</p> <ol> <li>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT de la librer\u00eda del keyboard correspondientes a la versi\u00f3n <code>V2</code>: https://github.com/sdg2DieUpm/simone/tree/simone_v2. Solo descarga por ahora: <code>port_keyboard.h</code>, <code>stm32f4_keyboard.h</code>, y <code>stm32f4_keyboard.c</code> y col\u00f3calos en las carpetas correspondientes. De la parte COMMON descarga solo <code>keyboards.h</code>, y <code>keyboards.c</code>, que incluyen los layouts de los teclados matriciales.</li> <li>Coloca cada uno donde corresponde: <code>PORT</code> o <code>COMMON</code>, en <code>include</code>, o <code>src</code>. Ten en cuenta que algunos ficheros de <code>PORT</code> est\u00e1n en la carpeta <code>stm32f4</code> porque sus funciones reciben o devuelven estructuras espec\u00edficas de la Nucleo-STM32F446RE.</li> </ol> <p>Ver\u00e1s que no compila, y es que solo se te proporciona cierta parte del c\u00f3digo. Los prototipos de gran parte de las funciones p\u00fablicas no est\u00e1n definidos.</p>"},{"location":"notebook/version_2.html#sec:layouts_keyboards","title":"Layouts de teclados matriciales","text":"<p>Antes de ponernos a programar, conviene explicar qu\u00e9 son los ficheros <code>keyboards.h</code> y <code>keyboards.c</code>. Estos ficheros se han de colocar en la carpeta <code>common/include</code> y <code>common/src</code> respectivamente. Estos ficheros contienen los layouts de los teclados matriciales que queramos usar en nuestro proyecto. Un layout es una matriz que define qu\u00e9 car\u00e1cter representa cada tecla del teclado. Por ejemplo, en un teclado 4x4 t\u00edpico, la primera fila podr\u00eda representar los caracteres '1', '2', '3', 'A'; la segunda fila '4', '5', '6', 'B'; y as\u00ed sucesivamente, pero otro de 4x4 tambi\u00e9n podr\u00eda tener una distribuci\u00f3n diferente (solo letras, o solo n\u00fameros), \u00a1o tener otro de 1x3 de colores!...</p> <p>Estos ficheros permiten definir m\u00faltiples layouts para diferentes teclados matriciales, facilitando su uso en la librer\u00eda del teclado. En la Versi\u00f3n 5 podr\u00edas querer a\u00f1adir un nuevo layout de alg\u00fan teclado extra, o modificar el existente.</p> <p>La estructura <code>keyboard_t</code> definida en <code>keyboards.h</code> contiene:</p> <ul> <li>Un puntero a una matriz de caracteres (<code>const char *keys</code>), que representa el layout del teclado.</li> <li>El n\u00famero de filas (<code>uint8_t rows</code>) y columnas (<code>uint8_t cols</code>) del teclado.</li> <li>Un caracter especial (<code>char null_key</code>) que indica que no se ha pulsado ninguna tecla. Por ejemplo el caracter ASCII nulo <code>'\\0'</code>.</li> </ul> <p>En el mismo fichero se declara <code>standard_keyboard</code> como un ejemplo de layout para un teclado matricial 4x4. El nombre es algo gen\u00e9rico y representativo. Este layout se define en <code>keyboards.c</code> como una matriz de caracteres que representa las teclas del teclado. Aqu\u00ed se hace p\u00fablico para que pueda ser usado en otras partes del c\u00f3digo; sus particularidades se definen en el <code>.c</code>.</p>"},{"location":"notebook/version_2.html#sec:headers_keyboard","title":"<code>PORT</code>: cabeceras de la librer\u00eda del teclado","text":"<p>Vamos a implementar el contrato con el usuario de la parte dependiente del HW de librer\u00eda del teclado. Esta interfaz permitir\u00e1 configurar las filas y columnas de nuestro teclado y realizar el barrido de excitaci\u00f3n de filas y lectura de columnas para identificar la tecla pulsada.</p> <p>El montaje de nuestro m\u00f3dulo teclado matricial tendr\u00e1 un aspecto como el mostrado en la figura.</p> Montaje del teclado matricial con la Nucleo-STM32F446RE <p>M\u00e1s adelante lo implementaremos.</p>"},{"location":"notebook/version_2.html#cabecera-port_keyboardh","title":"Cabecera port_keyboard.h","text":"<p>Esta cabecera depende del HW pero no de las particularidades del microcontrolador STM32F446RE. Vamos a seguir los siguientes pasos:</p> <ol> <li>Incluye todas las cabeceras necesarias seg\u00fan indica la API.</li> <li> <p>Incluye los (<code>#define</code>) necesarios para el teclado: el identificador <code>PORT_KEYBOARD_MAIN_ID</code> que usaremos en el proyecto Simone, el timeout de excitaci\u00f3n de filas, y el tiempo de antirebotes de las teclas (mismo tiempo para todas).</p> <p>Hemos decidido darle el nombre <code>PORT_KEYBOARD_MAIN_ID</code> al teclado que usaremos en el juego. En la Versi\u00f3n 5 podr\u00edamos querer a\u00f1adir m\u00e1s teclados, y entonces habr\u00eda que definir m\u00e1s identificadores con otros nombres representativos. 3. Define el enumerado que identifica los \u00edndices de las columnas del teclado, y que ser\u00e1 de utilidad para hacer el c\u00f3digo m\u00e1s legible en el manejo de las interrupciones. 4. Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_keyboard.h</code>. 5. Puede ser buen momento ahora para documentar con Doxygen.</p> </li> </ol>"},{"location":"notebook/version_2.html#cabecera-stm32f4_keyboardh","title":"Cabecera stm32f4_keyboard.h","text":"<p>Esta cabecera define los pines f\u00edsicos a los que est\u00e1n conectadas las filas y columnas de los teclados que usemos con nuestra placa Nucleo-STM32F446RE.</p> <ol> <li>Incluye todas las cabeceras necesarias.</li> <li> <p>Define (<code>#define</code>) los valores de las GPIO y pines para las 4 filas y las 4 columnas seg\u00fan indica la tabla de caracter\u00edsticas del teclado matricial.</p> </li> <li> <p>Declara la estructura <code>stm32f4_keyboard_hw_t</code> que contendr\u00e1 la configuraci\u00f3n f\u00edsica del teclado.</p> <p>Presta atenci\u00f3n a la documentaci\u00f3n que explica en cada campo qu\u00e9 deber\u00e1 contener. Recuerda que las filas son salidas y las columnas entradas.</p> <p>Especial menci\u00f3n merecen los campos <code>p_row_ports</code> y <code>p_col_ports</code>, que son dobles punteros: punteros a arrays de punteros a estructuras <code>GPIO_TypeDef</code>. Estos campos permiten almacenar las referencias a los puertos GPIO de cada fila y columna del teclado. Esta es la forma de poder definir una estructura gen\u00e9rica sin saber el tama\u00f1o del teclado que va a gestionar. Nos da lo mismo que definamos un teclado de 2x2, 4x4 o 5x3; por eso estos campos son punteros que apuntar\u00e1n a arrays de elementos de tipo <code>GPIO_TypeDef*</code> (por ejemplo, <code>GPIOA</code>, <code>GPIOB</code>, etc.). As\u00ed, podemos tener una lista din\u00e1mica de puertos para las filas y columnas del teclado, adapt\u00e1ndonos a cualquier configuraci\u00f3n f\u00edsica que necesitemos.</p> <p>El campo <code>p_layout</code> es un puntero a una estructura <code>keyboard_t</code>, que contiene el layout del teclado. Esto nos permite asociar el dise\u00f1o l\u00f3gico del teclado con su configuraci\u00f3n f\u00edsica. Se declara <code>const</code> porque el layout no debe modificarse en tiempo de ejecuci\u00f3n.</p> <p>F\u00edjate tambi\u00e9n que la estructura NO guarda la tecla pulsada, sino que guarda el \u00edndice de la fila que se est\u00e1 excitando y la columna que genera la interrupci\u00f3n. La gesti\u00f3n de la tecla pulsada se har\u00e1 en la FSM del teclado, que es independiente del HW.</p> </li> <li> <p>Declara el array de estructuras de tipo <code>stm32f4_keyboard_hw_t</code> como se hizo con el bot\u00f3n. Este array contendr\u00e1 las caracter\u00edsticas de todos los teclados que tengamos en el sistema.</p> </li> <li> <p>Documenta todo con Doxygen.</p> </li> </ol> <p>Ya hemos acabado con el encabezado (header) que interact\u00faa con el HW. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a implementar todas las funciones prototipadas en <code>port_keyboard.h</code>.</p>"},{"location":"notebook/version_2.html#sec:port_keyboard","title":"<code>PORT</code>: fuente de la librer\u00eda del teclado","text":"<p>Vamos a portar las funciones necesarias para controlar los pines del teclado. Programaremos los ficheros fuente de la parte <code>PORT</code>, que todos estar\u00e1n en el fichero <code>stm32f4_keyboard.c</code>.</p>"},{"location":"notebook/version_2.html#fuentes-stm32f4_keyboardc","title":"Fuentes stm32f4_keyboard.c","text":"<p>La complejidad aqu\u00ed reside en la gesti\u00f3n de m\u00faltiples pines y en la l\u00f3gica de configuraci\u00f3n de entrada/salida.</p> <ol> <li>Incluye las librer\u00edas necesarias.</li> <li>Ver\u00e1s que en la plantilla proporcionada se han definido 4 arrays que corresponden con laos puertos y pines de las filas y columnas del teclado. Estos arrays se usan para inicializar la estructura del teclado. Estos son los arrays de elementos <code>GPIO_TypeDef*</code> (y <code>uint8_t</code>) de los que hablabamos anteriormente y alos que apuntar\u00e1 la estructura <code>stm32f4_keyboard_hw_t</code> del teclado principal <code>KEYBOARD_MAIN</code>.</li> <li> <p>Define la variable global privada <code>stm32f4_keyboard_hw_t keyboards_arr</code> con la configuraci\u00f3n f\u00edsica de nuestro teclado tal y como hicimos con el bot\u00f3n. Los campos <code>p_row_ports</code>, <code>p_row_pins</code>, <code>p_col_ports</code>, y <code>p_col_pins</code> deben apuntar a los arrays definidos en el paso anterior. El campo <code>p_layout</code> debe apuntar a la direcci\u00f3n de memoria del layout del teclado est\u00e1ndar definido en <code>keyboards.c</code>. El resto de campos se inicializan en la funci\u00f3n <code>port_keyboard_init()</code>.</p> </li> <li> <p>Codifica la funci\u00f3n <code>_stm32f4_keyboard_get()</code> para recuperar la configuraci\u00f3n del hardware, de modo an\u00e1logo a como se hizo para el bot\u00f3n.</p> </li> <li> <p>Codifica la funci\u00f3n <code>port_keyboard_init()</code> como se indica en la API.</p> <p>Recuerda que es muy importante indicar en el modo de las interrupciones de las columnas del teclado que, adem\u00e1s de detectar ambos flancos (subida y bajada), debe habilitar la petici\u00f3n de interrupci\u00f3n (registro <code>EXTI_IMR</code>).</p> <p>Se recomienda usar bucles para configurar las filas y columnas, y evitar el spaghetti code. Esto hace que el c\u00f3digo sea m\u00e1s compacto y f\u00e1cil de leer y mantener.</p> </li> <li> <p>Codifica la funci\u00f3n <code>port_keyboard_excite_row()</code> como se indica en la API. Esta funci\u00f3n debe activar la fila indicada y \u00a1desactivar las restantes!</p> </li> <li> <p>Codifica la funci\u00f3n <code>port_keyboard_excite_next_row()</code> como se indica en la API. Esta funci\u00f3n llama a la anterior pero antes actualiza <code>current_excited_row</code>, que es el \u00edndice de la fila a ser excitada.</p> </li> <li> <p>Codifica todos los getters y setters que aparecen en el <code>.h</code> como indica la API. Especial atenci\u00f3n a la funci\u00f3n <code>port_keyboard_get_key_value()</code>, que debe devolver el car\u00e1cter ASCII correspondiente a la tecla pulsada, usando el layout del teclado.</p> <p>Como en nuestra estructura no tenemos definida de manera fija el array del layout del teclado, sino que tenemos un puntero a una estructura <code>keyboard_t</code>, no podemos acceder directamente al array de teclas tratado como matriz bidimensional con los \u00edndices de la fila y columna. En su lugar, debemos tratar el array como unidimensional -que es, por otro lado, como est\u00e1 almacenado en memoria- y calcular la posici\u00f3n del caracter de la tecla pulsada usando la f\u00f3rmula:</p> <pre><code>key index = (excited row * num columns) + column interrupting\n</code></pre> <p>Vamos a codificar ahora las funciones que gestionan el temporizador que controla la excitaci\u00f3n de las filas.</p> <p></p><p></p> Par\u00e1metro Valor Temporizador <code>TIM5</code> Prescaler (a calcular para <code>PORT_KEYBOARDS_TIMEOUT_MS</code>) Periodo (a calcular para <code>PORT_KEYBOARDS_TIMEOUT_MS</code>) ISR <code>TIM5_IRQHandler</code> Prioridad 2 Subrioridad 0 </li> <li> <p>Codifica la funci\u00f3n <code>_timer_scan_column_config()</code> como indica la API. Esta funci\u00f3n configura el temporizador que controla el tiempo de excitaci\u00f3n de las filas de cualquier teclado que se monte en el juego; si hubiese m\u00e1s de uno, todos se excitar\u00edan a la vez. Para ello, ap\u00f3yate en el ejemplo \"timer para interrupci\u00f3n peri\u00f3dica\" del libro de fundamentos te\u00f3ricos\u00a0<sup>3</sup>.</p> <p>Esta funci\u00f3n configura un temporizador para que genere una interrupci\u00f3n de <code>PORT_KEYBOARDS_TIMEOUT_MS</code> milisegundos desde que se habilita el mismo. El temporizador elegido se muestra en la tabla de caracter\u00edsticas del teclado.</p> <p>Lo vamos a usar para que genere interrupciones peri\u00f3dicas. Lo activaremos cuando durante el juego sea turno del jugador que use el teclado matricial, y lo desactivaremos cuando se est\u00e9 reproduciendo la secuencia de colores.</p> <p>Para saber qu\u00e9 fuente de reloj habilitar para el temporizador, consulta la tabla \"Figure 3. STM32F446xC/E block diagram\" del datasheet \"STM32F446xC/E\" <sup>4</sup>. All\u00ed podr\u00e1s ver si nuestro temporizador est\u00e1 conectado al APB1 o al APB2, y tenemos que habilitar el reloj en el registro <code>RCC-&gt;APB1ENR</code> o <code>RCC-&gt;APB2ENR</code> respectivamente.</p> <p>Es importante que no pongas los valores de los registros de configuraci\u00f3n del temporizador a mano, sino que uses las ecuaciones que se proporcionan en el libro de fundamentos te\u00f3ricos\u00a0<sup>3</sup> para calcular los valores de los registros <code>TIMx-&gt;PSC</code> y <code>TIMx-&gt;ARR</code>. En cualquier momento podr\u00edamos querer cambiar el periodo de excitaci\u00f3n de filas y, si lo hacemos a mano, podr\u00edamos cometer errores, adem\u00e1s de que es menos legible.</p> <p>**Es muy importante que la funci\u00f3n <code>_timer_scan_column_config()</code> se llame desde la funci\u00f3n <code>port_keyboard_init()</code>. Si no, no se podr\u00e1n generar interrupciones para excitar filas y leer columnas.</p> </li> <li> <p>Codifica la funci\u00f3n <code>port_keyboard_start_scan()</code> que se encarga de habilitar las interrupciones del temporizador y activar la cuenta (reseteando el contador). En esta funci\u00f3n se resetea el flag <code>flag_row_timeout</code>, y se excita la primera fila del teclado.</p> </li> <li>Codifica la funci\u00f3n <code>port_keyboard_stop_scan()</code> que deshabilita las interrupciones del temporizador y detiene la cuenta. Del mismo modo, apaga todas las filas del teclado.</li> </ol> <p>**\u00a1Ya hemos acabado con la implementaci\u00f3n de la parte HW <code>stm32f\\_keyboard.c</code> del teclado. Ahora solo queda la ISR asociada a dicho temporizador en el fichero `interr.c``. Vamos a ello.</p>"},{"location":"notebook/version_2.html#interrc","title":"interr.c","text":"<p>Abre el fichero <code>interr.c</code>. Tenemos que codificar las ISR para gestionar las interrupciones de cada una de las columnas y del temporizador de excitaci\u00f3n de filas.</p> <p>Es muy importante que notes que algunas  est\u00e1n compartidas ISR por distintas l\u00edneas. Esto ya lo vimos en la Versi\u00f3n 1 con el bot\u00f3n. Por ejemplo la ISR <code>EXTI15_10_IRQHandler()</code> gestiona las interrupciones de las l\u00edneas 10 a la 15 de cualquier GPIO, y es por ello que hab\u00edamos puesto un <code>if</code> para identificar la fuente. Es ahora cuando le vas a encontrar m\u00e1s sentido a ese bloque condicional.</p> <p>F\u00edjate en las ISR de las interrupciones de las columnas del teclado matricial en la tabla de caracter\u00edsticas del teclado: 2 de las columnas comparten ISR, y otra de ellas la comparte con el bot\u00f3n. Vamos a codificar dichas ISR:</p> <ol> <li> <p>Completa la ISR <code>EXTI15_10_IRQHandler</code> para gestionar la interrupci\u00f3n de la columna <code>PORT_KEYBOARD_COL_1</code> (la segunda) del teclado matricial. Recuerda que esta ISR tambi\u00e9n gestiona la interrupci\u00f3n del bot\u00f3n, por lo que debes mantener el bloque condicional <code>if</code> que ya estaba implementado.</p> <p>F\u00edjate, en la API, en el TODO para Versi\u00f3n 2.</p> <p>Note</p> <p>Tanto esta ISR como las siguientes hacen llamadas la funci\u00f3n privada <code>_check_column_interrupt()</code>, que se encargar\u00e1 de gestionar el flag de pulsaci\u00f3n de tecla y guardar el \u00edndice de la columna que ha generado la interrupci\u00f3n. Esta funci\u00f3n auxiliar es opcional implementarla, pero hace el c\u00f3digo m\u00e1s legible y evita repetir c\u00f3digo. Si no quieres implementarla, aseg\u00farate de hacer en cada ISR de cada columna lo que la API indica para esta funci\u00f3n.</p> <p>Si quieres implementar <code>_check_column_interrupt()</code>, hazlo ahora. Debes colocarla antes de cualquier funci\u00f3n que la use.</p> <p>Esta ISR, cuando salta, se encarga de llamar a la funci\u00f3n correspondiente para settear el estado del flag de pulsaci\u00f3n de tecla y guardar el \u00edndice de la columna que ha generado la interrupci\u00f3n.</p> </li> <li> <p>Codifica la ISR <code>EXTI9_5_IRQHandler</code> para gestionar las interrupciones de las columnas <code>PORT_KEYBOARD_COL_0</code> (la primera) y <code>PORT_KEYBOARD_COL_3</code> (la cuarta) del teclado matricial. Esta ISR gestiona las interrupciones de dos l\u00edneas del teclado matricial, por lo que debes mantener un bloque condicional <code>if</code> como en de la ISR anterior.</p> </li> <li> <p>Codifica la ISR <code>EXTI4_IRQHandler</code> para gestionar la interrupci\u00f3n de la columna <code>PORT_KEYBOARD_COL_2</code> (la tercera) del teclado matricial. Como esta ISR no est\u00e1 compartida entre l\u00edneas del <code>EXTI</code>, no es necesario un bloque condicional.</p> </li> <li> <p>Por \u00faltimo, codifica la ISR <code>TIM5_IRQHandler</code> como se indica en la API. Recuerda que las ISR no reciben ni devuelven nada.</p> <p>Esta ISR, cuando salta, se encarga de llamar a la funci\u00f3n correspondiente para settear el estado del flag de timeout que permitir\u00e1 excitar la siguiente fila del teclado.</p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>Si ahora compilas, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado de excitaci\u00f3n de filas para lectura de teclas en un teclado matricial!. Vamos a probarlo con el test unitario de la parte <code>PORT</code> para esta parte.</p>"},{"location":"notebook/version_2.html#sec:test_port_keyboard","title":"<code>PORT</code>: Test unitario del teclado matricial","text":"<p>Vamos a comprobar que la parte <code>PORT</code> funciona correctamente pasando los test HW del c\u00f3digo que hemos desarrollado antes de continuar.</p> <p>\u00a1Importante! Los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente. \u00a0Ten a mano y revisa el cap\u00edtulo \u201cTest unitarios y ejemplos de integraci\u00f3n\u201d del libro de fundamentos te\u00f3ricos\u00a0<sup>3</sup>.</p> <p>Descarga el fichero de test HW del teclado <code>test_port_keyboard.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto.</p> <ol> <li> <p>Conecta la placa Nucleo-STM32\u00a0al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_port_keyboard</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Comprueba que todos los test pasan correctamente en el texto mostrado en la terminal de depuraci\u00f3n. Si no es as\u00ed, lee los mensajes de error y corrige tu c\u00f3digo hasta que pase todas las pruebas. Si no pasa las pruebas, no contin\u00faes programando, corrigelas.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pase todos los test.</p> </li> </ol> <p>\u00a1Ya hemos acabado con la parte <code>PORT</code> del teclado! Vamos ahora a implementar la parte <code>COMMON</code> de la librer\u00eda del teclado.</p>"},{"location":"notebook/version_2.html#common-cabecera-de-la-fsm-del-teclado","title":"<code>COMMON</code>: cabecera de la FSM del teclado","text":""},{"location":"notebook/version_2.html#consideraciones-de-la-fsm-del-teclado","title":"Consideraciones de la FSM del teclado","text":"<p>Antes de ponernos a programar, conviene explicar algunos aspectos importantes de la FSM del teclado matricial.</p> <ul> <li> <p>La FSM almacena el caracter <code>char</code> de la \u00faltima  tecla pulsada.</p> </li> <li> <p>El usuario debe solicitar/\u00a0comprobar el caracter mediante la funci\u00f3n <code>fsm_keyboard_get_key_value()</code>.</p> </li> <li> <p>El valor de inicio del caracter al arrancar la FSM, y el valor de reinicio, debe ser le valor de tecla inv\u00e1lida que haya definido el layout del teclado. En nuestro caso, el valor de tecla inv\u00e1lida es el caracter nulo <code>'\\0'</code>, que est\u00e1 definido en la estructura <code>keyboard_t</code> del layout del teclado. En otro teclado podr\u00eda ser otro, por lo que no hay que poner este valor a pincho, sino el que nos devuelva <code>port_keyboard_get_invalid_key_value()</code>.</p> <p>\u00a1Ojo! \ud83d\udc41 \u00a1Al inicializar la FSM, hay que inicializar el <code>port_keyboard_init()</code>, porque de lo contrario, no podremos leer qu\u00e9 tecla es inv\u00e1lida seg\u00fan el layout!</p> </li> <li> <p>Un valor de <code>invalid_key</code> significa que no ha habido una nueva pulsaci\u00f3n del teclado.</p> </li> <li> <p>El usuario debe reiniciar el valor de tecla pulsada una vez le\u00eddo, de lo contrario, este valor puede ser malinterpretado por el usuario si se realizan sucesivas comprobaciones sin haber pulsado el teclado. Es an\u00e1logo a lo que hac\u00edamos con el bot\u00f3n.  Para reiniciar el valor se debe llamar a la funci\u00f3n <code>fsm_keyboard_reset_key_value()</code>.</p> </li> <li> <p>La FSM contiene informaci\u00f3n del identificador (<code>ID</code>) del teclado que maneja. Este <code>ID</code> es \u00fanico y gestionado por el usuario en el <code>PORT</code>. Ah\u00ed es donde el usuario proporciona identificadores e informaci\u00f3n HW (GPIOs a la que est\u00e1 conectado y tiempo de anti-rebotes) para todos los teclados de su sistema.</p> </li> </ul> M\u00e1quina de estados del teclado matricial. <p>Nuestra librer\u00eda implementa la l\u00f3gica de la FSM mostrada en el diagrama de la figura y que llamaremos <code>fsm_keyboard</code> (en los ficheros <code>.c</code> y <code>.h</code>). Es an\u00e1loga a la del bot\u00f3n, salvo por una autotransici\u00f3n en el primer estado. Tiene 4 estados porque implementa tambi\u00e9n un mecanismo anti-rebotes SW. Nos centramos en la descripci\u00f3n de ese primer estado y su autotransici\u00f3n, para el resto, vaya la descripci\u00f3n hecha en las consideraciones de la FSM del bot\u00f3n:</p> <ul> <li> <p><code>KEYBOARD_RELEASED_WAIT_ROW</code>: es el estado inicial de la m\u00e1quina de estados, y es al estado al que vuelve cuando se pulsa \u00a1y se suelta! una tecla. En este estado, adem\u00e1s, se comprueba si ha pasado el timeout de excitaci\u00f3n de filas (flag <code>flag_row_timeout</code>), y si es as\u00ed, se excita la siguiente fila del teclado, permaneciendo en este estado (autotransici\u00f3n). Esta excitaci\u00f3n se hace llamando a la funci\u00f3n <code>port_keyboard_excite_next_row()</code>. Si, durante la excitaci\u00f3n de una fila, se detecta una interrupci\u00f3n de subida en alguna columna, se guardar\u00e1 el tick de tiempo en el que se puls\u00f3 la tecla; transcurrido el tiempo suficiente para evitar rebotes, al soltar y producirse una interrupci\u00f3n en flanco de bajada, se llamar\u00e1 a <code>do_set_key_value()</code> que  guardar\u00e1 la tecla pulsada tras ped\u00edrselo al <code>PORT</code>.</p> <p>Ser\u00e1 el usuario en su programa principal quien deba reiniciar el valor de tecla pulsada una vez le\u00eddo, llamando a la funci\u00f3n <code>fsm_keyboard_reset_key_value()</code>, como se hac\u00eda con el bot\u00f3n.</p> </li> </ul> <p>La parte <code>COMMON</code> de nuestra librer\u00eda trabaja con la estructura (<code>struct</code>) p\u00fablica que se muestra en la figura (b) de estructuras.</p> <ol> <li> <p>Descarga del repositorio los ficheros correspondientes a la parte COMMON de la librer\u00eda del teclado correspondientes a la versi\u00f3n <code>V2</code>: https://github.com/sdg2DieUpm/simone/tree/simone_v2. Solo descarga lo que faltaba por implementar, es decir, los ficheros <code>fsm_keyboard.h</code> y <code>fsm_keyboard.c</code> y ponlos en las carpetas correspondientes de tu proyecto.</p> <p>Ahora, vamos a completar la cabecera de la FSM del teclado, <code>fsm_keyboard.h</code>.</p> </li> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Escribe el <code>enum</code> <code>FSM_KEYBOARD</code> con los nombres de los estados del diagrama de la separados por <code>,</code>. No olvides poner un <code>;</code> al final del <code>enum</code>.</p> </li> <li> <p>Declara la estructura <code>fsm_keyboard_t</code> para hacerla p\u00fablica como indica la figura de la estructura de la FSM, y documenta cada campo con Doxygen.</p> <p>Continuamos con las declaraciones de funciones p\u00fablicas de la librer\u00eda. Procedamos:</p> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>fsm_keyboard.h</code> y documenta cada funci\u00f3n con Doxygen. Recuerda que la documentaci\u00f3n va encima del nombre de cada funci\u00f3n.</p> </li> </ol> <p>Ya hemos acabado con el encabezado. Quiz\u00e1s de errores al compilar. Vamos ahora a programar el fichero fuente <code>fsm_keyboard.c</code>.</p>"},{"location":"notebook/version_2.html#sec:fsm_keyboard","title":"<code>COMMON</code>: fuente de la FSM del teclado","text":"<p>Vamos a proceder con la implementaci\u00f3n de las funciones del teclado. Deber\u00e1s implementar todas las funciones p\u00fablicas de las que ya has declarado el prototipo en el encabezado, y el resto de funciones privadas que aparecen en la API del fichero <code>fsm_keyboard.c</code>. Tambi\u00e9n definiremos las variables globales y estructuras que sean necesarias. \u00a1Recuerda que las funciones privadas no se declaran en el <code>.h</code>!</p> <ol> <li> <p>Incluye las cabeceras que indica la API.</p> <p>Ahora empezamos a codificar las funciones privadas de entrada o comprobaci\u00f3n de la FSM <code>check_</code>.</p> </li> <li> <p>Codifica las funciones <code>check_row_timeout()</code>, <code>check_keyboard_pressed()</code>, <code>check_keyboard_released()</code>, y <code>check_timeout()</code> como se indica en la API.</p> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen. En este caso, como las funciones no est\u00e1n declaradas en el encabezado, la documentaci\u00f3n ir\u00e1 en el <code>.c</code>, encima del nombre de cada funci\u00f3n.</p> </li> <li> <p>Codifica las funciones <code>do_excite_next_row()</code>, <code>do_store_tick_pressed()</code>, <code>do_clear_key_value()</code>, y <code>do_set_key_value()</code> como se indica en la API.</p> <p>Documenta las funciones con Doxygen igual que antes.</p> </li> <li> <p>Definimos <code>static fsm_trans_t fsm_trans_keyboard[] = ...</code> justo despu\u00e9s de la funci\u00f3n <code>do_set_key_value()</code> siguiendo el diagrama de la FSM.</p> <p>Recuerda que debe haber una fila en la tabla por cada flecha de transici\u00f3n entre estados de la forma: <code>EstadoIni, FuncCompruebaCondicion, EstadoSig, FuncAccionesSiTransicion</code>. No olvides a\u00f1adir la fila <code>-1, NULL, -1, NULL</code>. No olvides que el <code>EstadoIni</code> de la primera transici\u00f3n es el estado inicial de la FSM.</p> </li> <li> <p>Codifica las funciones <code>fsm_keyboard_start_scan()</code>, <code>fsm_keyboard_stop_scan()</code>, <code>fsm_keyboard_get_key_value()</code>, y <code>fsm_keyboard_get_is_valid_key()</code> como se indica en la API. Con esta \u00faltima funci\u00f3n, el usuario podr\u00e1 comprobar si la \u00faltima tecla pulsada es v\u00e1lida o no.</p> <p>Codifica tambi\u00e9n la funci\u00f3n <code>fsm_keyboard_reset_key_value()</code> con la que el usuario podr\u00e1 reiniciar el valor de la tecla pulsada a <code>invalid_key</code> tras leerla.</p> </li> <li> <p>Completa la funci\u00f3n <code>fsm_keyboard_init()</code> como se indica en la API.</p> </li> <li> <p>Codifica la funci\u00f3n <code>fsm_keyboard_fire()</code> de manera an\u00e1loga a como se hizo en la FSM del bot\u00f3n.</p> </li> <li> <p>Documenta el c\u00f3digo que est\u00e9 sin comentar.</p> </li> </ol> <p>Ya hemos acabado con la programaci\u00f3n de la librer\u00eda del teclado. Toda esta l\u00f3gica <code>COMMON</code> puede ser usada en cualquier sistema. Hemos hecho una librer\u00eda de un teclado que tiene un anti-rebotes y nos devuelve el valor de la \u00faltima tecla pulsada. As\u00ed pues, si compilas, no deber\u00edan aparecer errores.</p>"},{"location":"notebook/version_2.html#sec:test_fsm_v2","title":"<code>COMMON</code> Test unitario de la FSM del teclado","text":"<p>Vamos a probar el test del c\u00f3digo que hemos desarrollado de la librer\u00eda de la m\u00e1quina de estados del teclado y probar que funciona antes de continuar con la siguiente versi\u00f3n. \u00a1Importante! Recuerda que los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente.</p> <p>Descarga el fichero de test de la FSM del teclado <code>test_fsm_keyboard.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>test/</code> de tu proyecto. \u00a1No lo metas en stm32f4/, pues no es un test espec\u00edfico del microcontrolador!</p> <ol> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_fsm_keyboard</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso.</p> </li> <li> <p>Se habr\u00e1 impreso por la terminal del <code>gdb-server</code> el resultado de las pruebas de los tests. Deber\u00eda haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu c\u00f3digo hasta que pasen todas las pruebas. Si no pasan las pruebas, no contin\u00faes.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pasen todos los test.</p> </li> </ol>"},{"location":"notebook/version_2.html#ejemplo-de-uso-de-la-version-2","title":"Ejemplo de uso de la Versi\u00f3n 2","text":"<p>El test de integraci\u00f3n no hace uso de la librer\u00eda <code>unity</code>, sino que es como un peque\u00f1o programa de prueba sobre las funciones que hemos implementado y tiene su propio <code>main</code>.</p> <p>En los test de integraci\u00f3n es responsabilidad del alumno comprobar que la funcionalidad es la esperada, porque aqu\u00ed no hay test unitarios que nos ayuden.</p> <p>Nuestra librer\u00eda de teclado devuelve el valor de la \u00faltima tecla pulsada. As\u00ed pues, algunas de las comprobaciones que podemos hacer son: que todas las teclas de todas las columnas aparecen impresas por pantalla, que se reinicia adecuadamente el valor tras leerlo, que funciona el anti-rebotes\u2026</p> <p>Descarga el fichero de ejemplo <code>example_v2.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v2_test. Ponlo en la carpeta <code>example/</code> de tu proyecto.</p> <p>Procedamos:</p> <p>Para poder hacer el ejemplo del teclado matricial, necesitamos conectarlo como se muestra en el montaje de la figura. F\u00edjate que las filas son los pines  de la izquierda si miramos el teclado de frente. </p> <ol> <li> <p>Monta el circuito del teclado matricial como se muestra en la figura.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>example_v2</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Se parar\u00e1 en la primera l\u00ednea del <code>main()</code>. Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso. Este c\u00f3digo no termina, pues es un bucle <code>while</code> infinito.</p> </li> <li> <p>Abre la terminal del <code>gdb-server</code> para ver los mensajes que se van imprimiendo.</p> </li> <li> <p>Pulsa una a una todas las teclas del teclado.Deber\u00edas ver que se imprime por pantalla el caracter de la pulsaci\u00f3n. Si no es as\u00ed, revisa tu c\u00f3digo.</p> </li> <li> <p>Haz distintas pruebas y aseg\u00farate de que el comportamiento es el adecuado.</p> </li> </ol> <p>\u00a1Hemos creado nuestra primera librer\u00eda! F\u00edjate que es portable a cualquier plataforma solo con adaptar las funciones del <code>PORT</code>.</p> <p>No dejes de documentar el c\u00f3digo. Comprueba que la documentaci\u00f3n del c\u00f3digo se ha generado correctamente como se explica en la \u201cGu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C\u201d <sup>6</sup>., o en el v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d.</p> <p>Guarda una copia de su proyecto como <code>simone_v2</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla.</p> <ol> <li> <p>Por ejemplo, un teclado de ordenador, una calculadora, un cajero autom\u00e1tico, etc. No nos hacemos responsables de posibles da\u00f1os que pueda ocasionar \ud83d\ude05.\u00a0\u21a9</p> </li> <li> <p>Para un mejor contacto, el circuito de la imagen son dos pistas de cobre en zig-zag que se cortocircuitan al pulsar el bot\u00f3n. Lo m\u00e1s simple ser\u00eda una cruz que no se toca, pero su contacto es menos fiable. En teclados m\u00e1s avanzados, puede haber circuitos adicionales para mejorar la durabilidad o la respuesta t\u00e1ctil.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Juan Jos\u00e9 G\u00f3mez Valverde. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/88460/.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Amadeo de Gracia Herranz, Sergio Esteban Romero, and Daniel Capell\u00e1n Mart\u00edn. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/92376/.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_3.html","title":"Versi\u00f3n 3","text":""},{"location":"notebook/version_3.html#cha:version3","title":"Versi\u00f3n 3: RGB light","text":"<p>Ya tenemos una librer\u00eda que nos permite tener botones que funcionan aut\u00f3nomamente mediante FSM. De ella hemos creado un bot\u00f3n que nos permitir\u00e1 encender y apagar el juego Simone. Adem\u00e1s, hemos creado una librer\u00eda que nos permite crear teclados matriciales, tambi\u00e9n gestionados mediante FSM. De esta \u00faltima, hemos creado un teclado que permitir\u00e1 al jugador introducir la secuencia de colores en cada turno.</p> <p>Bibliograf\u00eda</p> <ol> <li> <p>\"Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32\u201d <sup>1</sup></p> </li> <li> <p>Datasheet \"STM32F446xC/E\u201d <sup>2</sup></p> </li> <li> <p>Reference manual \"RM0390. STM32F446xx advanced Arm-based 32-bit MCUs\u2019 <sup>3</sup></p> </li> </ol> <p>V\u00eddeos del canal de SDGII</p> <ul> <li> <p>Demostraci\u00f3n Simone</p> </li> <li> <p>Conceptos b\u00e1sicos de C (canal SDG1)</p> </li> <li> <p>\"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d</p> </li> </ul> <p>En este cap\u00edtulo vamos a crear una librer\u00eda que nos permita mostrar un LED RGB\u00a0donde cada color estar\u00e1 controlado por una se\u00f1al PWM. Este elemento que llamaremos RGB light nos permitir\u00e1 mostrar (i) los colores de la secuencia que tiene que replicar el usuario, y (ii) dar feedback visual al jugador cada vez que pulse una tecla.</p> <p>Como ya hicimos en las versiones anteriores, (i) vamos a implementar la parte portable <code>PORT</code> dependiente del HW para comunicarnos con el LED RGB, y lo probaremos con un test unitario. (ii) Despu\u00e9s, vamos a crear la l\u00f3gica de la FSM para gestionar las secuencias del juego con los distintos colores (la parte <code>COMMON</code>), y lo probaremos con un test unitario. (iii) Por \u00faltimo, montaremos el HW y probaremos el funcionamiento del LED RGB\u00a0con un programa de ejemplo.</p> <p>Cuando lea esta introducci\u00f3n conviene que lea y entienda el cap\u00edtulo \"Circuito de reloj\u201d del libro\u00a0<sup>1</sup>, prestando especial atenci\u00f3n al ejemplo proporcionado sobre PWM.</p> <p>Cada uno de los LED (R, G, y B) del LED estar\u00e1 conectado a una GPIO del STM32F446RE. Los tres LED est\u00e1n controlados por el mismo temporizador en modo PWM, pero cada uno con un canal de dicho temporizador. La se\u00f1al PWM es una se\u00f1al cuadrada que tiene un periodo fijo y un ciclo de trabajo variable. Si el ciclo de trabajo es del 100\\%, el LED estar\u00e1 a m\u00e1xima intensidad, y si es del 0\\%, el LED estar\u00e1 apagado. Las caracter\u00edsticas a destacar del sistema de la Versi\u00f3n 3 se muestran en la siguiente tabla.</p> Par\u00e1metro Valor Pin LED rojo <code>PB6</code> Pin LED verde <code>PB8</code> Pin LED azul <code>PB9</code> Modo Alternativo Pull up/ down Sin pull Temporizador (para todos los colores) <code>TIM4</code> Canal LED rojo (ver la tabla de Funci\u00f3n Alternativa en el datasheet<sup>2</sup>) Canal LED verde (ver la tabla de Funci\u00f3n Alternativa en el datasheet<sup>2</sup>) Canal LED azul (ver la tabla de Funci\u00f3n Alternativa en el datasheet<sup>2</sup>) Modo PWM Modo PWM 1 Prescaler (Calcular para frecuencia de 50 Hz) Periodo (Calcular para frecuencia de 50 Hz) Ciclo de trabajo LED rojo (variable, depende del color a mostrar) Ciclo de trabajo LED verde (variable, depende del color a mostrar) Ciclo de trabajo LED azul (variable, depende del color a mostrar) <p>Un color se representa en el LED RGB mediante la combinaci\u00f3n de los tres colores b\u00e1sicos: rojo, verde y azul. La combinaci\u00f3n de los tres colores b\u00e1sicos en diferentes proporciones nos permite obtener una amplia gama de colores. La intensidad la controla el ciclo de trabajo (canal del temporizador), pero la frecuencia para los tres colores ser\u00e1 la misma. La frecuencia de la se\u00f1al PWM ser\u00e1 de \\(50 Hz\\), valor lo suficientemente alto para que no se perciba el parpadeo de los LED. Nuestro ojo integrar\u00e1 esos trenes de pulsos y lo veremos como un color determinado. Si se cambia el ciclo de trabajo, estaremos controlando la intensidad de cada LED, y por tanto el color mostrado.</p> <p>\u00bfCu\u00e1ndo cambiaremos los valores del ciclo de trabajo? Pues depende de la intensidad calculada de forma aleatoria seg\u00fan el nivel de dificultad del juego. Cuanto m\u00e1s dif\u00edcil sea el nivel, m\u00e1s parecidos ser\u00e1n los colores (menor intensidad), y por tanto m\u00e1s dif\u00edcil ser\u00e1 para el usuario distinguirlos.</p> <p>La tabla de colores muestra los colores que se usar\u00e1n en el juego y los valores de ciclo de trabajo asociados a cada color para m\u00e1xima intensidad en tanto por ciento. Los colores est\u00e1n definidos en la librer\u00eda que se proporciona <code>rgb_colors.c</code> de la parte <code>COMMON</code>, y que mencionaremos m\u00e1s adelante.</p> Color LED rojo LED verde LED azul Rojo \\(100~\\%\\) \\(0~\\%\\) \\(0~\\%\\) Verde \\(0~\\%\\) \\(100~\\%\\) \\(0~\\%\\) Azul \\(0~\\%\\) \\(0~\\%\\) \\(100~\\%\\) Amarillo \\(37~\\%\\) \\(37~\\%\\) \\(0~\\%\\) Turquesa \\(10~\\%\\) \\(35~\\%\\) \\(32~\\%\\) Blanco \\(100~\\%\\) \\(100~\\%\\) \\(100~\\%\\) Apagado \\(0~\\%\\) \\(0~\\%\\) \\(0~\\%\\) <p>En la Versi\u00f3n 5 puedes implementar otros colores. Tienes una lista de colores en la www.downtownuplighting.com\u2014aunque no todos se pueden mostrar en un LED RGB.</p> <p>La figura muestra un ejemplo de se\u00f1al PWM para un color amarillento (que no el amarillo de la tabla. Se muestran en el osciloscopio dos de los LED del RGB. En la parte superior se muestra el canal de osciloscopio para el LED rojo, y en la parte inferior el canal de osciloscopio para el LED verde. F\u00edjate que el periodo de la se\u00f1al PWM es el mismo para los dos LED (\\(20 ms\\)), pero el ciclo de trabajo es distinto: \\(20.8\\%\\) para el LED rojo y \\(36.6\\%\\) para el LED verde.</p> Ejemplo de se\u00f1ales PWM para un color amarillento. <p>Igual que hemos hecho hasta ahora, estamos desarrollando una librer\u00eda. As\u00ed, cada vez que se quiera a\u00f1adir un LED RGB\u00a0le asociaremos una FSM. Las particularidades de d\u00f3nde est\u00e1 conectado cada nuevo LED RGB, sus caracter\u00edsticas f\u00edsicas, etc., son cosas espec\u00edficas del HW, por lo que estar\u00e1n en <code>PORT</code>.</p> (a) Estructura de un color RGB, (b) Estructura del HW del LED RGB en PORT, (c) Estructura de la FSM del *RGB light* en COMMON. <p>Las figuras de estructuras de un color RGB, del HW y del SW muestran las estructuras que vamos a necesitar para el LED RGB.</p> <p>Un color RGB se define por la estructura de la figura (a) con tres valores <code>uint8_t</code> que indican la intensidad de cada componente en un rango de [0, <code>COLOR_RGB_MAX_VALUE</code>]. Donde la etiqueta <code>COLOR_RGB_MAX_VALUE</code> se ha definido con un valor de <code>255</code>, por lo que este ser\u00e1 el n\u00famero de niveles de intensidad que podremos representar para cada componente.</p> <p>La estructura del HW del LED RGB\u00a0(en <code>PORT</code>) se muestra en la figura (b). La estructura de la FSM (en <code>COMMON</code>) se muestra en la figura (c).</p> <p>Preparemos el proyecto para poder a\u00f1adir el LED RGB:</p> <ol> <li> <p>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT de la librer\u00eda del RGB light correspondientes a la versi\u00f3n <code>V3</code>: https://github.com/sdg2DieUpm/simone/tree/simone_v3. Solo descarga por ahora: <code>port_rgb_light.h</code>, <code>stm32f4_rgb_light.h</code>, y <code>stm32f4_rgb_light.c</code> y col\u00f3calos en las carpetas correspondientes. De la parte COMMON descarga solo <code>rgb_color.h</code> y <code>rgb_color.c</code>, que incluyen la definici\u00f3n de los colores que usaremos en el juego.</p> </li> <li> <p>Coloca cada uno donde corresponde: <code>PORT</code> o <code>COMMON</code>, en <code>include</code>, o <code>src</code>, como se explic\u00f3 en el los cap\u00edtulos anteriores.</p> </li> <li> <p>Ver\u00e1s que no compila, y es que solo se proporciona un esqueleto del c\u00f3digo.</p> </li> </ol>"},{"location":"notebook/version_3.html#sec:rgb_colors","title":"Colores RGB predefinidos","text":"<p>Antes de ponernos a programar, conviene explicar qu\u00e9 son los ficheros <code>rgb_colors.h</code> y <code>rg_colors.c</code>. Estos ficheros se han de colocar en la carpeta <code>common/include</code> y <code>common/src</code> respectivamente. Estos ficheros contienen los colores que se usar\u00e1n en el juego. Cada color est\u00e1 representado por una estructura de tipo <code>rgb_color_t</code> que contiene tres campos: <code>r</code>, <code>g</code>, y <code>b</code>, que representan la intensidad de cada componente del color en un rango de [0, <code>COLOR_RGB_MAX_VALUE</code>]. Estos colores predefinidos son los que se muestran en la tabla.</p> <p>Estos ficheros permiten definir m\u00faltiples colores de manera sencilla y reutilizable. Si deseas a\u00f1adir m\u00e1s colores, puedes hacerlo en la Versi\u00f3n 5 definiendo nuevas variables de tipo <code>rgb_color_t</code> en el fichero <code>rgb_colors.c</code> y declar\u00e1ndolas en el fichero <code>rgb_colors.h</code>. Tambi\u00e9n podr\u00edas cambiar el rango de intensidad modificando el valor de <code>COLOR_RGB_MAX_VALUE</code> para tener mayor o menor resoluci\u00f3n en la representaci\u00f3n de los colores.</p>"},{"location":"notebook/version_3.html#sec:headers_rgb_light","title":"<code>PORT</code>: cabeceras de la librer\u00eda del RGB light","text":"<p>Vamos a implementar el contrato con el usuario de la parte dependiente del HW de librer\u00eda del RGB light. Esta es la interfaz que vamos a proporcionar al usuario para que pueda usar la librer\u00eda y a\u00f1adir LEDs RGB\u00a0como necesite. Vamos a portar las funciones necesarias para usar la librer\u00eda, c\u00f3mo no, para la placa Nucleo-STM32F446RE. Comenzaremos de nuevo por la cabecera y luego los c\u00f3digos fuente. El montaje de nuestro LED RGB\u00a0con la Nucleo-STM32F446RE\u00a0se muestra en la figura.</p> Montaje del LED RGB\u00a0de c\u00e1todo com\u00fan con la Nucleo-STM32F446RE. <p>En el mercado existen numerosos LEDs RGB. En este proyecto utilizaremos un LED de c\u00e1todo com\u00fan. En este tipo de LEDs, el \u00e1nodo de cada LED est\u00e1 conectado a un pin del microcontrolador a trav\u00e9s de una resistencia, y los c\u00e1todos de los tres LED est\u00e1n internamente conectados a un pin com\u00fan que ir\u00e1 a tierra. Para adquirir uno, ve a la\u00a0BOM).</p>"},{"location":"notebook/version_3.html#cabecera-port_rgb_lighth","title":"Cabecera port_rgb_light.h","text":"<p>Esta cabecera depende del HW pero no de las particularidades del microcontrolador STM32F446RE. Vamos a seguir los siguientes pasos:</p> <ol> <li> <p>Incluye todas las cabeceras necesarias seg\u00fan indica la API.</p> </li> <li> <p>Define (<code>#define</code>) el <code>PORT_RGB_LIGHT_ID</code>, que es un valor num\u00e9rico natural que ser\u00e1 el identificador del RGB light trasero. Si es el \u00fanico RGB light del sistema, le asignaremos el 0.</p> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>port_rgb_light.h</code>.</p> </li> <li> <p>Puede ser buen momento ahora para documentar con Doxygen.</p> </li> </ol> <p>Ya hemos acabado con el encabezado que interact\u00faa con el HW del RGB light y que no depende del microcontrolador. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a programar la cabecera que s\u00ed depende del microcontrolador <code>stm32f4_rgb_light.h</code>.</p>"},{"location":"notebook/version_3.html#cabecera-stm32f4_rgb_lighth","title":"Cabecera stm32f4_rgb_light.h","text":"<p>Esta cabecera define los pines a los que est\u00e1 conectado el LED RGB\u00a0de cada RGB light asociado.</p> <ol> <li> <p>Incluye todas las cabeceras necesarias seg\u00fan indica la API.</p> </li> <li> <p>Define (<code>#define</code>) los valores de las GPIO de los pines de los LED rojo, verde y azul.</p> </li> <li> <p>Declara la estructura <code>stm32f4_rgb_light_hw_t</code>, que contiene en sus campos los puertos y pines de cada GPIO. Presta atenci\u00f3n a la API.</p> </li> <li> <p>Declara el array de estructuras de tipo <code>stm32f4_rgb_light_hw_t</code> como se hizo en versiones anteriores. Este array contendr\u00e1 las caracter\u00edsticas de todos los LED RGB que tengamos en el sistema.</p> </li> <li> <p>Documenta todo con Doxygen.</p> </li> </ol> <p>Ya hemos acabado con el encabezado (header) que interact\u00faa con el HW del RGB light. Todav\u00eda dar\u00e1 errores al compilar. Vamos ahora a implementar todas las funciones prototipadas en <code>port_rgb_light.h</code>.</p>"},{"location":"notebook/version_3.html#sec:port_rgb_light","title":"<code>PORT</code>: fuente de la librer\u00eda del RGB light","text":"<p>Vamos a portar las funciones necesarias para usar la librer\u00eda del RGB light y comprobar que la parte HW est\u00e1 bien programada. Vamos a programar los ficheros fuente de la parte <code>PORT</code>, que todos estar\u00e1n en el fichero <code>stm32f4_rgb_light.c</code>.</p>"},{"location":"notebook/version_3.html#fuentes-stm32f4_rgb_lightc","title":"Fuentes stm32f4_rgb_light.c","text":"<p>Este fichero es mucho menos extenso que el de la versi\u00f3n anterior. La mayor complejidad est\u00e1 en la configuraci\u00f3n de los canales del temporizador, pero si has le\u00eddo el cap\u00edtulo del libro relativo a PWM y lo has entendido, no deber\u00edas tener problema\u00a0<sup>1</sup>. Vamos a ello.</p> <ol> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Igual que hicimos anteriormente, define la variable global privada <code>stm32f4_rgb_light_hw_t rgb_lights_arr[]</code> con la configuraci\u00f3n f\u00edsica de nuesto LED RGB. Se trata del array de estructuras de tipo <code>stm32f4_rgb_light_hw_t</code>, que representa al HW de cada RGB light que tengamos en nuestro juego.</p> <p>Asigna los valores HW del LED RGB\u00a0del LED <code>PORT_RGB_LIGHT_ID</code> utilizando los <code>#define</code> de <code>stm32f4_rgb_light.h</code>.</p> </li> <li> <p>Codifica la funci\u00f3n <code>_stm32f4_rgb_light_get()</code> de manera an\u00e1loga a como se ha hecho en las versiones anteriores.</p> </li> </ol> <p>Ahora vamos a codificar las funciones m\u00e1s importantes de la parte <code>PORT</code> del RGB light, y son las que configuran el temporizador asociado al LED RGB.</p> <ol> <li> <p>Codifica la funci\u00f3n <code>_timer_pwm_config()</code> como indica la API. Esta funci\u00f3n configura el temporizador que controla los ciclos de trabajo de los LED rojo, verde y azul. Para ello, ap\u00f3yate en el ejemplo \"timer para PWM\u201d del libro de Fundamentos\u00a0<sup>1</sup>.</p> <p>Esta funci\u00f3n configura un temporizador para que genere una se\u00f1al PWM con una frecuencia fija y un ciclo de trabajo variable. El temporizador elegido y la frecuencia se muestra en la tabla de HW para la versi\u00f3n 3.</p> <p>Esta funci\u00f3n recibe el identificador del LED RGB. Cada RGB light tendr\u00e1 su propio temporizador, pero esta funci\u00f3n ser\u00e1 llamada para configurar todos ellos. Aseg\u00farate de que el c\u00f3digo se ejecuta dentro de un bloque condicional que compruebe el identificador del RGB light.</p> <p>Para saber qu\u00e9 fuente de reloj habilitar para el temporizador, consulta la tabla \"Figure 3. STM32F446xC/E block diagram\u201d del datasheet <sup>2</sup>. All\u00ed podr\u00e1s ver si nuestro temporizador est\u00e1 conectado al APB1 o al APB2, y tenemos que habilitar el reloj en el registro <code>RCC-&gt;APB1ENR</code> o <code>RCC-&gt;APB2ENR</code> respectivamente.</p> <p>Puedes poner los valores de los registros <code>TIMx-&gt;PSC</code> y <code>TIMx-&gt;ARR</code> a mano, o usando las ecuaciones. Puedes crear un <code>#define</code> para la frecuencia de la se\u00f1al PWM, si te es m\u00e1s c\u00f3modo. Si lo haces a mano, aseg\u00farate de que los valores son correctos.</p> <p>Aseg\u00farate de que los registro Capture Compare Enable Register (<code>CCER</code>) y Capture Compare Mode Register (<code>CCMRx</code>) est\u00e1n configurados correctamente. En el CCER se habilitan los canales de salida y en el CCMRx se configura el modo PWM. La x es el registro 1 o 2, dependiendo del canal que est\u00e9s configurando.</p> <p>Es muy importante que la funci\u00f3n <code>_timer_pwm_config()</code> se llame desde la funci\u00f3n <code>port_rgb_light_init()</code>. Si no, no se podr\u00e1n generar las se\u00f1ales PWM.</p> </li> </ol> <p>Vamos a continuar con las funciones p\u00fablicas de la parte <code>PORT</code> del RGB light.</p> <ol> <li> <p>Completa la funci\u00f3n <code>port_rgb_light_init()</code> como se indica en la API.</p> <p>Configura las GPIO y el modo alternativo de los tres LED RGB. Para ello, consulta la tabla de Funci\u00f3n Alternativa del datasheet <sup>2</sup>.</p> <p>Aseg\u00farate de que la funci\u00f3n <code>_timer_pwm_config()</code> se llama desde esta funci\u00f3n y que el LED RGB\u00a0comienza apagado.</p> </li> <li> <p>Codifica la funci\u00f3n <code>port_rgb_light_set_rgb</code> siguiendo la API.</p> <p>Esta funci\u00f3n se encarga de configurar el ciclo de trabajo de los LED rojo, verde y azul. Lo hace con la proporci\u00f3n de los valores recibidos en la estructura <code>rgb_color_t</code> sobre el m\u00e1ximo valor definido en <code>COLOR_RGB_MAX_VALUE</code>. Si el valor recibido es 0, el LED estar\u00e1 apagado, deshabilitando el canal correspondiente.</p> <p>F\u00edjate que la funci\u00f3n recibe el identificador del LED RGB. Aseg\u00farate de que el c\u00f3digo se ejecuta dentro de un bloque condicional que compruebe el identificador del RGB light.</p> <p>Sigue el siguiente flujograma para implementar la funci\u00f3n <code>port_rgb_light_set_rgb()</code>:</p> <p></p>Flujograma de la funci\u00f3n <code>port_rgb_light_set_rgb()</code>.<p></p> </li> <li> <p>Si queda algo por documentar puede ser buen momento ahora.</p> </li> </ol> <p>Ahora, compila, el c\u00f3digo no deber\u00eda tener ning\u00fan error. \u00a1Ya hemos acabado con la implementaci\u00f3n de portado del LED RGB! Vamos a probarlo con el test unitario de la parte <code>PORT</code>.</p>"},{"location":"notebook/version_3.html#sec:test_port_v3","title":"<code>PORT</code>: Test unitario del RGB light","text":"<p>Vamos a comprobar que la parte <code>PORT</code> funciona correctamente pasando los test HW del c\u00f3digo que hemos desarrollado de la librer\u00eda del LED RGB\u00a0antes de continuar con la FSM.</p> <p>\u00a1Importante! Los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente. \u00a0Ten a mano y revisa el cap\u00edtulo \"Test unitarios y ejemplos de integraci\u00f3n\u201d del libro de fundamentos te\u00f3ricos\u00a0<sup>1</sup>.</p> <p>Descarga el fichero de test HW del RGB light <code>test_port_rgb_light.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v3_test. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto.</p> <ol> <li> <p>Conecta la placa Nucleo-STM32\u00a0al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_port_rgb_light</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Comprueba que todos los test pasan correctamente en el texto mostrado en la terminal de depuraci\u00f3n. Si no es as\u00ed, lee los mensajes de error y corrige tu c\u00f3digo hasta que pase todas las pruebas. Si no pasa las pruebas, no contin\u00faes con el siguiente test.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pase todos los test.</p> </li> </ol> <p>\u00a1Ya hemos acabado con la parte <code>PORT</code> del RGB light! Vamos ahora a implementar la parte <code>COMMON</code>.</p>"},{"location":"notebook/version_3.html#common-cabecera-de-la-fsm-del-rgb-light","title":"<code>COMMON</code>: cabecera de la FSM del RGB light","text":""},{"location":"notebook/version_3.html#consideraciones-de-la-fsm-del-RGB","title":"Consideraciones de la FSM del RGB light","text":"<p>Antes de empezar vamos a partir de una serie de consideraciones.</p> <ul> <li> <p>La FSM almacena el \u00faltimo color que se le ha indicado que tiene que representar y su intensidad. La intensidad se almacena en porcentaje como un un <code>uint8_t</code> pero ha de estar limitada a <code>MAX_LEVEL_INTENSITY</code> igual a \\(100\\) cuando se opere con ella. El color se almacena en una estructura de tipo <code>rgb_color_t</code>.</p> </li> <li> <p>La FSM contiene un campo de estado (<code>status</code>) que indica si el RGB light est\u00e1 activo. Si el RGB light est\u00e1 desactivado, no se mostrar\u00e1 ning\u00fan color. Esto puede ser \u00fatil si, por ejemplo, tenemos m\u00e1s de un RGB light en el sistema y queremos desactivar alguno de ellos.</p> <p>La m\u00e1quina de estados superior, la del sistema Simone, ser\u00e1 la que indique si el RGB light est\u00e1 activo o no. La FSM del RGB light solo se encargar\u00e1 de representar los colores si est\u00e1 activo.</p> </li> <li> <p>La FSM contiene otro flag que indica si el RGB light est\u00e1 en modo ocioso (<code>idle</code>). En este estado, el RGB light ya ha puesto un color, no se ha cambiado \u00e9ste ni la intensidad, y podemos entrar en un modo de bajo consumo Sleep Mode Versi\u00f3n 4. En Sleep Mode, el n\u00facleo del procesador se detiene, pero los perif\u00e9ricos y el sistema de reloj contin\u00faan funcionando, por eso el LED permanecer\u00e1 encendido en el color que se haya quedado.</p> </li> <li> <p>El flag <code>new_color</code> lo activa la m\u00e1quina de estados de Simone cuando se ha cambiado el color a representar. La FSM del RGB light comprobar\u00e1 este flag para saber si tiene que cambiar el color del LED.</p> </li> <li> <p>El valor de inicio de intensidad al arrancar debe ser el m\u00e1ximo permitido. El intensidad se da en porcentaje.</p> </li> <li> <p>La FSM contiene informaci\u00f3n del identificador (<code>ID</code>) del RGB light. Este <code>ID</code> es \u00fanico y gestionado por el usuario en el <code>PORT</code>. Ah\u00ed es donde el usuario proporciona identificadores e informaci\u00f3n HW (GPIO a la que est\u00e1 conectado) para todos los LED RGB\u00a0del sistema.</p> </li> </ul> M\u00e1quina de estados del RGB light. <p>Nuestra librer\u00eda implementa la l\u00f3gica de la FSM mostrada en la figura y que llamaremos <code>fsm_rgb_light</code> (en los ficheros <code>.c</code> y <code>.h</code>). Tiene 2 estados en los que:</p> <ul> <li> <p><code>IDLE_RGB</code>: estado inicial de la FSM en el que espara a ser activada. Si se le activa se cambia al estado <code>SET_COLOR</code>. Tambi\u00e9n se vuelve a este estado cuando el sistema no est\u00e1 activo (<code>status</code> es <code>false</code>).</p> </li> <li> <p><code>SET_COLOR</code>: en este estado la FSM espera a que se le haya pasado un nuevo color base y/o una intensidad nueva. Tras poner el color, se activa el flag <code>idle</code> y se queda en este estado. El nuevo color se corrige modificando la intensidad del color base recibido seg\u00fan el porcentaje de intensidad indicado; esto se hace con la funci\u00f3n privada <code>_correct_rgb_light_levels()</code> que deber\u00e1 implementar. Si se le desactiva el sistema, vuelve al estado <code>IDLE_RGB</code>.</p> </li> </ul> <p>La parte <code>COMMON</code> de nuestra librer\u00eda trabaja con la estructura (<code>struct</code>) p\u00fablica que se muestra en la figura (c) <code>fsm_rgb_light_t</code>. El tipo de esta estructura est\u00e1 declarada en el fichero <code>fsm_rgb_light.h</code>.</p> <ol> <li> <p>Lo primero, descarga del repositorio de la asignatura los ficheros correspondientes a la parte COMMON de la librer\u00eda del RGB light correspondientes a la versi\u00f3n <code>V3</code>: https://github.com/sdg2DieUpm/simone/tree/simone_v3. Solo descarga lo que faltaba por implementar, es decir, los ficheros <code>fsm_rgb_light.h</code> y <code>fsm_rgb_light.c</code>. Ponlos en las carpetas correspondientes de tu proyecto.</p> <p>Ahora, vamos a completar la cabecera de la FSM del RGB light, <code>fsm_rgb_light.h</code>.</p> </li> <li> <p>Incluye las librer\u00edas necesarias, si falta alguna, seg\u00fan indique la API.</p> </li> <li> <p>Ahora vamos a definir el enumerado con los nombres de los estados de la FSM. Escribe el <code>enum</code> <code>FSM_RGB_LIGHT_SYSTEM</code> con los nombres de los estados del diagrama de la .</p> </li> <li> <p>Defina los <code>#define</code> que se indican en la API para el m\u00e1ximo nivel de intensidad porcentual que se pueden manejar en el RGB light.</p> </li> <li> <p>Es buena pr\u00e1ctica ir documentado el c\u00f3digo a la vez que se programa.</p> </li> <li> <p>Seguidamente declararemos la estructura <code>fsm_rgb_light_t</code> y definimos sus campos. Es muy importante que la m\u00e1quina de estados del RGB light <code>fsm_t</code> sea el primer campo.</p> <p>Continuamos con las declaraciones de funciones p\u00fablicas de la librer\u00eda. Procedamos:</p> </li> <li> <p>Escribe los prototipos de las funciones p\u00fablicas que aparecen en la API del fichero <code>fsm_rgb_light.h</code>. A\u00f1ada la funci\u00f3n <code>fsm_rgb_light_check_activity()</code> que, aunque la usaremos en la siguiente versi\u00f3n, tambi\u00e9n ser\u00e1 necesaria para el test de la FSM.</p> </li> <li> <p>Puede ser buen momento ahora para documentar las funciones con Doxygen.</p> </li> </ol> <p>Vamos ahora a programar el fichero fuente <code>fsm_rgb_light.c</code>.</p>"},{"location":"notebook/version_3.html#common-fuente-de-la-fsm-del-rgb-light","title":"<code>COMMON</code>: fuente de la FSM del RGB light","text":"<p>Vamos a proceder con la implementaci\u00f3n de las funciones del RGB light. Deber\u00e1s implementar todas las funciones p\u00fablicas de las que ya has declarado el prototipo en el encabezado, y la funci\u00f3n privada <code>_correct_rgb_light_levels()</code> que aparece en la API del fichero <code>fsm_rgb_light.c</code>. \u00a1Recuerda que las funciones privadas no se declaran en el <code>.h</code>!</p> <ol> <li> <p>Lo primero que debe aparecer es la inclusi\u00f3n de cabeceras como indica la API.</p> <p>Ahora empezamos a codificar las funciones privadas de la FSM. Bajo la l\u00ednea de <code>/\\* Private functions \\*/</code> vamos a codificar la funci\u00f3n <code>_correct_rgb_light_levels()</code>.</p> </li> <li> <p>Codifica la funci\u00f3n <code>_correct_rgb_light_levels()</code> que se encarga de calcular los niveles de ciclo de trabajo de cada LED rejo, verde y azul. Esta funci\u00f3n simplemente multiplica por un valor entre [0, 1] cada uno de los componentes RGB. Esta funci\u00f3n Ten en cuenta que el valor que almacenan no es el ciclo de trabajo entre 0 y 100, sino que quedar\u00e1 entre 0 y 255. \u00a1El ciclo de trabajo se calcula en <code>port_rgb_light_set_rgb()</code>!</p> </li> <li> <p>Documenta la funci\u00f3n con Doxygen.</p> <p>Continuamos con las funciones de entrada o comprobaci\u00f3n <code>check_</code> de la FSM bajo la l\u00ednea de <code>/\\* State machine input or transition functions \\*/</code>.</p> </li> <li> <p>Codifica las funciones <code>check_active()</code>, <code>check_set_new_color()</code> y, <code>check_off()</code> como se indica en la API.</p> </li> <li> <p>Documenta las funciones con Doxygen, encima del nombre de cada funci\u00f3n.</p> <p>Seguiremos con las funciones de salida o actualizaci\u00f3n de la FSM <code>do_</code>.</p> </li> <li> <p>Codifica las funciones <code>do_set_on()</code>, <code>do_set_color()</code> y, <code>do_set_off()</code> como se indica en la API.</p> </li> <li> <p>Documenta las funciones con Doxygen. En este caso, igual que antes, la documentaci\u00f3n ir\u00e1 en el <code>.c</code>, encima del nombre de cada funci\u00f3n.</p> <p>Todav\u00eda no hemos acabado con el desarrollo, pero puedes compilar para ir depurando errores.</p> </li> <li> <p>Declara la tabla de transiciones de la FSM <code>fsm_trans_rgb_light</code>. Esto eliminar\u00e1 muchos errores de compilaci\u00f3n.</p> </li> <li> <p>Completa la funci\u00f3n de inicializaci\u00f3n de la FSM <code>fsm_rgb_light_init()</code> como se indica en la API. En esta funci\u00f3n se inicializan los campos de la estructura de la FSM, y se llama a la funci\u00f3n <code>fsm_init()</code> para inicializar la m\u00e1quina de estados. Tambi\u00e9n se llama a la funci\u00f3n <code>port_rgb_light_init()</code> para inicializar el HW del LED RGB.</p> </li> <li> <p>Codifica las funciones <code>fsm_rgb_light_fire()</code> y <code>fsm_rgb_light_destroy()</code> igual que hiciste en las versiones anteriores. Estas funciones lanzan la FSM y liberan la memoria respectivamente.</p> </li> <li> <p>Codifica el resto de las funciones <code>fsm_rgb_light_xxx()</code> p\u00fablicas que quedan declaradas en el <code>.h</code> como se indica en la API.</p> </li> <li> <p>Documenta el c\u00f3digo que est\u00e9 sin comentar todav\u00eda.</p> </li> </ol> <p>Ya hemos acabado con la programaci\u00f3n de la librer\u00eda del RGB light. Ahora, si compilas, no deber\u00e1n aparecer errores.</p>"},{"location":"notebook/version_3.html#sec:test_fsm_v3","title":"<code>COMMON</code> Test unitario de la FSM del RGB light","text":"<p>Vamos a hacer el test del c\u00f3digo que hemos desarrollado de la librer\u00eda de la m\u00e1quina de estados del RGB light y probar que funciona antes de continuar con la siguiente versi\u00f3n.</p> <p>\u00a1Importante! Recuerda que los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente.</p> <p>Descarga el fichero de test de la FSM del RGB light <code>test_fsm_rgb_light.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v3_test. Ponlo en la carpeta <code>test/</code> de tu proyecto. \u00a1No lo metas en stm32f4/, pues no es un test espec\u00edfico del microcontrolador!</p> <ol> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>test_fsm_rgb_light</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso.</p> </li> <li> <p>Comprueba los mensajes del <code>gdb-server</code> para ver el resultado de las pruebas de los tests. Deber\u00eda haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu c\u00f3digo hasta que pasen todas las pruebas. Si no pasan las pruebas, no contin\u00faes.</p> </li> <li> <p>Termina la depuraci\u00f3n pulsando () y repite el proceso hasta que pasen todos los test.</p> </li> </ol>"},{"location":"notebook/version_3.html#ejemplo-de-uso-de-la-version-3","title":"Ejemplo de uso de la Versi\u00f3n 3","text":"<p>En este test de integraci\u00f3n del RGB light es responsabilidad del alumno comprobar que la funcionalidad es la esperada. El ejemplo que se da no contempla todas las situaciones.</p> <p>Descarga el fichero de ejemplo <code>example_v3.c</code> de https://github.com/sdg2DieUpm/simone/tree/simone_v3_test. Ponlo en la carpeta <code>example/</code> de tu proyecto.</p> <p>Procedamos:</p> <p>Para poder hacer el ejemplo del RGB light, necesitamos montar el LED RGB. En el esquema de la figura se muestra un ejemplo de montaje.</p> <ol> <li> <p>Monte el HW como se muestra en la .</p> </li> <li> <p>Con la placa Nucleo-STM32\u00a0conectada al ordenador.</p> </li> <li> <p>Pulsa sobre el icono de depuraci\u00f3n  y selecciona  Clean and Debug sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p> </li> <li> <p>En el desplegable que se abre, selecciona el test <code>example_v3</code>. Se compilar\u00e1 y se cargar\u00e1 en la placa.</p> </li> <li> <p>Se parar\u00e1 en la primera l\u00ednea del <code>main()</code>. Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso. Este c\u00f3digo no termina, pues es un bucle <code>while</code> infinito.</p> </li> <li> <p>Abre la terminal del <code>gdb-server</code> para ver los mensajes que se van imprimiendo.</p> </li> <li> <p>Comprueba que los colores del LED RGB\u00a0cambian en funci\u00f3n de la intensidad que se le indica en los mensajes de la terminal.</p> </li> <li> <p>Haz distintas pruebas y aseg\u00farate de que el comportamiento es el adecuado.</p> </li> </ol> <p>\u00a1Hemos creado nuestra tercera librer\u00eda! F\u00edjate que es portable a cualquier plataforma solo con adaptar las funciones del <code>PORT</code>.</p> <p>No dejes de documentar el c\u00f3digo. Comprueba que la documentaci\u00f3n del c\u00f3digo se ha generado correctamente como se explica en la \"Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C\u201d <sup>4</sup>., o en el v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d.</p> <p>Guarda una copia de su proyecto como <code>simone_v3</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla.</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Juan Jos\u00e9 G\u00f3mez Valverde. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/88460/.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/datasheet/stm32f446re.pdf.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, Amadeo de Gracia Herranz, Sergio Esteban Romero, and Daniel Capell\u00e1n Mart\u00edn. Gu\u00eda de instalaci\u00f3n de herramientas para compilaci\u00f3n multiplataforma en C. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/92376/.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_4.html","title":"Versi\u00f3n 4","text":""},{"location":"notebook/version_4.html#version-4-integracion-final-y-modos-de-bajo-consumo","title":"Versi\u00f3n 4: integraci\u00f3n final y modos de bajo consumo","text":""},{"location":"notebook/version_4.html#sec:low_power_modes","title":"Modos de bajo consumo","text":"<p>Ya tenemos todos los elementos del sistema para que sea funcional. Quiz\u00e1s quisi\u00e9ramos \u2014si se hace el dise\u00f1o correspondiente\u2014 dise\u00f1ar una PCB para desplegarlo en alg\u00fan sitio. Si hici\u00e9semos esto, muy seguramente alimentar\u00edamos el dispositivo con una bater\u00eda. Si midi\u00e9semos el consumo con un amper\u00edmetro, podr\u00edamos calcular la autonom\u00eda de nuestro sistema. Te habr\u00e1s fijado que en los dispositivos comerciales como relojes inteligentes, mandos de TV, dispositivos IoT\u2026la autonom\u00eda puede superar de largo varios meses con un uso normal del mismo. Para conseguir esto contamos con los modos de bajo consumo. Buena parte de los microcontroladores que hoy en d\u00eda se precien cuentan con distintos modos de bajo consumo. Lea la secci\u00f3n \u201cModos de bajo consumo\u201d del libro de Fundamentos Te\u00f3ricos\u00a0<sup>1</sup>.</p> <p>En esta versi\u00f3n, antes de hacer la integraci\u00f3n final, vamos a implementar unas pocas funciones para gestionar el modo sleep de bajo consumo en nuestro sistema. Esto se destaca en 2 estados de la FSM de Simone que veremos m\u00e1s adelante. Estos estados comprueban si alguna de las FSM de los elementos est\u00e1, o no, activa, y en caso de que todas est\u00e9n inactivas, se va a dormir. El sistema se despertar\u00e1 ante alguna interrupci\u00f3n de un timer o interrupci\u00f3n externa (pulsaci\u00f3n de bot\u00f3n o teclado).</p> <p>Antes de empezar a implementar las funciones de bajo consumo vamos a partir de una serie de consideraciones de la FSM. En la siguiente secci\u00f3n se detallan mucho m\u00e1s los estados, pero por ahora, nos fijamos en lo relativo al bajo consumo:</p> <ul> <li> <p>En bajo consumo desactivaremos el SysTick para que no despierte al sistema cada \\(1 ms\\). As\u00ed pues, el contador del sistema no aumenta mientras se est\u00e1 dormido.</p> </li> <li> <p>Las ISR que generan interrupciones externas \u2014bot\u00f3n y teclado matricial\u2014 son las encargadas de reactivar el SysTick.</p> </li> <li> <p>La FSM del bot\u00f3n est\u00e1 inactiva en el estado <code>BUTTON_RELEASED</code>.</p> </li> <li> <p>La FSM del teclado matricial est\u00e1 inactiva en el estado <code>KEYBOARD_RELEASED_WAIT_ROW</code>.</p> </li> <li> <p>La FSM del RGB light est\u00e1 activa si el status indica que est\u00e1 funcionando, y no est\u00e1 ocioso (idle).</p> </li> <li> <p>Las autotransiciones de los estados de la FSM Simone (<code>SLEEP_WHILE_IDLE</code> y <code>SLEEP_WHILE_PLAYBACK</code>) est\u00e1n pensadas para cuando est\u00e9 trabajando en depuraci\u00f3n. El depurador genera interrupciones en la ejecuci\u00f3n del c\u00f3digo que despiertan a nuestro sistema. Como no se trata de interrupciones de nuestros elementos, no pasaremos a los estados, pero debemos dormirnos mientras no se detenga el depurador de nuevo en otro breakpoint. Este es el cometido de dichas autotransiciones.</p> </li> </ul> <p>Procedamos. Como siempre, tenga abierta la p\u00e1gina web de la API https://sdg2dieupm.github.io/simone/, ah\u00ed est\u00e1n todos los detalles de implementaci\u00f3n. Ahora vamos a tocar varios ficheros pero no crearemos ninguno nuevo.</p> <p>Vamos a a\u00f1adir las funciones de comprobaci\u00f3n espec\u00edficas de cada m\u00e1quina de estados.</p> <ol> <li> <p>En <code>fsm_button.c</code>: A\u00f1ade la funci\u00f3n <code>fsm_button_check_activity()</code> y su prototipo y documentaci\u00f3n del c\u00f3digo en <code>fsm_button.h</code>.</p> </li> <li> <p>En <code>fsm_keyboard.c</code> a\u00f1ade la funci\u00f3n <code>fsm_keyboard_check_activity()</code> y su prototipo y documentaci\u00f3n del c\u00f3digo en <code>fsm_keyboard.h</code>.</p> </li> <li> <p>En <code>fsm_rgb_light.c</code> a\u00f1ade la funci\u00f3n <code>fsm_rgb_light_check_activity()</code> y su prototipo y documentaci\u00f3n en <code>fsm_rgb_light.h</code>.</p> </li> </ol> <p>Para terminar, vamos a a\u00f1adir las funciones HW espec\u00edficas de manejo del modo stop y sleep en nuestro STM32F446RE. Primero a\u00f1adiremos algunas funciones generales del sistema en <code>stm32f4_system.c</code>; luego las modificaciones necesarias para restablecer el reloj de sistema SysTick tras una interrupci\u00f3n del bot\u00f3n o del teclado matricial, o de temporizador.</p> <p>En <code>stm32f4_system.c</code>:</p> <ol> <li> <p>Copia el c\u00f3digo de <code>port_system_power_stop()</code> y <code>port_system_power_sleep()</code> de la API. Por tener un orden, puedes hacerlo en una parte dedicada a POWER RELATED FUNCTIONS.</p> </li> <li> <p>Copia el c\u00f3digo de <code>port_system_systick_suspend()</code> de la API. Por tener un orden, puedes hacerlo en la parte dedicada a TIMER RELATED FUNCTIONS.</p> </li> <li> <p>Copia el c\u00f3digo de <code>port_system_systick_resume()</code> de la API. Por tener un orden, puedes hacerlo tambi\u00e9n en la parte dedicada a TIMER RELATED FUNCTIONS.</p> </li> <li> <p>Implementa la funci\u00f3n <code>port_system_sleep()</code> como indica la API. Por tener un orden, puedes hacerlo junto con las anteriores en la parte dedicada a POWER RELATED FUNCTIONS.</p> </li> </ol> <p>En <code>port_system.h</code>:</p> <ol> <li>A\u00f1ade los prototipos de las funciones anteriores y su documentaci\u00f3n.</li> </ol> <p>En el fichero en el que se encuentran nuestras ISR, <code>interr.c</code>, a\u00f1ade al principio de todas las ISR de todos las GPIO la llamada a <code>port_system_systick_resume()</code> para reactivar el contador del sistema SysTick inmediatamente tras la interrupci\u00f3n de pulsaci\u00f3n de cualquier tecla o del bot\u00f3n de usuario: <code>EXTI15_10_IRQHandler()</code>, <code>EXTI4_IRQHandler()</code>, y <code>EXTI9_5_IRQHandler()</code>.</p> <p>\u00a1Ya tenemos un sistema eficiente energ\u00e9ticamente! En el futuro ten siempre en consideraci\u00f3n la importancia de estos modos de bajo consumo en cualquier sistema embebido que se alimente con bater\u00edas. Vamos a unir todas las piezas.</p>"},{"location":"notebook/version_4.html#sec:fsm_simone_1","title":"Integraci\u00f3n final","text":"<p>Ya tenemos todos los m\u00f3dulos de las versiones V1-V3 de Simone desarrollados y probados: bot\u00f3n, teclado matricial y RGB light (LED) RGB. Ahora vamos a integrarlos en el sistema central, y rellenar el <code>main.c</code> del programa. Procedamos:</p> <p>La m\u00e1quina de estados del sistema Simone involucra a todos los elementos del mismo y la gesti\u00f3n del bajo consumo. Ser\u00e1 una implementaci\u00f3n principalmente de la l\u00f3gica de control del juego en <code>fsm_simone.c</code> y <code>fsm_simone.h</code>. La parte dependiente del hardware (<code>PORT</code>) relacionada con la temporizaci\u00f3n del juego (<code>port_simone</code>) se os proporciona parcialmente implementada para facilitar la integraci\u00f3n.</p>"},{"location":"notebook/version_4.html#sec:fsm_simone_main","title":"Mec\u00e1nica del juego y reglas","text":"<p>El sistema debe gestionar la l\u00f3gica del juego, tiempos de espera, niveles de dificultad y la interacci\u00f3n con los drivers de hardware (bot\u00f3n, teclado matricial y LED RGB).</p>"},{"location":"notebook/version_4.html#inicio","title":"Inicio","text":"<p>El sistema arranca en reposo en el estado <code>IDLE</code>. Al pulsar el bot\u00f3n de usuario, el sistema arranca pansando al estado que gestiona las secuencias de colores.</p> <p>El juego tiene 3 niveles de dificultad predefinidos: f\u00e1cil, medio y dif\u00edcil. Al arrancar el sistema, empieza en modo f\u00e1cil por defecto.</p> <p>Los niveles predefinidos son: <code>LEVEL_EASY</code>, <code>LEVEL_MEDIUM</code> y <code>LEVEL_HARD</code>.</p> <p>Consejo</p> <p>Utiliza un <code>enum</code> para definir los niveles y <code>#defines</code> para definir las teclas de cad nivel. La FSM tendr\u00e1 un campo <code>level</code> en su estructura para guardar el nivel del juego.</p>"},{"location":"notebook/version_4.html#generacion-de-secuencia-de-colores-y-teclas-asociadas","title":"Generaci\u00f3n de secuencia de colores y teclas asociadas","text":"<p>El juego b\u00e1sico usa 6 colores para mostrar al usuario de manera aleatoria en una secuencia, y se define tambi\u00e9n el color apagado para parpadear entre colores. Cada color estar\u00e1 asociado a una tecla. Los colores est\u00e1n definidos en <code>rgb_colors.h</code> como estructuras de tipo <code>rgb_color_t</code>. Las asociaciones son las siguientes:</p> Tecla Color '0' <code>color_white</code> '1' <code>color_red</code> '2' <code>color_green</code> '3' <code>color_blue</code> '5' <code>color_yellow</code> '8' <code>color_turquoise</code> <p>El n\u00famero de colores se debe definir en el fichero de cabecera con la etiqueta <code>NUMBER_OF_COLORS_GAME</code>.</p> <p>Cada color de la secuencia se mostrar\u00e1 a una velocidad (tiempo que tarda en apagarse), y a una intensidad lum\u00ednica. La dificultad rige estos dos par\u00e1metros elegidos al inicio del juego.</p> Nivel Velocidad por color Intensidad m\u00ednima <code>LEVEL_EASY</code> <code>SIMONE_TIME_ON_LEVEL_EASY_MS</code>: 3000 ms <code>LEVEL_EASY_MIN_INTENSITY</code>: 80% <code>LEVEL_MEDIUM</code> <code>SIMONE_TIME_ON_LEVEL_MEDIUM_MS</code>: 2000 ms <code>LEVEL_MEDIUM_MIN_INTENSITY</code>: 50% <code>LEVEL_HARD</code> <code>SIMONE_TIME_ON_LEVEL_HARD_MS</code>: 1000 ms <code>LEVEL_HARD_MIN_INTENSITY</code>: 20% <p>En todos los casos el tiempo de apagado entre colores es fijo: <code>SIMONE_TIME_OFF_BETWEEN_COLORS_MS</code>: 300 ms, que se debe definir en el fichero de cabecera. De igual modo se debe definir el tiempo de espera m\u00e1ximo para la entrada del usuario entre pulsaciones: <code>SIMONE_TIME_WAIT_INPUT_MS</code>: 5000 ms, y el timpo de feedback visual al usuario tras cada pulsaci\u00f3n: <code>SIMONE_TIME_VISUAL_FEEDBACK_MS</code>: 300 ms.</p> <p>La longitud de la secuencia m\u00e1xima es fija para todos los niveles <code>SEQUENCE_LENGTH</code>: 5 colores. Cuando el jugador complete la secuencia m\u00e1xima en un nivel, el sistema subir\u00e1 autom\u00e1ticamente al siguiente nivel (si no est\u00e1 ya en el m\u00e1ximo) y reiniciar\u00e1 la secuencia.</p> <p>Consejo</p> <p>Declara los <code>#define</code> de velocidad e intensidad en <code>fsm_simone.h</code> para mayor legibilidad.</p> <p>El juego debe comportarse de forma determinista siguiendo las siguientes reglas:</p>"},{"location":"notebook/version_4.html#flujo-del-juego","title":"Flujo del juego","text":"<ol> <li> <p>Ronda:</p> <ul> <li>El sistema a\u00f1ade un color aleatorio a la secuencia.</li> <li>El sistema reproduce la secuencia completa usando el LED (respetando la velocidad del nivel actual). Nota: Debe haber un breve instante de apagado entre colores consecutivos para distinguirlos si son el mismo.</li> <li>El sistema espera a que el usuario repita la secuencia.</li> </ul> </li> <li> <p>Turno del jugador:</p> <ul> <li>El usuario debe pulsar las teclas en el orden correcto.</li> <li>Timeout de usuario: Si el usuario tarda m\u00e1s de <code>SIMONE_TIME_WAIT_INPUT_MS</code> milisegundos en pulsar una tecla entre paso y paso, pierde la partida. Se ha establcido que este valor sea de 5000 ms.</li> <li>Si se pulsa una tecla incorrecta, pierde la partida.</li> <li>Si se pulsa una tecla correcta, se reinicia el temporizador y el jugador tiene otros <code>SIMONE_TIME_WAIT_INPUT_MS</code> milisegundos para pulsar la siguiente tecla.</li> </ul> </li> <li> <p>Victoria de ronda y juego:</p> <ul> <li>Si el usuario completa la secuencia actual correctamente, el sistema a\u00f1ade un nuevo color y repite el proceso (Ronda + 1).</li> <li>Si el usuario completa la secuencia de m\u00e1xima longitud <code>SEQUENCE_LENGTH</code> correctamente, aumenta de nivel.</li> <li>Si el usuario ya estaba en el nivel m\u00e1ximo y completa la secuencia, gana la partida y la FSM va al estado <code>IDLE</code>.</li> </ul> </li> <li> <p>Game over</p> <ul> <li>Si el usuario pierde (por error o por timeout), el sistema debe mostrar un mensaje de resultado y volver al estado de reposo para permitir empezar una nueva partida.</li> </ul> </li> </ol>"},{"location":"notebook/version_4.html#instrucciones-de-implementacion","title":"Instrucciones de implementaci\u00f3n","text":"<p>Para el desarrollo de la FSM, se os proporcionan la parte portable <code>PORT</code>, algunos <code>#define</code> de <code>fsm_simone.h</code>, y alg\u00fan c\u00f3digo en <code>fsm_simone.c</code>, como dos funciones auxiliares que facilitan la conversi\u00f3n entre los tipos de datos:</p> <ul> <li><code>_get_key_from_color()</code>: devuelve el car\u00e1cter asociado a un color (ej. '1' para Rojo).</li> <li><code>_get_color_from_key()</code>: devuelve el color asociado a un car\u00e1cter.</li> </ul> <p>Deb\u00e9is implementar el resto de la l\u00f3gica siguiendo la tabla de transiciones que dise\u00f1\u00e9is bas\u00e1ndoos en la especificaci\u00f3n de la FSM. Deb\u00e9is  completar el fichero de cabecera con los prototipos de funci\u00f3n y a\u00f1adir cualquier <code>#include</code>, <code>#define</code>, o funci\u00f3n auxiliar que consider\u00e9is necesaria para el correcto funcionamiento.</p> <p>Descarga del repositorio de la asignatura los ficheros correspondientes a la parte PORT y COMMON de la librer\u00eda de Simone correspondientes a la versi\u00f3n <code>V4</code>: https://github.com/sdg2DieUpm/simone/tree/simone_v4 y col\u00f3calos en las carpetas correspondientes de tu proyecto.</p>"},{"location":"notebook/version_4.html#sec:fsm_simone_spec","title":"FSM Simone. Especificaci\u00f3n detallada","text":"<p>En esta ocasi\u00f3n no se proporciona la m\u00e1quina de estados, ni funciones, ni API. Se dar\u00e1 el detalle de la l\u00f3gica de control del juego y alg\u00fan detalle de implementaci\u00f3n m\u00e1s cr\u00edtico, as\u00ed como las restricciones a implementar.</p> <p>La l\u00f3gica del juego es m\u00e1s compleja que la de un simple perif\u00e9rico. El sistema debe ser capaz de generar secuencias aleatorias, reproducirlas respetando tiempos, esperar la entrada del usuario, validar dicha entrada en tiempo real y gestionar la victoria o la derrota. Para gobernar todo esto, utilizaremos una FSM central que orquestar\u00e1 el funcionamiento del juego.</p> <p>Objetivo</p> <p>El objetivo de esta versi\u00f3n es implementar la l\u00f3gica de control del juego en <code>fsm_simone.c</code> y <code>fsm_simone.h</code>. La parte dependiente del hardware (<code>PORT</code>) relacionada con la temporizaci\u00f3n del juego (<code>port_simone</code>) se os proporciona parcialmente implementada para facilitar la integraci\u00f3n.</p>"},{"location":"notebook/version_4.html#definicion-de-la-estructura-de-datos","title":"Definici\u00f3n de la estructura de datos","text":"<p>Antes de dibujar estados y transiciones, es fundamental entender qu\u00e9 datos necesita manejar nuestra m\u00e1quina para funcionar. La estructura de datos <code>fsm_simone_t</code> act\u00faa como la memoria del juego. Aparte de los punteros a las otras FSM (teclado, bot\u00f3n, luces), necesitamos variables para gestionar la secuencia. Compl\u00e9tala con los detalles que se indican a continuaci\u00f3n.</p> <p>Hay que tener cuidado de no confundir los diferentes \u00edndices que gestionan el progreso del juego. Observa los campos definidos en la estructura:</p> <ul> <li>FSMs de los elementos:</li> <li><code>f</code>: estructura base de la FSM de Simone de tipo sm_t` y que ha de ser el primer elemento de la estructura.</li> <li><code>p_fsm_button</code>: puntero a la FSM del bot\u00f3n de usuario.</li> <li><code>p_fsm_keyboard</code>: puntero a la FSM del teclado matricial.</li> <li> <p><code>p_fsm_rgb_light</code>: puntero a la FSM del LED RGB.</p> </li> <li> <p>Secuencia de datos:</p> </li> <li><code>seq_colors</code>: un array que almacena la lista de <code>`SEQUENCE_LENGTH</code> colores (<code>rgb_color_t</code>) de la secuencia actual.</li> <li><code>seq_intensities</code>: un array paralelo al anterior, tambi\u00e9n de longitud <code>SEQUENCE_LENGTH</code>, y que almacena la intensidad ([0-100]) de cada color como un entero.</li> <li> <p><code>level</code>: almacena como un entero el nivel de dificultad actual definido en un enumerado (f\u00e1cil, medio, dif\u00edcil).</p> </li> <li> <p>\u00cdndices de control (\u00a1Cuidado aqu\u00ed!):</p> </li> <li><code>seq_idx</code>: indica la longitud actual de la secuencia que se debe jugar. Si estamos en la ronda 3, este \u00edndice valdr\u00e1 3. Determina hasta d\u00f3nde tiene que llegar la m\u00e1quina reproduciendo y hasta d\u00f3nde tiene que llegar el jugador repitiendo.</li> <li><code>playback_idx</code>: es el \u00edndice de Simone. Recorre la secuencia del array de colores y de intensidades. Indica qu\u00e9 color de la secuencia se est\u00e1 mostrando actualmente por los LED.</li> <li> <p><code>player_idx</code>: es el \u00edndice del jugador. Recorre tambi\u00e9n la secuencia, pero para comparar si el valor pulsado por el usuario es correcto.</p> </li> <li> <p>Flags y otros campos:</p> </li> <li><code>player_key</code>: almacena el caracter de la tecla que acaba de pulsar el usuario para poder verificarla con la correspondiente del color que deber\u00eda haber pulsado el usuario</li> <li><code>playback_over</code>: es un booleano que usaremos para controlar el parpadeo de los LED (encendido/apagado) durante la reproducci\u00f3n de la secuencia de colores.</li> <li><code>level</code>: almacena el nivel de dificultad actual del juego como un entero. Albergar\u00e1 los valores del enumerado que contiene los niveles <code>LEVEL_EASY</code>, <code>LEVEL_MEDIUM</code> y <code>LEVEL_HARD</code>.</li> <li><code>on_off_press_time_ms</code>: entero que almacena el tiempo que el bot\u00f3n de usuario ha estado presionado (para gestionar el encendido y apagado del sistema).</li> </ul> <p>Completa la estructura y docum\u00e9ntala en <code>fsm_simone.h</code>.</p> <p>Consejo sobre los \u00edndices</p> <p>El juego consiste esencialmente en comparar \u00edndices.</p> <ol> <li>La m\u00e1quina Simone reproduce desde <code>0</code> hasta <code>seq_idx</code> usando su \u00edndice <code>playback_idx</code>.</li> <li>El jugador repite desde <code>0</code> hasta <code>seq_idx</code> usando su \u00edndice <code>player_idx</code>.</li> <li>Si <code>player_idx</code> alcanza a <code>seq_idx</code> es que todo han sido aciertos, por tanto \u00a1ronda superada! Se incrementa <code>seq_idx</code> y vuelta a empezar.</li> </ol> <p>Importante: Nombres de las constantes</p> <p>Para que vuestro c\u00f3digo pase los test autom\u00e1ticos de los profesores, deb\u00e9is respetar escrupulosamente los nombres de los <code>#define</code> de tiempos y teclas, as\u00ed como los nombres de los estados en el <code>enum FSM_SIMONE</code> definidos en el fichero de cabecera proporcionado.</p>"},{"location":"notebook/version_4.html#especificacion-de-la-maquina-de-estados","title":"Especificaci\u00f3n de la m\u00e1quina de estados","text":"<p>El juego consta de 7 estados: 5 de juego y 2 de gesti\u00f3n de bajo consumo. Mant\u00e9n los nombres proporcionados de los estados. Tienes que completar y documentar todas las funciones de la tabla de transiciones y funciones auxiliares faltantes, as\u00ed como la propia tabla de transiciones. Sigue los criterios que hemos usado en las tres versiones anteriores.</p> <p>La l\u00f3gica del juego se divide en los siguientes estados principales. Estudia detenidamente qu\u00e9 debe ocurrir en cada uno y, sobre todo, qu\u00e9 condiciones provocan las transiciones a los siguientes estados.</p>"},{"location":"notebook/version_4.html#sec:estado-idle","title":"Estado <code>IDLE</code>","text":"<p>Es el estado de reposo. El sistema est\u00e1 dormido esperando a que el usuario quiera jugar.</p> Entradas Salidas (1) al arrancar el sistema (1) Por encendido del usuario (2) Por victoria (desde <code>WAIT_KEY</code>) (2) Por inactividad (3) Por derrota (desde <code>WAIT_KEY</code>) (4) Por apagado del usuario (desde <code>WAIT_KEY</code>)"},{"location":"notebook/version_4.html#cond:simone_idle_on","title":"Transici\u00f3n (1): Por encendido del usuario","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_on()</code> debe detectar si el jugador ha pulsado el bot\u00f3n de usuario durante el tiempo definido en <code>main.c</code> (<code>SIMONE_ON_OFF_PRESS_TIME_MS</code>). Si esto sucede, pasar\u00e1 al estado <code>ADD_COLOR</code> para iniciar la partida.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_init_game()</code> inicializa las variables del juego. Debe resetear la duraci\u00f3n del bot\u00f3n de usuario, la tecla del teclado matricial, los \u00edndices de control (<code>seq_idx</code>, <code>playback_idx</code>, <code>player_idx</code>), y las variables <code>playback_over</code>, y <code>player_key</code> (esta \u00faltima al car\u00e1cter definido en <code>KEY_NO_KEY_PRESSED</code>).</p> <p>El nivel de dificultad lo inicializa a <code>LEVEL_EASY</code>. Inicializa cada elemento del array de secuencia de colores al color <code>color_off</code> (ver colores en <code>rgb_colors.c</code>), y cada elemento del array de las intensidades a <code>0</code>.</p> <p>Llama a una funci\u00f3n privada auxiliar (<code>_add_color()</code>) pas\u00e1ndole un puntero a la m\u00e1quina de estados de Simone para a\u00f1adir un color e intensidad aleatorios a la secuencia. Ser\u00e1 el primer color de la ronda 1.</p> <p>Para que el LED RGB muestre el color, esta funci\u00f3n debe activar el status de la FSM RGB light llamando a la funci\u00f3n apropiada de dicha FSM.</p> <p>Por \u00faltimo, antes de salir, imprime un mensaje de inicio al usuario. Algo como: <code> <code>printf(\"[SIMONE][%ld] Simone game INIT\\n\", port_system_get_millis());</code> </code></p> <p>Funci\u00f3n auxiliar <code>_add_color</code></p> <p>Esta funci\u00f3n privada que encapsula la generaci\u00f3n aleatoria recibe un puntero a la FSM de Simone y debe:</p> <ol> <li> <p>Generar un \u00edndice aleatorio para seleccionar un color del array <code>p_colors_library</code>. Este array debe colocarse al inicio de <code>fsm_simone.c</code> y contiene direcciones los 6 colores usados en el juego.</p> <pre><code>const rgb_color_t *p_colors_library[] = {&amp;color_red, &amp;color_green, &amp;color_blue, &amp;color_yellow, &amp;color_turquoise, &amp;color_white};\n</code></pre> <p>Para generar el \u00edndice aleatorio usa la funci\u00f3n <code>rand()</code> de la <code>&lt;stdlib.h&gt;</code>, y el operador m\u00f3dulo <code>%</code> para acotar el valor al rango <code>0</code> a <code>NUMBER_OF_COLORS_GAME</code>. El valor aleatorio se generar\u00e1 gracias a la semilla <code>srand()</code> iniciada en <code>fsm_simone_init()</code>.</p> </li> <li> <p>Generar una intensidad aleatoria respetando los rangos definidos para el nivel actual (usando los define <code>LEVEL_X_MIN_INTENSITY</code>).</p> <p>Como la funci\u00f3n <code>rand()</code> devuelve un valor entre <code>0</code> y <code>RAND_MAX</code>, puedes usar la siguiente f\u00f3rmula para acotar el valor al rango deseado:</p> <pre><code>random_num = (random_num % (max - min + 1)) + min;\n</code></pre> <p>Donde los valores m\u00e1ximos y m\u00ednimos dependen del nivel actual <code>level</code>.</p> </li> <li> <p>Si <code>seq_idx</code> ha alcanzado el valor <code>SEQUENCE_LENGTH</code>, reseteamos <code>seq_idx</code>. Si no, guardamos el color e intensidad generados en las posiciones <code>seq_idx</code> de los arrays <code>seq_colors</code> y <code>seq_intensities</code>, respectivamente, y luego incrementamos <code>seq_idx</code> en 1.</p> </li> </ol>"},{"location":"notebook/version_4.html#cond:simone_idle_no_activity","title":"Transici\u00f3n (2): Por inactividad","text":"<p>Si no hay actividad, el sistema puede dormirse pasando al estado <code>SLEEP_WHILE_IDLE</code>.</p> <p>La funci\u00f3n de comprobaci\u00f3n <code>check_no_activity()</code> devuelve directamente el valor inverso al de su contraria <code>check_activity()</code>. Esta \u00faltima, lo que hace es devolver <code>true</code> si alguna de las FSM de los elementos (bot\u00f3n, teclado, RGB light) est\u00e1 activa. Para ello, llama a las funciones de comprobaci\u00f3n de actividad que hemos implementado en la secci\u00f3n de bajo consumo (<code>fsm_xxx_check_activity()</code>).</p> <p>La funci\u00f3n de acci\u00f3n <code>do_sleep_idle()</code> debe poner el sistema en un estado de bajo consumo. Para ello llama a la funci\u00f3n de sleep del <code>PORT</code> del sistema que hemos implementado en la secci\u00f3n de bajo consumo.</p>"},{"location":"notebook/version_4.html#sec:estado-add_color","title":"Estado <code>ADD_COLOR</code>","text":"<p>Este es un estado de transici\u00f3n. El sistema no se detiene aqu\u00ed esperando eventos externos, sino que realiza las operaciones l\u00f3gicas necesarias para preparar la secuencia de la siguiente ronda antes de reproducirla.</p> Entradas Salidas (1) Al iniciar partida (desde <code>IDLE</code>) (1) Secuencia actualizada (2) Al completar ronda (desde <code>WAIT_KEY</code>)"},{"location":"notebook/version_4.html#cond:simone_add_color_added","title":"Transici\u00f3n (1): Secuencia actualizada","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_color_added()</code> verifica si la longitud de la secuencia (<code>seq_idx</code>) es diferente del \u00edndice del jugador (<code>player_idx</code>). Como la la funci\u00f3n auxiliar <code>_add_color()</code> habr\u00e1 a\u00f1adido un nuevo color, esta condici\u00f3n se cumplir\u00e1 inmediatamente, permitiendo el paso al estado de reproducci\u00f3n de la secuencia <code>PLAYBACK</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_playback()</code> es el core de la reproducci\u00f3n. Su objetivo es gestionar el parpadeo de los LED respetando los tiempos de cada nivel. Dado que esta funci\u00f3n se llama repetidamente, utiliza la variable <code>playback_over</code> como un selector para alternar entre dos fases: mostrar color y pausa.</p> Diagrama de flujo de la funci\u00f3n `do_playback()`. <p>Aunque el diagrama resume el flujo l\u00f3gico, la implementaci\u00f3n correcta de <code>do_playback()</code> requiere prestar atenci\u00f3n a varios detalles t\u00e9cnicos para mantener la estabilidad del sistema:</p> <ol> <li>La naturaleza no bloqueante del temporizador: Cuando el diagrama indica \"Set timer de Simone\", debes llamar a <code>port_simone_set_timer_timeout()</code>. Hay que entender que esta funci\u00f3n no detiene la ejecuci\u00f3n del c\u00f3digo (no es un <code>delay</code>), sino que  programa una interrupci\u00f3n futura. El microcontrolador se dormir\u00e1 en el estado <code>SLEEP_WHILE_PLAYBACK</code> hasta que ese tiempo expire, interrumpa y vuelva a comprobarse la tabla de transiciones.</li> <li>Protecci\u00f3n contra entradas espurias: Una de las primeras acciones es detener el escaneo del teclado. Si no se hace, el usuario podr\u00eda pulsar teclas mientras se muestran las luces; esas pulsaciones se quedar\u00edan guardadas en el struct HW del teclado y se procesar\u00edan err\u00f3neamente en cuanto el juego pasara al estado de espera, provocando que se detecte como una tecla mal pulsada al inicio de la ronda siguiente.</li> <li>Acceso a la memoria de la secuencia: En la fase de encendido, debes recuperar la informaci\u00f3n almacenada previamente. Usa la variable <code>playback_idx</code> para acceder a los arrays paralelos <code>seq_colors</code> y <code>seq_intensities</code>. Recuerda que la funci\u00f3n de encendido del LED (<code>fsm_rgb_light_set_color_intensity</code>) requiere ambos par\u00e1metros.</li> <li>Sincronizaci\u00f3n de \u00edndices: F\u00edjate bien en la comparaci\u00f3n final. Comparamos <code>playback_idx</code> (lo que estamos mostrando ahora) con <code>seq_idx</code> (la longitud total de la secuencia actual).<ul> <li>Si <code>seq_idx</code> es 3, significa que hay colores en las posiciones 0, 1 y 2.</li> <li>Cuando terminamos de mostrar el color 2 y su pausa, incrementamos <code>playback_idx</code> a 3.</li> <li>Como 3 es mayor o igual que 3, sabemos que hemos terminado.</li> </ul> </li> </ol> <p>El marcador de fin de playback</p> <p>Para marcar el final de playback y poder comprobar al inicio si ha acabado o no, podemos usar varios mecanismos. Puedes usar, por ejemplo, una variable global, o puedes usar un valor inv\u00e1lido (que nunca vaya a ocurrir en el \u00edndice <code>playback_idx</code>). Cualquiera que uses, ten en cuenta que este marcador ser\u00e1 la forma de comunicar  a la funci\u00f3n de comprobaci\u00f3n <code>check_playback_over()</code> que la tarea de reproducci\u00f3n ha concluido.</p>"},{"location":"notebook/version_4.html#sec:estado-playback","title":"Estado <code>PLAYBACK</code>","text":"<p>En este estado el sistema ha tomado el control para mostrar la secuencia de colores al jugador como se ha mostrado en el flujograma de <code>do_playback</code>.</p> Entradas Salidas (1) Desde <code>ADD_COLOR</code> (1) Apagado manual (2) Desde <code>SLEEP_WHILE_PLAYBACK</code> (2) Turno del jugador (3) Por inactividad"},{"location":"notebook/version_4.html#cond:simone_playback_off","title":"Transici\u00f3n (1): Apagado manual","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_off()</code> verifica si el bot\u00f3n de la placa se ha mantenido pulsado el tiempo suficiente. Es id\u00e9ntica a la funci\u00f3n <code>check_on()</code>. Si se cumple, el sistema debe volver al estado de reposo <code>IDLE</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_stop_simone()</code>: resetea la duraci\u00f3n del bot\u00f3n de usuario, desactiva el estado del LED, resetea el nivel de dificultad a <code>LEVEL_EASY</code>, e imprime un mensaje de despedida indicando que el juego ha terminado y que puede presionar el bot\u00f3n para iniciar una nueva partida.</p>"},{"location":"notebook/version_4.html#cond:simone_playback_over","title":"Transici\u00f3n (2): Turno del jugador","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_playback_over()</code> determina si la m\u00e1quina ha terminado de reproducir toda la secuencia y, adem\u00e1s, ha terminado el tiempo de espera del \u00faltimo apagado. Debe devolver <code>true</code> solo si se cumplen dos condiciones simult\u00e1neamente:</p> <ol> <li>El marcador de fin de reproducci\u00f3n est\u00e1 activado (establecido en <code>do_playback()</code>).</li> <li>El temporizador ha expirado (<code>port_simone_get_timeout_status()</code>).</li> </ol> <p>La funci\u00f3n de acci\u00f3n <code>do_start_player_sequence()</code> prepara el sistema para escuchar al usuario. La funci\u00f3n debe:</p> <ol> <li>Reiniciar flag <code>playback_over</code> y reiniciar el \u00edndice del jugador <code>player_idx</code> para empezar a comprobar desde el principio.</li> <li>Apagar LED con el color <code>color_off</code> llamando a la funci\u00f3n correspondiente de la FSM del LED.</li> <li>Set timeout del temporizador con el tiempo m\u00e1ximo que tiene el usuario para reaccionar (<code>SIMONE_TIME_WAIT_INPUT_MS</code>).</li> <li>Iniciar el escaneo del teclado llamando a la funci\u00f3n correspondiente de la FSM del teclado, ya que se desactiv\u00f3 durante la reproducci\u00f3n.</li> <li>Imprimir un mensaje por consola informando al usuario de que es su turno y cu\u00e1ntos segundos tiene para responder entre pulsaciones.</li> </ol>"},{"location":"notebook/version_4.html#cond:simone_playback_no_activity","title":"Transici\u00f3n (3): Por inactividad","text":"<p>Si no ha expirado el temporizador mientras mostramos un color o una pausa, el sistema puede dormirse para ahorrar energ\u00eda.</p> <p>La funci\u00f3n de comprobaci\u00f3n <code>check_no_activity()</code> devuelve el valor inverso al de su contraria <code>check_activity()</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_sleep_playback()</code> debe poner el sistema en un estado de bajo consumo. Para ello llama a la funci\u00f3n de sleep del <code>PORT</code> del sistema que hemos implementado en la secci\u00f3n de bajo consumo.</p>"},{"location":"notebook/version_4.html#sec:estado-wait_key","title":"Estado <code>WAIT_KEY</code>","text":"<p>Es el turno del jugador. El sistema espera cualquier reacci\u00f3n por parte del usuario, ya sea para apagar el juego, introducir una tecla de la secuencia, o porque se ha agotado el tiempo.</p> Entradas Salidas (1) Desde <code>PLAYBACK</code> (1) Apagado manual (2) Desde <code>VERIFY_INPUT</code> (2) Victoria final (3) Derrota por tiempo (4) Fin de ronda (5) Pulsaci\u00f3n de una tecla"},{"location":"notebook/version_4.html#cond:simone_wait_key_off","title":"Transici\u00f3n (1): Apagado manual","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_off()</code> verifica si el bot\u00f3n de la placa se ha mantenido pulsado el tiempo suficiente. Es id\u00e9ntica a la funci\u00f3n <code>check_on()</code>. Si se cumple, el sistema debe volver al estado de reposo <code>IDLE</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_stop_simone()</code>: resetea la duraci\u00f3n del bot\u00f3n de usuario, desactiva el estado del LED, resetea el nivel de dificultad a <code>LEVEL_EASY</code>, e imprime un mensaje de despedida indicando que el juego ha terminado y que puede presionar el bot\u00f3n para iniciar una nueva partida.</p>"},{"location":"notebook/version_4.html#cond:simone_wait_key_winner","title":"Transici\u00f3n (2): Victoria final","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_winner()</code> es la m\u00e1s estricta. Deben cumplirse 3 condiciones: se cumple solo si (1) el jugador ha terminado la secuencia (debes jugar con los \u00edndices del jugador y la secuencia), (2) el \u00edndice que recorre el array de la secuencia ha llegado o superado la longitud m\u00e1xima (<code>SEQUENCE_LENGTH</code>) y, adem\u00e1s, (3) estamos en el nivel <code>level</code> de dificultad m\u00e1s alto (<code>LEVEL_HARD</code>).</p> <p>Si se cumplen estas 3 condiciones, el jugador ha ganado la partida y pasa al estado de reposo <code>IDLE</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_winner()</code> detiene el temporizador (<code>port_simone_stop_timer()</code>), y muestra un mensaje de felicitaci\u00f3n por consola indicando cu\u00e1ntos colores ha conseguido recordar el jugador.</p>"},{"location":"notebook/version_4.html#cond:simone_wait_key_timeout","title":"Transici\u00f3n (3): Derrota por tiempo","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_player_key_timeout()</code> verifica si el temporizador de espera de usuario ha expirado (<code>port_simone_get_timeout_status()</code>). Si el jugador tarda demasiado en pensar (<code>SIMONE_TIME_WAIT_INPUT_MS</code>), la condici\u00f3n se cumple y pasa al estado de reposo <code>IDLE</code>.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_game_over_timeout()</code> gestiona el fin de la partida por tiempo. Detiene el temporizador (<code>port_simone_stop_timer()</code>), reinicia todos los \u00edndices y elementos de la estructura de Simone (<code>seq_idx</code>, <code>player_idx</code>, etc.), detiene el escaneo del teclado antes de volver al reposo. Por \u00faltimo imprime un mensaje de Game Over, indicando alguna estad\u00edstica relevante (por ejemplo, cu\u00e1ntos colores ha conseguido recordar el jugador).</p>"},{"location":"notebook/version_4.html#cond:simone_wait_key_round_end","title":"Transici\u00f3n (4): Fin de ronda","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_player_round_end()</code> verifica si (1) el jugador ha reproducido con \u00e9xito toda la secuencia actual (comparando los \u00edndices <code>player_idx</code> y <code>seq_idx</code>), pero (2) a\u00fan no ha cumplido las condiciones de victoria total; esto es, no ha alcanzado la longitud m\u00e1xima de la secuencia o no est\u00e1 en el nivel m\u00e1s alto.</p> <p>Si se cumplen estas dos condiciones, el jugador ha superado la ronda y pasa al estado <code>ADD_COLOR</code> para preparar la siguiente ronda.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_add_color()</code> prepara el sistema para el siguiente nivel o secuencia. Puedes ver su l\u00f3gica detallada en el flujograma.</p> Diagrama de flujo de la funci\u00f3n `do_add_color()`."},{"location":"notebook/version_4.html#cond:simone_wait_any_key","title":"Transici\u00f3n (5): Pulsaci\u00f3n de una tecla","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_any_key_pressed()</code> utiliza el driver del teclado para detectar si hay alguna tecla disponible en el buffer. Devuelve <code>true</code> si el usuario ha pulsado algo (valor de tecla le\u00edda es distinto de <code>KEY_NO_KEY_PRESSED</code>). En tal caso, el sistema transiciona al estado intermedio <code>VERIFY_INPUT</code> para validar la pulsaci\u00f3n.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_capture_input()</code> realiza de nuevo la lectura de la tecla pulsada y proporciona feedback visual inmediato al usuario del color de la tecla que haya pulsado (sea correcta, o no). Debe:</p> <ol> <li>Obtiene la tecla del teclado y la guarda en la variable <code>player_key</code>. Luego, resetea el valor de la tecla del teclado para evitar lecturas repetidas usando la funci\u00f3n correspondiente de la FSM del teclado.</li> <li>Traduce la tecla a color usando la funci\u00f3n auxiliar <code>_get_color_from_key()</code>, y enciende el LED al m\u00e1ximo brillo con el color resultante.</li> <li>Pone el temporizador de Simone con un tiempo breve de feedback visual (definido en <code>SIMONE_TIME_VISUAL_FEEDBACK_MS</code>).</li> </ol>"},{"location":"notebook/version_4.html#sec:estado-verify_input","title":"Estado <code>VERIFY_INPUT</code>","text":"<p>Este es un estado temporal de retenci\u00f3n. El sistema entra aqu\u00ed justo despu\u00e9s de que el usuario pulse una tecla para mantener el LED encendido durante un breve instante (<code>SIMONE_TIME_VISUAL_FEEDBACK_MS</code>), permitiendo al jugador ver qu\u00e9 color ha seleccionado. En este estado se comprueba si la tecla le\u00edda es la esperada, o no.</p> Entradas Salidas (1) Desde <code>WAIT_KEY</code> (1) Tecla correcta (2) Tecla incorrecta"},{"location":"notebook/version_4.html#cond:simone_verify_valid","title":"Transici\u00f3n (1): Tecla correcta","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_input_valid()</code> realiza una validaci\u00f3n en dos pasos:</p> <ol> <li>Espera visual: Primero verifica si el temporizador de feedback visual ha expirado (<code>!port_simone_get_timeout_status()</code>). Si el tiempo no ha pasado, devuelve <code>false</code> y sale de la funci\u00f3n.</li> <li>Validaci\u00f3n l\u00f3gica: Si el tiempo ha pasado, compara la tecla pulsada guardada en la estructura con la esperada seg\u00fan la secuencia (ay\u00fadate de la funci\u00f3n auxiliar <code>_get_key_from_color()</code>). Devuelve <code>true</code> solo si coinciden. En este caso transicionar\u00e1 de vuelta al estado <code>WAIT_KEY</code> para esperar la siguiente pulsaci\u00f3n.</li> </ol> <p>La funci\u00f3n de acci\u00f3n <code>do_valid_key()</code> consolida el progreso del jugador. Debe:</p> <ol> <li>Apagar el LED con el color <code>color_off</code>.</li> <li>Aumentar el \u00edndice del jugador.</li> <li>Reiniciar la tecla guardada en la estructura a <code>KEY_NO_KEY_PRESSED</code>.</li> <li>Reiniciar el temporizador (<code>port_simone_set_timer_timeout()</code>) para dar tiempo al usuario a pulsar la siguiente tecla.</li> </ol>"},{"location":"notebook/version_4.html#cond:simone_verify_invalid","title":"Transici\u00f3n (2): Tecla incorrecta","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_input_invalid_finished()</code> sigue la misma l\u00f3gica temporal que la anterior, pero devuelve <code>true</code> si la tecla pulsada es diferente a la esperada.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_game_over_invalid_key()</code> gestiona la derrota:</p> <ol> <li>Apaga el LED para finalizar el feedback.</li> <li>Reinicia todos los elementos de la estructura de Simone (<code>seq_idx</code>, <code>player_idx</code>, <code>player_key</code>, etc.) para que la pr\u00f3xima vez se empiece desde cero.</li> <li>Reiniciar el temporizador de Simone (<code>port_simone_stop_timer()</code>) y detiene el escaneo* del teclado usando la funci\u00f3n correspondiente de la FSM del teclado.</li> <li>Muestra por consola informaci\u00f3n sobre qu\u00e9 tecla se esperaba y cu\u00e1l se puls\u00f3 realmente, junto con un mensaje de Game Over. Hace uso de la funci\u00f3n auxiliar <code>_get_key_from_color()</code>.</li> </ol>"},{"location":"notebook/version_4.html#sec:estado-sleep_while_idle","title":"Estado <code>SLEEP_WHILE_IDLE</code>","text":"<p>Es el estado de bajo consumo. El sistema entra aqu\u00ed cuando est\u00e1 en reposo (<code>IDLE</code>) y no hay ninguna interacci\u00f3n por parte del usuario, permitiendo ahorrar energ\u00eda mientras se espera a que se inicie una nueva partida.</p> Entradas Salidas (1) Desde <code>IDLE</code> (1) Detecci\u00f3n de actividad (2) Desde <code>SLEEP_WHILE_IDLE</code> (autotransici\u00f3n) (2) Sin actividad"},{"location":"notebook/version_4.html#cond:simone_sleep_idle_wake","title":"Transici\u00f3n (1): Detecci\u00f3n de actividad","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_activity()</code> verifica si alg\u00fan perif\u00e9rico ha generado un evento (bot\u00f3n pulsado, tecla pulsada, etc.). Al despertar por una interrupci\u00f3n, esta condici\u00f3n se cumple y el sistema transiciona de vuelta a <code>IDLE</code> para procesar dicho evento.</p> <p>En esta transici\u00f3n no hay funci\u00f3n de acci\u00f3n asociada (es <code>NULL</code>), ya que la propia salida del estado de sue\u00f1o es suficiente para reactivar la l\u00f3gica principal.</p>"},{"location":"notebook/version_4.html#cond:simone_sleep_idle_sleep","title":"Transici\u00f3n (2): Sin actividad","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_no_activity()</code> confirma que el sistema sigue inactivo. Esta autotransici\u00f3n sirve para gestionar el bajo consumo en modo depuraci\u00f3n, cuando se despierta por un breakpoint o similar.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_sleep_idle()</code> detendr\u00e1 el reloj de la CPU  hasta que ocurra la pr\u00f3xima interrupci\u00f3n.</p>"},{"location":"notebook/version_4.html#sec:estado-sleep_while_playback","title":"Estado <code>SLEEP_WHILE_PLAYBACK</code>","text":"<p>Este estado gestiona el bajo consumo durante la reproducci\u00f3n. Mientras el LED est\u00e1 encendido mostrando un color o apagado durante una pausa, no es necesario que la CPU est\u00e9 consumiendo ciclos. El sistema duerme aqu\u00ed hasta que el temporizador interrumpe.</p> Entradas Salidas (1) Desde <code>PLAYBACK</code> (1) Timeout del color/pausa (2) Desde <code>SLEEP_WHILE_PLAYBACK</code> (autotransici\u00f3n) (2) Sin actividad"},{"location":"notebook/version_4.html#cond:simone_sleep_playback_timeout","title":"Transici\u00f3n (1): Timeout del color/pausa","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_playback_color_timeout()</code> consulta al si el temporizador (<code>port_simone_get_timeout_status()</code>) configurado en el paso anterior ha expirado. Si es as\u00ed, significa que es hora de cambiar el estado del LED.</p> <p>La funci\u00f3n de acci\u00f3n asociada es <code>do_playback()</code>. Esta transici\u00f3n devuelve al sistema al estado <code>PLAYBACK</code>, ejecutando inmediatamente la l\u00f3gica de alternancia de luces (encender/apagar) descrita en el flujograma de dicho estado.</p> <p>Funcionamiento c\u00edclico</p> <p>Observa que el sistema entra y sale constantemente entre <code>PLAYBACK</code> y <code>SLEEP_WHILE_PLAYBACK</code>.</p> <ol> <li><code>PLAYBACK</code> configura el LED y el temporizador, y salta a dormir.</li> <li>Espera dormido en bajo consumo.</li> <li>Timer interrumpe y vuelve a <code>PLAYBACK</code> para cambiar el LED, y puede volver a dormir de nuevo.</li> </ol>"},{"location":"notebook/version_4.html#cond:simone_sleep_playback_sleep","title":"Transici\u00f3n (2): Sin actividad","text":"<p>La funci\u00f3n de comprobaci\u00f3n <code>check_no_activity()</code> verifica que no hay eventos pendientes.</p> <p>La funci\u00f3n de acci\u00f3n <code>do_sleep_playback()</code> detendr\u00e1 el reloj de la CPU  hasta que ocurra la pr\u00f3xima interrupci\u00f3n de la misma forma que lo hace <code>do_sleep_idle()</code>, o <code>do_sleep_playback()</code>.</p> <p>Funciones de bajo consumo</p> <p>Habr\u00e1s notado que hay 3 funciones que hacen lo mismo: <code>do_sleep_idle()</code>, <code>do_sleep_playback()</code> y <code>do_sleep_playback()</code>. Esto es una buena pr\u00e1ctica para poder saber d\u00f3nde est\u00e1 y de d\u00f3nde viene el sistema cuando se est\u00e1 depurando.</p> <p>Bajo consumo durante la lectura del teclado</p> <p>N\u00f3tese que no hay bajo consumo en el estado <code>WAIT_KEY</code>. Esto es intencionado, ya que el jugador debe poder interactuar en cualquier momento. Por la forma en la que se excitan y leen las filas y columnas, la gesti\u00f3n del bajo consumo aqu\u00ed es posible, pero m\u00e1s complicada de manejar. Se deja como implementaci\u00f3n a elegir en la Versi\u00f3n 5.</p>"},{"location":"notebook/version_4.html#sec:v4_fsm_simone_init","title":"Inicializaci\u00f3n de la FSM Simone","text":"<p>Ya hemos codificado las funciones de entrada y salida, ahora vamos a codificar las funciones privadas que nos quedan.</p> <p>Codifica la funci\u00f3n <code>fsm_simone_init()</code> de forma an\u00e1loga a las anteriores m\u00e1quinas de estados. </p> <ol> <li>Llama a la funci\u00f3n <code>fsm_init()</code> pas\u00e1ndole el puntero a la m\u00e1quina de estados, y el array de transiciones.</li> <li>Inicializa el HW asociado a la FSM de Simone llamando a <code>port_simone_init()</code>.</li> <li>Inicializa en la estructura todos los elementos que ser reciben: los punteros a las m\u00e1quinas de estados de los elementos del sistema Simone, el tiempo de pulsaci\u00f3n del bot\u00f3n para encender y apagar, y el nivel inicial. </li> <li>Inicializa la semilla aleatoria con la funci\u00f3n <code>srand(time(NULL))</code> para asegurar que los n\u00fameros aleatorios generados sean diferentes en cada ejecuci\u00f3n. Deber\u00e1s importar la cabecera <code>&lt;time.h&gt;</code> para usar la funci\u00f3n <code>time()</code>.</li> <li>Imprime un mensaje por consola indicando al usuario que debe pulsar el bot\u00f3n para iniciar una nueva partida.</li> </ol> <p>Codifica las funciones <code>fsm_simone_fire()</code> y <code>fsm_simone_destroy()</code> de forma an\u00e1loga a las anteriores m\u00e1quinas de estados.</p> <p>Ya hemos terminado con al FSM, ahora vamos a integrar todas las FSM en el <code>main.c</code> y a probarlo.</p>"},{"location":"notebook/version_4.html#sec:v4_integration","title":"Integraci\u00f3n HW-SW de la FSM Simone","text":"<p>Ha llegado la hora de integrar la parte HW-SW del sistema, y depurar. Vamos a escribir las l\u00edneas de c\u00f3digo necesarias en <code>main.c</code> para probar que funciona. Procedamos:</p> <ol> <li> <p>Abre el fichero <code>main.c</code> e incluye las cabeceras necesarias.</p> </li> <li> <p>Define la macro <code>SIMONE_ON_OFF_PRESS_TIME_MS</code> como indica la API para definir una pulsaci\u00f3n larga como aquella que supere \\(1 s\\). \u00a1Ojo, porque el tiempo hay que darlo en milisegundos! Este es el tiempo que se debe mantener pulsado el bot\u00f3n para encender y apagar el juego.</p> </li> <li> <p>Despu\u00e9s de la inicializaci\u00f3n del sistema con la llamada a la funci\u00f3n <code>port_system_init()</code>, crea la m\u00e1quina de estados para el bot\u00f3n. Dale un nombre representativo (*e.g.*, <code>p_fsm_button</code>). Para ello llama a la funci\u00f3n <code>fsm_button_new()</code> con los argumentos necesarios. A continuaci\u00f3n, haz lo propio con la m\u00e1quina de estados del teclado matricial, y con la del RGB light trasero. Dales nombres representativos.</p> </li> <li> <p>Crea la m\u00e1quina de estados para el sistema Simone, puedes darle un nombre representativo (*e.g.*, <code>p_fsm_simone</code>). \u00a1No pases los valores \u201ca pincho\u201d, usa los <code>#define</code> que has creado!</p> </li> <li> <p>En el bucle <code>while</code>, lanza constantemente la funci\u00f3n <code>fsm_xxx_fire()</code>, para las m\u00e1quinas de estados del bot\u00f3n, el teclado, el RGB light y Simone.</p> <p>Conviene que el sistema sea lo \u00faltimo porque depende de la actualizaci\u00f3n del estado de las FSM de los elementos anteriores.</p> </li> <li> <p>Por \u00faltimo solo nos queda un aspecto meramente formal, casi acad\u00e9mico. Cuando creamos las m\u00e1quinas de estado con las funciones <code>fsm_xxx_new()</code> estamos reservando memoria de forma din\u00e1mica (con la funci\u00f3n <code>malloc()</code>). Cuando las m\u00e1quinas de estado dejan de usarse, esa memoria debe ser liberada para poder ser usada por otras partes del c\u00f3digo. Esa liberaci\u00f3n se har\u00e1 con la llamada a la funci\u00f3n <code>fsm_destroy()</code>.</p> <p>Despu\u00e9s del bucle <code>while</code> llama a <code>fsm_xxx_destroy()</code> para cada una de las FSM pas\u00e1ndole su tipo concreto. Esto libera la memoria de cada una de las m\u00e1quinas de estado creadas: bot\u00f3n, teclado matricial, RGB light, y Simone.</p> <p>Como se dec\u00eda, esto es pura ortodoxia, porque el bucle <code>while</code> del <code>main</code> es infinito, y nunca saldr\u00e1 de ah\u00ed, por lo que nuestras FSM nunca dejar\u00e1n de usarse y las l\u00edneas que acabas de escribir con <code>fsm_xxx_destroy()</code> nunca se ejecutar\u00e1n. No obstante, conviene que sepas que as\u00ed deber\u00eda hacerse.</p> </li> <li> <p>Compila y comprueba que no tiene ning\u00fan error. Si tienes, corr\u00edgelos.</p> </li> </ol> <p>Puede ser buen momento ahora para documentar todo el c\u00f3digo con Doxygen.</p>"},{"location":"notebook/version_4.html#test-de-integracion-de-simone","title":"Test de integraci\u00f3n de Simone","text":""},{"location":"notebook/version_4.html#test-de-funcionalidades","title":"Test de funcionalidades","text":"<p>Ya has probado los test de ejemplo de los distintos elementos y que se os han sido proporcionado. Ahora vamos a probar el sistema Simone completo. No se os va a pedir hacer un test formal, pero con todo el trabajo que has hecho, es conveniente que compruebes que todo funciona correctamente. Monta el circuito como se muestra en la . Prueba todo el sistema como en el v\u00eddeo demostraci\u00f3n Simone. Procedamos:</p> Montaje final con el teclado, el bot\u00f3n y el LED RGB. <ol> <li> <p>Conecta la placa Nucleo-STM32\u00a0al ordenador.</p> </li> <li> <p>Compila y carga el programa <code>main</code> en la placa ( <code>Clean and Debug</code>). Comprueba que no tienes errores de compilaci\u00f3n.</p> </li> <li> <p>Prueba que el bot\u00f3n enciende y apaga el juego Simone.</p> </li> <li> <p>Prueba que el RGB light se enciende de manera acorde en la primera ronda y enciende un color y mostrando los mensajes por la terminal oportuna</p> </li> <li> <p>Prueba que el teclado recoge correctamente las teclas, tanto cuando aciertos, como cuando fallas.</p> </li> <li> <p>Prueba que el nivel de dificultad sube correctamente cada vez que se completa una secuencia de longitud <code>SEQUENCE_LENGTH</code>, hasta un m\u00e1ximo de 3 niveles.</p> </li> <li> <p>Prueba que mientras est\u00e1 haciendo el playback no responde al teclado.</p> </li> <li> <p>Prueba que puedes apagarlo y encenderlo en cualquier momento.</p> </li> <li> <p>Prueba que, estando apagada, el juego Simone no responde al teclado ni muestra nada por el LED RGB.</p> </li> <li> <p>Prueba, en general, el funcionamiento correcto como en el v\u00eddeo de demostraci\u00f3n. Si encuentras alg\u00fan error, corr\u00edgelo.</p> </li> </ol>"},{"location":"notebook/version_4.html#comprobaci\u00f3n-de-bajo-consumo","title":"Comprobaci\u00f3n de bajo consumo","text":"<p>Comprobaremos que el modo sleep de bajo consumo se gestiona correctamente. Compila y comprueba que no tienes errores de sintaxis o de c\u00f3digo. Para comprobar que el sistema est\u00e1 dormido, podemos hacerlo de dos formas:</p> <ol> <li> <p>Lo m\u00e1s habitual \u2014si no tenemos acceso a un depurador y si tenemos que caracterizar nuestro producto\u2014 ser\u00eda hacerlo mediante la medici\u00f3n del consumo del microcontrolador (\u00a1no de los elementos HW de nuestro sistema!). Para medir el consumo, ve el punto \u201c6.6 JP6 (IDD)\u201d del manual de la placa\u00a0<sup>2</sup>. Si vas a medirlo, tambi\u00e9n deber\u00edas desconectar los jumpers del <code>ST-LINK</code> del conector <code>CN2</code>. Para ver el ahorro tendr\u00edamos que medirlo en ejecuci\u00f3n sobre versi\u00f3n final. Esto puedes hacerlo si deseas como funcionalidad extra en la Versi\u00f3n 5, e incluir la informaci\u00f3n en la documentaci\u00f3n del c\u00f3digo (fichero <code>README.md</code>).</p> </li> <li> <p>Lo que haremos para demostrar que el sistema alterna entre el modo despierto y dormido ser\u00e1 depurando. Contin\u00faa con la depuraci\u00f3n sin poner puntos de parada. Cuando el sistema est\u00e9 inactivo, pausa la depuraci\u00f3n y comprueba que se ha detenido en la l\u00ednea de c\u00f3digo tras la llamada a wait for interrupt (<code>__WFI()</code>), similar a como se muestra en la . Esto querr\u00e1 decir que, efectivamente, la ejecuci\u00f3n estaba detenida esperando una interrupci\u00f3n, se ha despertado, y ha pasado a la siguiente l\u00ednea de c\u00f3digo.</p> </li> </ol> Restauraci\u00f3n del modo despierto vista en depuraci\u00f3n. <p>Realiza con con Paint, Drawio, o cualquier programa que elijas el diagrama de la FSM del sistema con todas sus transiciones. A\u00f1\u00e1dela a tu <code>README.md</code>.</p> <p>\u00a1Ya tenemos el sistema Simone funcionando! No olvides documentarlo (v\u00eddeo \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d). En la siguiente versi\u00f3n podr\u00e1s a\u00f1adir m\u00e1s funcionalidades a tu elecci\u00f3n. Puedes incluir m\u00e1s capturas o im\u00e1genes para enriquecer la documentaci\u00f3n.</p> <p>Guarda una copia de su proyecto como <code>simone_v4</code> para tener un punto de partida para la siguiente versi\u00f3n, y una copia de seguridad por si algo falla. Esta copia s\u00fabela al buz\u00f3n de entrega de la asignatura separada de la que hagas con la versi\u00f3n 5, que tiene otro buz\u00f3n. \u00a1\u00c1nimo!</p> <ol> <li> <p>Josu\u00e9 Pag\u00e1n Ortiz, Pedro Jos\u00e9 Malag\u00f3n Marzo, Rom\u00e1n C\u00e1rdenas Rodr\u00edguez, and Juan Jos\u00e9 G\u00f3mez Valverde. Fundamentos te\u00f3ricos de sistemas basados en microcontrolador STM32. Sistemas Digitales II, Sistemas Electr\u00f3nicos. Josu\u00e9 Pag\u00e1n Ortiz, Madrid, March 2025. URL: https://oa.upm.es/88460/.\u00a0\u21a9</p> </li> <li> <p>STMicroelectronics. Um1724 user manual. stm32 nucleo-64 boards. Technical Report, STMicroelectronics, 2020. URL: https://www.st.com/resource/en/user_manual/um1724-stm32-nucleo64-boards-mb1136-stmicroelectronics.pdf.\u00a0\u21a9</p> </li> </ol>"},{"location":"notebook/version_5.html","title":"Versi\u00f3n 5","text":""},{"location":"notebook/version_5.html#cha:version5","title":"Versi\u00f3n 5: funcionalidades de libre elecci\u00f3n","text":"<p>En las \u00faltimas sesiones puedes poner a punto la versi\u00f3n final del sistema e incluir diversas funcionalidades a tu elecci\u00f3n. Con ello podr\u00e1s alcanzar la m\u00e1xima nota. Recuerda que (i) el proyecto es el \\(70\\%\\) de la nota total, y (ii) que el proyecto propuesto con especificaciones m\u00ednimas obligatorias tiene un m\u00e1ximo de 8 puntos. Estas funcionalidades de libre elecci\u00f3n son un \\(20\\%\\) de la nota final, \u00a1no las dejes!</p>"},{"location":"notebook/version_5.html#posibles-funcionalidades","title":"Posibles funcionalidades","text":"<p>Las sugerencias que se muestran son orientativas. La valoraci\u00f3n de la dificultad (de dise\u00f1o y de implementaci\u00f3n) tambi\u00e9n. No obstante, se valorar\u00e1n especialmente aquellas funcionalidades que conlleven alg\u00fan tipo de esfuerzo por parte del alumno a un mayor n\u00famero de niveles. As\u00ed, se tendr\u00e1n en cuenta los 3 niveles de la arquitectura t\u00edpica de cualquier sistema embebido: (i) nivel SW o de aplicaci\u00f3n (nivel superior en verde de la pila presentada en la\u00a0), nivel HW (nivel inferior en rojo), y nivel de SW de sistema o nivel dedicado a la integraci\u00f3n HW-SW (nivel intermedio en naranja), mediante el uso de drivers (i.e.\u00a0controladores o librer\u00edas) SW para el manejo de dispositivos.</p> Niveles de valoraci\u00f3n de las posibles funcionalidades a implementar. <p>As\u00ed, el impacto de la funcionalidad se valorar\u00e1 seg\u00fan las escalas de la figura de niveles\u00a0, y podr\u00eda puntuar, orientativamente, como se indica:</p> <ul> <li> <p>Solo el primer nivel: BAJA valoraci\u00f3n, por tratarse de una funcionalidad que solo requiere modificar c\u00f3digo. Hasta \\(0.5\\) puntos.</p> </li> <li> <p>Solo los dos primeros niveles: valoraci\u00f3n MEDIA, por tratarse de una funcionalidad que, adem\u00e1s de modificar el c\u00f3digo, requiere del uso de alg\u00fan nuevo recurso del STM32F446RE\u00a0o la placa (como por ejemplo otro temporizador, PWM, uso de ADC, FSM) o de una configuraci\u00f3n alternativa de los ya usados (bien sean HW o SW). Entre \\(0.5\\) y \\(1.0\\) puntos.</p> </li> <li> <p>Los tres niveles: valoraci\u00f3n ALTA, por afectar a todos los niveles de dise\u00f1o del sistema, por lo que es fundamental que se incluya nuevo HW al sistema. Entre \\(1.0\\) y \\(1.5\\) puntos.</p> </li> </ul> <p>En cualquier caso, las funcionalidades aqu\u00ed propuestas o las que t\u00fa sugieras, pueden implementarse de distintas formas m\u00e1s o menos complejas y con distintos grados de perfecci\u00f3n (calidad), por lo que la calificaci\u00f3n final depender\u00e1 de ambos aspectos. Igualmente, la originalidad o la novedad de tus propuestas, ser\u00e1 tenida en cuenta para la evaluaci\u00f3n. Hacer una funcionalidad no implica necesariamente conseguir toda la puntuaci\u00f3n. Del mismo modo, podr\u00edan conseguirse m\u00e1s puntos de los previstos, si se merece.</p> <p>ATENCI\u00d3N</p> <p>Es obligatoria para todas las funcionalidades meter su documentaci\u00f3n Doxygen incluyendo, si es necesario, diagramas o im\u00e1genes que expliquen el funcionamiento de la nueva funcionalidad. Se ha de hacer un v\u00eddeo demostrativo corto, 2-3 minutos con lo m\u00e1s relevante de tus propuestas. Incluye un enlace p\u00fablico al v\u00eddeo en el README.md.</p> <p>Recuerda que tienes el v\u00eddeo de ayuda \"[MatrixMCU] Documentaci\u00f3n de c\u00f3digo con Doxygen\u201d.</p> <p>Podr\u00edas hacer uso de HW disponible en el laboratorio como teclados matriciales de 16 botones y pantallas LCD. Tambi\u00e9n puedes a\u00f1adir el tuyo. A continuaci\u00f3n se muestran algunas posibles ideas para a\u00f1adir al sistema o convertirlo en parte de otro proyecto mayor. Pero recuerda que \u00a1las m\u00e1s interesantes son las que a ti se te puedan ocurrir!</p> <p>Si tienes dudas sobre la implementaci\u00f3n o valoraci\u00f3n de estas u otras funcionalidades, no dudes en ponerte en contacto con cualquiera de los profesores de la asignatura.</p> <p>Guarda una copia de tu proyecto como <code>simone_v5</code> separada de la que contiene los requisitos b\u00e1sicos V1-V4, y s\u00fabelo a Moodle en el buz\u00f3n preparado para V5. No olvides incluir el v\u00eddeo demostrativo en el README.md.</p> Descripci\u00f3n Dificultad A\u00f1adir un modo inverso para que el jugador tenga que repetir la secuencia empezando por el \u00faltimo color mostrado hasta el primero. \ud83d\udfe2 BAJA Tecla wildcard para permitir repetir la \u00faltima secuencia. \ud83d\udfe2 BAJA Sistema de vidas para permitir un margen de error antes del Game Over, indicando los fallos restantes con parpadeos o colores espec\u00edficos. \ud83d\udfe2 BAJA A\u00f1adir estad\u00edsticas de partida para medir y mostrar por consola el tiempo medio de reacci\u00f3n del jugador entre colores o la ronda m\u00e1xima alcanzada. \ud83d\udfe2 BAJA Meter el tiempo de anti-rebote como caracter\u00edstica HW del bot\u00f3n y que no se le pase a la FSM del bot\u00f3n, sino que se le pida al <code>PORT</code>. \ud83d\udfe2 BAJA Que haya un indicador LED para mostrar las distintas situaciones del sistema (cuando se ha encendido, apagado, etc.). \ud83d\udfe2 BAJA A\u00f1adir un nuevo bot\u00f3n para gestionar alg\u00fan aspecto de la gesti\u00f3n del juego, o a\u00f1adir estad\u00edsticas de uso en un campo de la FSM. \ud83d\udfe1 BAJA-MEDIA Que el bot\u00f3n mida el tiempo de pulsaci\u00f3n con input capture (en lugar de con ticks) en proporci\u00f3n al tiempo que ha estado encendido el LED. \ud83d\udfe1 BAJA-MEDIA Implementar alguna funcionalidad que tenga en cuenta que el bot\u00f3n de usuario est\u00e1 pulsado m\u00e1s de un tiempo determinado. \ud83d\udfe1 BAJA-MEDIA A\u00f1adir un zumbador (Buzzer)  para generar tonos musicales distintos mediante PWM asociados a cada color sincronizados con la luz. \ud83d\udfe0 MEDIA-ALTA Dise\u00f1ar o adaptar dise\u00f1os de impresiones 3D para Nucleo y hacer el sistema m\u00e1s robusto (ver dise\u00f1os en Thingiverse o Tinkercad). \ud83d\udfe0 MEDIA Multijugador local integrando un segundo teclado matricial y modificando la FSM para permitir un modo versus (uno propone secuencia, otro repite). \ud83d\udfe0 MEDIA-ALTA Desarrollo de test unitarios y ejemplos exhaustivos de todo el proyecto (cobertura de c\u00f3digo superior al habitual). \ud83d\udfe0 MEDIA-ALTA Multijugador remoto conectando dos placas STM32 mediante UART, I2C o transceptores inal\u00e1mbricos para jugar una partida sincronizada a distancia. \ud83d\udd34 ALTA Crear una interfaz gr\u00e1fica de PC que se comunique por puerto serie y muestre el tablero de colores y puntuaciones en la pantalla del ordenador en tiempo real. \ud83d\udd34 ALTA Integrar un lector de tarjetas RFID o cualquier otra forma de comunicaci\u00f3n inal\u00e1mbrica que permita interactuar con el sistema. \ud83d\udd34 ALTA Nuevos esquemas y montajes PCB. \ud83d\udd34 ALTA Integrar interfaces de visualizaci\u00f3n alternativa (display LCD, web, m\u00f3vil), comunicaci\u00f3n con la nube... \ud83d\udd34 ALTA"}]}