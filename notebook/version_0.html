
<!DOCTYPE html>

<html class="no-js" lang="es">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<link href="https://sdg2dieupm.github.io/simone/notebook/version_0.html" rel="canonical"/>
<link href="sesion_introduccion.html" rel="prev"/>
<link href="version_1.html" rel="next"/>
<link href="../assets/general/favicon.ico" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.14" name="generator"/>
<title>Versión 0 - Laboratorio de Sistemas Digitales II</title>
<link href="../assets/stylesheets/main.342714a4.min.css" rel="stylesheet"/>
<link href="../assets/stylesheets/palette.06af60db.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
<link href="../stylesheets/notebook-extra.css" rel="stylesheet"/>
<script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
</head>
<body data-md-color-accent="deep_orange" data-md-color-primary="blue_grey" data-md-color-scheme="default" dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#cha:peoyecto_base">
          Saltar a contenido
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header md-header--shadow" data-md-component="header">
<nav aria-label="Cabecera" class="md-header__inner md-grid">
<a aria-label="Laboratorio de Sistemas Digitales II" class="md-header__button md-logo" data-md-component="logo" href="../index.html" title="Laboratorio de Sistemas Digitales II">
<img alt="logo" src="../assets/notebook_imgs/general/etsit.png"/>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            Laboratorio de Sistemas Digitales II
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Versión 0
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Cambiar a modo oscuro" class="md-option" data-md-color-accent="deep_orange" data-md-color-media="" data-md-color-primary="blue_grey" data-md-color-scheme="default" id="__palette_0" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Cambiar a modo oscuro">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg>
</label>
<input aria-label="Cambiar a modo claro" class="md-option" data-md-color-accent="deep_orange" data-md-color-media="" data-md-color-primary="blue_grey" data-md-color-scheme="slate" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_0" hidden="" title="Cambiar a modo claro">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg>
</label>
</form>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="Búsqueda" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="Búsqueda" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path></svg>
</label>
<nav aria-label="Buscar" class="md-search__options">
<button aria-label="Limpiar" class="md-search__icon md-icon" tabindex="-1" title="Limpiar" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            Inicializando búsqueda
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navegación" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="Laboratorio de Sistemas Digitales II" class="md-nav__button md-logo" data-md-component="logo" href="../index.html" title="Laboratorio de Sistemas Digitales II">
<img alt="logo" src="../assets/notebook_imgs/general/etsit.png"/>
</a>
    Laboratorio de Sistemas Digitales II
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../index.html">
<span class="md-ellipsis">
    Portada
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--section md-nav__item--nested">
<input class="md-nav__toggle md-toggle md-toggle--indeterminate" id="__nav_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
<span class="md-ellipsis">
    Introducción general
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_2_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
            Introducción general
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="intro.html">
<span class="md-ellipsis">
    Introducción a SDG2
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="sesion_introduccion.html">
<span class="md-ellipsis">
    Sesión de introducción
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
<span class="md-ellipsis">
    Proyecto
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="true" aria-labelledby="__nav_3_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
            Proyecto
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
<span class="md-ellipsis">
    Versión 0
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="version_0.html">
<span class="md-ellipsis">
    Versión 0
    
  </span>
</a>
<nav aria-label="Tabla de contenidos" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#version-0-simone">
<span class="md-ellipsis">
      Versión 0: Simone
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#funciones-de-inicializacion-del-sistema">
<span class="md-ellipsis">
      Funciones de inicialización del sistema
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#referencia-temporal-del-sistema-systick">
<span class="md-ellipsis">
      Referencia temporal del sistema: SysTick
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:sys_gpio">
<span class="md-ellipsis">
      Configuración y manejo de GPIOs
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_1.html">
<span class="md-ellipsis">
    Versión 1
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_2.html">
<span class="md-ellipsis">
    Versión 2
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_3.html">
<span class="md-ellipsis">
    Versión 3
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_4.html">
<span class="md-ellipsis">
    Versión 4
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_5.html">
<span class="md-ellipsis">
    Versión 5
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--section md-nav__item--nested">
<input class="md-nav__toggle md-toggle md-toggle--indeterminate" id="__nav_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="">
<span class="md-ellipsis">
    API
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_4_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
            API
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../api/index.html">
<span class="md-ellipsis">
    Documentación API
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--section md-nav__item--nested">
<input class="md-nav__toggle md-toggle md-toggle--indeterminate" id="__nav_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="">
<span class="md-ellipsis">
    Apéndices
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_5_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
            Apéndices
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="bom.html">
<span class="md-ellipsis">
    BOM
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--section md-nav__item--nested">
<input class="md-nav__toggle md-toggle md-toggle--indeterminate" id="__nav_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="">
<span class="md-ellipsis">
    Acrónimos
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_6_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
            Acrónimos
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="acronimos.html">
<span class="md-ellipsis">
    Acrónimos
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Tabla de contenidos" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#version-0-simone">
<span class="md-ellipsis">
      Versión 0: Simone
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#funciones-de-inicializacion-del-sistema">
<span class="md-ellipsis">
      Funciones de inicialización del sistema
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#referencia-temporal-del-sistema-systick">
<span class="md-ellipsis">
      Referencia temporal del sistema: SysTick
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:sys_gpio">
<span class="md-ellipsis">
      Configuración y manejo de GPIOs
    </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1 id="cha:peoyecto_base"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.</span> Versión 0 y funciones de sistema<a class="headerlink" href="#cha:peoyecto_base" title="Permanent link">¶</a></h1>
<p>Antes de arrancar con la versión <code>V1</code> del sistema, tenemos que manejarnos con el versión 0. En esta configuración inicial vamos a programar una serie de funciones genéricas que se usarán a lo largo de todo el proyecto. Esta parte, junto con la versión <a href="../version_1"><code>V1</code></a> tiene un desarrollo estimado en unas 2-3 semanas. El inicio del proyecto tiene una curva de aprendizaje mayor; por eso, se te va a guiar en los pasos y la explicación será más extensa. Al acabar este capítulo tendrás listas algunas de las funciones base del proyecto <em>Simone</em>.</p>
<p>Debes tener a mano en todo momento <strong>los documentos referenciados y ver los vídeos sugeridos</strong> a fin de entender mejor cómo tiene que escribir el código o realizar montajes.</p>
<div class="admonition example">
<p class="admonition-title">Bibliografía</p>
<ol>
<li>
<p><em>Fundamentos teóricos de sistemas basados en microcontrolador STM32</em> <sup id="fnref6:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">4</a></sup></p>
</li>
<li>
<p><em>Datasheet “STM32F446xC/E”</em> <sup id="fnref:st2021datasheet"><a class="footnote-ref" href="#fn:st2021datasheet">5</a></sup></p>
</li>
<li>
<p><em>Reference manual “RM0390. STM32F446xx advanced Arm-based 32-bit MCUs’</em> <sup id="fnref:st2021reference"><a class="footnote-ref" href="#fn:st2021reference">6</a></sup></p>
</li>
<li>
<p><em>SISTEMAS DIGITALES I: Práctica de programación en C</em></p>
</li>
</ol>
</div>
<div class="admonition info">
<p class="admonition-title"><a href="https://www.youtube.com/channel/UCYIw_gl745WMJ1n0MamDzQw/">Vídeos del canal de SDGII</a></p>
<ul>
<li>
<p><a href="https://youtu.be/CcbgLVfCXrw?si=75H_FF_3tDnzOcMb">[MatrixMCU - examples] Blink LED y manejo de proyecto</a></p>
</li>
<li>
<p><a href="https://youtu.be/VC7fExJJQSY?si=YIY22n5yiqzfZuQd">[MatrixMCU] Documentación de código con Doxygen</a></p>
</li>
</ul>
</div>
<h2 id="version-0-simone"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.1</span> Versión 0: Simone<a class="headerlink" href="#version-0-simone" title="Permanent link">¶</a></h2>
<p>En esta sección se muestra el esquema general del sistema, y se presenta cómo has de configurar el proyecto en <em>VSCode</em>.</p>
<figure><img alt="Diagrama de elementos del sistema." id="fig:proyecto_base_dia" src="../assets/notebook_imgs/pr_chapters/version_0/diagram.svg" style="width:100.0%"><figcaption aria-hidden="true">Diagrama de elementos del sistema.</figcaption></img></figure>
<p>Nuestro sistema base versiona el clásico juego de los 80's, Simon. Cuando se presiona el botón de usuario (el <span style="color: Blue"><strong>azul</strong></span>) durante un tiempo indica que se quiere encender, o apagar, el juego. En ese instante el sistema central encenderá el <em>RGB light</em> (<a href="acronimos.html#acro:LED"><strong>LED</strong></a> <span style="color: red; font-weight: bold;">R</span><span style="color: green; font-weight: bold;">G</span><span style="color: blue; font-weight: bold;">B</span>) con la primera secuencia del juego en en nivel fácil (<code>LEVEL_EASY</code>). Cuando acaba de reproducirse (<em>playback</em>) la secuencia, se activa la excitación de las filas del teclado matricial (4x4) de forma iterativa, y se duerme para esperar una interrupción en alguna de las columnas. Cuando se detecta una pulsación, se comprueba si es la correcta. Si lo es, se vuelve a reproducir la secuencia con un nuevo paso añadido. Si no lo es, se enciende el <em>RGB light</em> en rojo para indicar el fallo, y se vuelve a empezar desde el principio. Si se pulsa el botón de usuario durante un tiempo largo, el sistema se apaga. Ve el video demostrativo en <a href="#TO-DO"><strong>Demostración del sistema Simone</strong></a>. La <a href="#fig:proyecto_base_dia">figura del diagrama</a> muestra los 4 bloques que conforman el sistema:</p>
<ol>
<li>
<p><strong>El sistema central con la placa <span style="color: RoyalBlue; font-weight: bold;">Nucleo-STM32</span></strong> aloja el microcontrolador <span style="color: RoyalBlue; font-weight: bold;">STM32F446RE</span>. Se encarga de gestionar, el encendido y apagado del sistema <em>Simone</em>, de interpretar las pulsaciones del usuario.</p>
</li>
<li>
<p>La placa <span style="color: RoyalBlue; font-weight: bold;">Nucleo-STM32</span> también tiene el botón de usuario <code>B1</code>, y el <a href="acronimos.html#acro:LED"><strong>LED</strong></a> de usuario <code>LD2</code>. Estos conforman <strong>el sub-sistema de control básico</strong>. El botón se usará para detectar pulsaciones que el sistema central interpretará para cambiar encender/ apagar, u otras implementaciones que el quieras hacer en <a href="../version_5">Versión 5</a>. El LED de la placa podrá usarse para saber si hemos realizado correctamente una operación, a modo de <em>feedback</em>.</p>
</li>
<li>
<p><strong>El teclado matricial</strong>. Representa a un dispositivo HW que permite al usuario interactuar con el sistema. En este caso, el teclado matricial es de <span class="arithmatex">\(4\times4\)</span> teclas, y se usará para que el usuario introduzca la secuencia que el sistema le va indicando. Se trata de un <strong>teclado matricial de membrana</strong> en el que se excitan las filas y se irán leyendo las columnas para identificar qué tecla se ha pulsado.</p>
</li>
<li>
<p><strong>El módulo de actuación.</strong> El <em>RGB light</em> está compuesto por un LED <span style="color: red; font-weight: bold;">R</span><span style="color: green; font-weight: bold;">G</span><span style="color: blue; font-weight: bold;">B</span> que se encenderá en función de la secuencia que toque reproducir en el juego, y para dar <em>feedback</em> al jugador de la tecla que ha pulsado.</p>
</li>
</ol>
<h3 id="proyecto-simone-en-vscode"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.1.1</span> Proyecto Simone en VSCode<a class="headerlink" href="#proyecto-simone-en-vscode" title="Permanent link">¶</a></h3>
<p>Vamos a ir construyendo el proyecto poco a poco. En esta primera fase/versión V1 construiremos parte del sistema central y el sub-sistema de control de encendido/ apagado. Se proporciona la estructura del proyecto sobre el que: desarrollaremos (i) las funciones básicas del sistema para gestión de las <a href="acronimos.html#acro:GPIO"><strong>GPIO</strong></a>, (ii) la <a href="acronimos.html#acro:FSM"><strong>FSM</strong></a> del botón y para el cambio de encendido/ apagado, (iii) <em>testearemos</em> su funcionamiento y, en todo momento documentaremos el código. Para empezar a trabajar con el proyecto:</p>
<ol>
<li>
<p>Se asume que has hecho la primera sesión de introducción y tienes <strong>ya montada la estructura para programación multiplataforma</strong> con el proyecto <em>project_template</em>.</p>
<p>Si estás trabajando en su ordenador, sigue los pasos para tener el entorno como indica la Guía de instalación <sup id="fnref2:stm322025guiainstalacion"><a class="footnote-ref" href="#fn:stm322025guiainstalacion">7</a></sup>.</p>
</li>
<li>
<p>Si ya tenemos todo configurado es suficiente con <strong>descargar</strong> —o clonar, si vas a trabajar con Git— del repositorio GitHub de la asignatura <strong>el versión 0 <em>Simone</em></strong>: <a href="https://github.com/sdg2DieUpm/simone">https://github.com/sdg2DieUpm/simone</a>, <strong>y dejarlo en la carpeta “projects” de la estructura de directorios MatrixMCU</strong>.</p>
<p>Deberá tener una estructura de directorios como la de la <a href="#fig:project_structure">figura de árbol de directorios</a>:</p>
</li>
</ol>
<figure><img alt="Árbol de directorios tras descargar el proyecto Simone." id="fig:project_structure" src="../assets/notebook_imgs/pr_chapters/version_0/project_tree.png" style="width:70.0%"><figcaption aria-hidden="true">Árbol de directorios tras descargar el proyecto Simone.</figcaption></img></figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Los puestos del laboratorio utilizan Windows 10. A priori no deberı́a haber conflicto con la configuración del proyecto en VSCode entre máquinas. No obstante, <strong>puedes trabajar con tu portátil en el laboratorio si te es más cómodo</strong> que llevar y traer el código cada dı́a. <strong>Sı́ es obligatorio que traigas tu placa Nucleo-STM32 y el HW necesario.</strong></p>
</div>
<ol>
<li>
<p>Abre <code>VSCode</code> y abre el proyecto <code>Simone</code> que está en la carpeta <code>projects</code>. <span style="color: Red"><strong>Es muy importante que solo abras esa carpeta, ¡no toda la carpeta <code>projects</code>!</strong></span>. Tiene que ver en <code>VSCode</code> algo como lo que se muestra en la <a href="#fig:vscode_project">figura del proyecto en VSCode</a>.</p>
</li>
<li>
<p>Conviene que, si no lo has hecho ya, <strong>leas el capítulo <em>“Desarrollando para <span style="color: RoyalBlue; font-weight: bold;">Nucleo-STM32</span>”</em></strong> <sup id="fnref5:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">4</a></sup> y te familiarices con la estructura de proyecto y los conceptos.</p>
</li>
</ol>
<figure><img alt="Proyecto Simone en VSCode." id="fig:vscode_project" src="../assets/notebook_imgs/pr_chapters/version_0/vscode_project.png" style="width:75.0%"/><figcaption aria-hidden="true">Proyecto Simone en VSCode.</figcaption></figure>
<p>Verás que el proyecto ya tiene algunos ficheros de partida. Los ficheros de cabecera (<code>.h</code>) definen nuevos tipos de variable, contienen <code>#define</code>, hacen <code>#include</code> de otros ficheros, y declaran variables. Si abres los ficheros <code>port_system.h</code> (<a href="#fig:port_system_h">ver figura</a>) o <code>stm32f4_system.h</code> verás que son muy verbosos; casi todo son líneas de comentario. La gran mayoría son líneas de comentario interpretables por el generador de documentación Doxygen. Esto se ha hecho así para que puedas desarrollar el código basándote en la <a href="acronimos.html#acro:API"><strong>API</strong></a> disponible en la página de <em>GitHub Pages</em>: <a href="https://sdg2dieupm.github.io/simone/">https://sdg2dieupm.github.io/simone/</a>. <strong>Tendrás que tener esta página siempre a mano</strong><sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>. Solo tiene algunos ficheros con ejemplo de documentación Doxygen; tú tendrás que completar el de cada función que desarrolles fijándote en los <strong><code>TO-DO alumnos</code></strong> de las descripciones de función. Más adelante se te indicará cómo utilizarla.</p>
<p><strong>En la carpeta <code>common</code> verás que hay dos ficheros <code>header.h</code> y <code>source.c</code> que indican que han de ser borrados. Están ahí para que veas cómo se estructura del proyecto completo. Bórralos cuando añadas los ficheros de la Versión V1.</strong></p>
<figure><img alt="Documentación de una función con Doxygen para generar la API." id="fig:port_system_h" src="../assets/notebook_imgs/pr_chapters/version_0/port_system_h.png" style="width:75.0%"/><figcaption aria-hidden="true">Documentación de una función con Doxygen para generar la API.</figcaption></figure>
<p>Podemos empezar ahora con la gestión de las funciones básicas del sistema y las de acceso a las GPIO. En las siguientes secciones vamos a ver (i) un conjunto de funciones genéricas de sistema, (ii) a desarrollar alguna función relacionada con la temporización del sistema, y (iii) funciones de configuración y manejo de las GPIO. <strong>Fíjate que dividimos por puntos enumerados las acciones a realizar. Ten esto en cuenta para llevar un orden y no perderse</strong>.</p>
<h2 id="funciones-de-inicializacion-del-sistema"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.2</span> Funciones de inicialización del sistema<a class="headerlink" href="#funciones-de-inicializacion-del-sistema" title="Permanent link">¶</a></h2>
<p>Como se comenta en el capítulo <em>“Arranque del sistema”</em> del libro de <em>“Fundamentos prácticos”</em> <sup id="fnref:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">4</a></sup>, antes de ir a la función <code>main()</code> el microcontrolador debe realizar el <em>boot</em> del sistema. En dicho capítulo se indica que una de las cosas que hace antes es llamar a la función <code>SystemInit()</code>. Lea dicho capítulo del libro.</p>
<p>Las funciones de inicialización no son evidentes y realizan muchas configuraciones de bajo nivel. Se te proporcionan ya codificadas. Todas se encuentran en el fichero <code>stm32f4_system.c</code>. Estas son:</p>
<ul>
<li>
<p><code>SystemInit()</code>: es llamada directamente por <code>Reset_Handler</code> del fichero <code>startup_stm32f446xx.s</code>. En nuestra implementación, inicializa la <a href="acronimos.html#acro:FPU"><strong>FPU</strong></a> (si se usa), configura la memoria externa (si la hay), re-coloca la tabla de vectores de interrupción (si es que la modificamos). En nuestro caso, ninguna de estas tres configuraciones se da.</p>
</li>
<li>
<p><code>port_system_init()</code>: <span style="color: Red"><strong>IMPORTANTE</strong></span> <strong>esta llamada debemos hacerla nosotros al inicio del programa antes de configurar cualquier periférico. Si no la hacemos, no funcionará nada que tenga que ver con el HW.</strong> Esta función inicializa los periféricos, la memoria <em>flash</em> y llama a la función de configuración del reloj <code>system_clock_config()</code>.</p>
</li>
<li>
<p><code>system_clock_config()</code>: <span style="color: Red"><strong>IMPORTANTE</strong></span> <strong>esta función, por seguridad, no puede ser accedida desde el exterior</strong> por lo que su declaración no está en <code>port_system.h</code>, para que no la pueda encontrar nadie. Esta función inicializa el oscilador interno <code>HSI</code> a <span class="arithmatex">\(16 MHz\)</span> (valor puesto en el <code>#define HSI_VALUE</code>). Esta función también gestiona la alimentación y configura <strong>el temporizador de sistema <span style="color: Red"><code>SysTick</code></span> a <span class="arithmatex">\(1 ms\)</span>.</strong></p>
</li>
</ul>
<h2 id="referencia-temporal-del-sistema-systick"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.3</span> Referencia temporal del sistema: SysTick<a class="headerlink" href="#referencia-temporal-del-sistema-systick" title="Permanent link">¶</a></h2>
<p>En esta sección vamos a hablar de las funciones:</p>
<ul>
<li>
<p><a href="#par:system_delay_ms"><code>port_system_delay_ms()</code></a></p>
</li>
<li>
<p><a href="#par:system_delay_until"><code>port_system_delay_until_ms()</code></a></p>
</li>
<li>
<p><a href="#par:system_get_millis"><code>port_system_get_millis()</code></a></p>
</li>
<li>
<p><a href="#par:system_set_millis"><code>port_system_set_millis()</code></a></p>
</li>
</ul>
<p>Y de la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> del temporizador del sistema o <span style="color: Red"><code>SysTick</code></span>:</p>
<ul>
<li><a href="#par:systick_handler"><code>SysTick_Handler()</code></a></li>
</ul>
<p>El <span style="color: Red"><code>SysTick</code></span> es el temporizador de referencia del sistema. Como se ha mencionado, <strong>está ya configurado para que genere una interrupción interna cada <span class="arithmatex">\(1 ms\)</span></strong>. Nosotros debemos decidir qué hacer cada vez que se genere dicha interrupción. En nuestro caso queremos tener <strong>una variable que lleve la cuenta de las veces que se ha interrumpido cada <span class="arithmatex">\(1 ms\)</span></strong>. Es lo que vamos a ver en esta sección.</p>
<p>Conforme está el proyecto <em>Simone</em> descargado, si lo compilamos, no te dará errores, pero no funciona. Posteriormente, completaremos algunos detalles que faltan, aunque intercalaremos con la explicación del código en este capítulo.</p>
<ol>
<li>
<p>Compila el código. Lo podemos hacer de varias maneras. Típicamente, lo haremos en depuración, <strong>con la placa conectada</strong>, pero por ahora, podemos construir los binarios sin necesidad de la placa. En este orden:</p>
<ol>
<li>
<p><strong>Primero generamos las reglas de compilación</strong> con <code>CMake</code>: Menú <code>Terminal→ Run Task... → Run CMake → stm32f446re (Default) → Release (Default)</code></p>
<p>Esto generará las carpetas <code>build/Release/</code> con todas las reglas de compilación.</p>
<p><span style="color: Red"><strong>Si no vas a trabajar en modo depuración, es necesario que generes las reglas de compilación en modo <code>Release</code> cada vez que añadas un fichero al proyecto</strong>. Si trabajas en modo depuración, no es necesario, se hace automáticamente tras el Clean.</span></p>
</li>
<li>
<p><strong>Seguidamente, compilamos el código</strong>: Menú <code>Terminal→ Run Task... → Build → stm32f446re (Default) → Release (Default) → main</code></p>
</li>
</ol>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>El modo <code>Release</code> se usa cuando queremos generar los ficheros binarios que se ejecutarán en el dispositivo, pero no queremos depurar. Se usa típicamente cuando no tenemos la placa o cuando se genera el código final de un proyecto que pasa a producción. </p>
<p>El modo <code>Debug</code> se usa cuando queremos depurar el código, y necesitamos tener el dispositivo conectado. En este caso, el compilador añade información extra al código para que el depurador pueda seguir el código línea a línea. Esto hace que el código sea más lento y ocupe más memoria. En el modo <code>Release</code> no se añade esta información extra. Normalmente trabajarás en modo <code>Debug</code>.</p>
</div>
<p>En el fichero <code>stm32f4_system.c</code>, tenemos la variable global <code>msTicks</code>. <strong><code>msTicks</code> es una variable muy importante que hemos definido para llevar la cuenta (ticks) en milisegundos del sistema, y está controlado por <span style="color: Red"><code>SysTick</code></span></strong> (ver capítulo de <em>“Circuito de reloj”</em> del libro de Fundamentos Teóricos <sup id="fnref2:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">4</a></sup>). El valor guardado en <code>msTicks</code> se actualiza cada vez que el reloj de sistema <span style="color: Red"><code>SysTick</code></span> genera una <strong>interrupción</strong>. Puesto que las interrupciones podemos deshabilitarlas —como en los modos de bajo consumo—, <strong>el valor almacenado NO será un valor absoluto desde que se inició el sistema, sino un valor que podremos tener en cuenta de forma relativa para contar lapsos de tiempo.</strong> Trabajaremos con esta variable en las siguientes secciones.</p>
<h3 id="par:system_delay_ms"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.3.1</span> Función <code>port_system_delay_ms</code><a class="headerlink" href="#par:system_delay_ms" title="Permanent link">¶</a></h3>
<p>La función <code>port_system_delay_ms</code> nos podría ser de ayuda en algún momento. Como dice la API, esta función hace una espera activa durante <code>ms</code> milisegundos, <em>i.e.</em>, el programa se bloquea en el <code>while<span class="arithmatex">\(\{\}\)</span></code> que no hace nada durante un tiempo dado. Esta función, para saber cuántos milisegundos han pasado, necesita hacer la resta entre el instante actual y la referencia que coge al inicio <code>tickstart</code>.</p>
<p>¿Cómo sabemos cuál es el instante actual? Pues con el valor de la variable global <code>msTicks</code>. Esta variable es global y estática (<code>static uint32_t msTicks</code>), por lo que es accesible por todas las funciones de este fichero solo<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>. Esta "librería" de sistema <code>stm32f4_system.c</code> ha de proporcionar al resto del código diversas funcionalidades, y una de ellas es la de dar información del tiempo de sistema <code>msTicks</code>. Para ello —y puesto que la variable no es accesible desde el exterior por ser estática—, nos proporciona la función <code>port_system_get_millis()</code>.</p>
<h3 id="par:system_delay_until"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.3.2</span> Función <code>port_system_delay_until_ms</code><a class="headerlink" href="#par:system_delay_until" title="Permanent link">¶</a></h3>
<p>La función <code>port_system_delay_until_ms()</code> recibe la referencia del tiempo actual y hace una espera activa hasta <code>ms</code> después. Nos puede ser también de utilidad durante el proyecto. Esta función toma la referencia de tiempos llamando a <code>port_system_get_millis()</code>.</p>
<h3 id="par:system_get_millis"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.3.3</span> Función <code>port_system_get_millis</code><a class="headerlink" href="#par:system_get_millis" title="Permanent link">¶</a></h3>
<p>La función <code>port_system_get_millis()</code> está declarada en <code>port_system.h</code> y, aunque está implementada, no hace nada. Según la API, dicha función simplemente devuelve la cuenta del sistema en milisegundos. Sabemos que ha de devolver un entero de 32 bits sin signo (<code>uint32_t</code>), es decir, tenemos que devolver el valor de la variable <code>msTicks</code>. Así pues, modifique la función para que quede como:</p>
<div class="highlight"><pre><span></span><code><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">port_system_get_millis</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">msTicks</span><span class="p">;</span><span class="w"> </span><span class="cm">/* ms */</span>
<span class="p">}</span><span class="w">    </span>
</code></pre></div>
<p>y como ya está documentada la función en el <code>.h</code>, no tenemos que poner la documentación Doxygen aquí.</p>
<h3 id="par:system_set_millis"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.3.4</span> Función <code>port_system_set_millis</code><a class="headerlink" href="#par:system_set_millis" title="Permanent link">¶</a></h3>
<p>En casi todos los lenguajes de programación, cuando una librería nos proporcione una función <em>get</em> que devuelve un parámetro encontraremos, típicamente, un <em>set</em>, para poder modificar dicho parámetro. Así pues, encontramos la función <code>port_system_set_millis()</code>.</p>
<p>Esta función también está declarada en <code>port_system.h</code> e implementada, pero sin desarrollar. Según la API, dicha función simplemente recibe la cuenta del sistema en milisegundos que queremos poner. ¿Por qué íbamos a querer modificar la cuenta de tiempos del sistema? Bueno, nuestra aplicación podría tener algún criterio relacionado con ello, pero esta función existe porque es la que la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> usa para modificar el contador <code>msTicks</code>. Ya que la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> está en otro fichero (el fichero <code>interr.c</code>) y no tiene acceso al contador, ha de hacerlo llamado a una función de <code>stm32f4_system.c</code> que sí pueda acceder; esta es nuestra función <code>port_system_set_millis()</code>.</p>
<p>Vamos a completarla:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">port_system_set_millis</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">msTicks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ms</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>En este punto te habrás dado cuenta que hay funciones que empiezan por "<code>port_system_</code>”. Esto es una convención de nomenclatura, un estilo. Si seguimos un criterio, nos puede ser fácil identificar de dónde vienen las funciones y qué hacen solo con su nombre. Estas en particular, nos indican que las funciones son "portables" (<code>port_</code>) —por lo que estarán en el directorio <code>port</code>, y no en el <code>common</code>—, y que son funciones centrales del sistema (<code>system</code>, por abreviar). </p>
<p>Como reciben y/ o devuelven variables estándar (<code>uint32_t</code>, <code>void</code>, …), no tienen nada que ver con el microcontrolador en particular, están en declaradas en los ficheros <code>.h</code> de <code>port/include</code>, pero su implementación está en <code>stm32f4_system.c</code> en <code>stm32f4/src</code>. Si tuviésemos otro microcontrolador, podríamos reutilizar estas funciones sin modificar el prototipo y solo cambiando la implementación. </p>
<p>Se seguirá un cierto estilo a la hora de programar. Se recomienda ojear el libro de estilo “Embedded C Coding Standard” <sup id="fnref:barr2009embedded"><a class="footnote-ref" href="#fn:barr2009embedded">8</a></sup>. El libro es distribuido gratuitamente por los autores en <a href="https://barrgroup.com/sites/default/files/barr_c_coding_standard_2018.pdf">https://barrgroup.com/sites/default/files/barr_c_coding_standard_2018.pdf</a>. <em>Accedido: 2026-01-18.</em></p>
</div>
<h3 id="par:systick_handler"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.3.5</span> Función <code>SysTick_Handler</code><a class="headerlink" href="#par:systick_handler" title="Permanent link">¶</a></h3>
<p><code>msTicks</code> está definida y se usa cuando se llama a las funciones <code>port_system_set_millis()</code> para darle un valor, y <code>port_system_get_millis()</code> para leerlo, pero ¿quién llama a estas funciones para actualizar el valor de <code>msTicks</code>? Bueno, estrictamente nadie las llama, saltan ahí por hardware, pues es la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> del <span style="color: Red"><code>SysTick</code></span>. Vamos a ver cómo funciona y a completarla.</p>
<p>En el documento <code>interr.c</code> encontrarás la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> del <span style="color: Red"><code>SysTick</code></span>, <code>SysTick_Handler</code>. Recuerda que este nombre no lo elegimos nosotros, sino que está definido en el fichero de ensamblador de cada dispositivo; <code>startup_stm32f446xx.s</code> para el microcontrolador <span style="color: RoyalBlue; font-weight: bold;">STM32F446RE</span>. Dentro de la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> vamos a usar las funciones <code>port_system_get_millis()</code> y <code>port_system_set_millis()</code> para leer y escribir el valor de <code>msTicks</code>.</p>
<ol>
<li>
<p>Llama a la función <code>port_system_get_millis()</code> en la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> <code>SysTick_Handler()</code> para leer el valor actual de <code>msTicks</code> y guárdalo en una variable local. <strong>No olvides declarar la variable</strong>.</p>
</li>
<li>
<p>Llama a la función <code>port_system_set_millis()</code> en la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> <code>SysTick_Handler()</code> para escribir el valor de <code>msTicks</code> con <strong>el valor anterior incrementado en 1</strong>.</p>
</li>
</ol>
<p>Ya tenemos hecho el punto <code>1</code> de la <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> <code>SysTick_Handler()</code> (ver <a href="#fig:systick_api">figura de la API</a>), y que estaba pendiente de hacer (<strong><code>TO-DO alumnos</code></strong>).</p>
<figure><img alt="Vista de la API para la ISR &lt;code&gt;SysTick_Handler&lt;/code&gt;." id="fig:systick_api" src="../assets/notebook_imgs/pr_chapters/version_0/systick_api.png" style="width:100.0%"/><figcaption aria-hidden="true">Vista de la API para la ISR <code>SysTick_Handler</code>.</figcaption></figure>
<p>Podemos comprobar que <strong>el programa sigue compilando correctamente</strong> y viendo que se ha generado el fichero ejecutable <code>.elf</code> en la carpeta <code>bin</code>, donde se guardan los binarios generados a ejecutar por el microcontrolador. Tendremos un mensaje en la terminal similar al que se muestra en la <a href="#fig:compile_ok">figura de compilación</a>.</p>
<figure><img alt="Compilación exitosa generando el ejecutable &lt;code&gt;.elf&lt;/code&gt;." id="fig:compile_ok" src="../assets/notebook_imgs/pr_chapters/version_0/compile_ok.png" style="width:80.0%"/><figcaption aria-hidden="true">Compilación exitosa generando el ejecutable <code>.elf</code>.</figcaption></figure>
<h2 id="sec:sys_gpio"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4</span> Configuración y manejo de GPIOs<a class="headerlink" href="#sec:sys_gpio" title="Permanent link">¶</a></h2>
<p>En esta sección vamos a comprender el código de las funciones de configuración y manejo de las GPIOs y a completar algunas de ellas. Con estas funciones conseguiremos inicializar el modo (<em>i.e.</em>, entrada, salida, o alternativo) de cada pin de la GPIO, configurar interrupciones, y leer y escribir en los puertos.</p>
<p><strong>Es muy importante que tengas a mano el capítulo </strong>“Configuración de GPIOs”<strong> del libro de <em>“Fundamentos teóricos”</em></strong> <sup id="fnref3:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">4</a></sup>. En esta sección vamos a trabajar con registros. Todo lo que vamos a ver es un repaso de lo que tiene ya en los ejemplos del libro, pero debes asegurarte de entender lo que hace y saber leer las tablas que en él se muestran. No se te va a pedir manejar el <em>reference manual</em> ni el <em>datasheet</em> del microcontrolador, aunque también puedes mirar en ellos si quieres más detalle sobre los registros.</p>
<p>A lo largo del proyecto vamos a configurar <strong>varias GPIOs, como las del botón, el teclado, o los LED</strong>. Así, para no hacer el código repetitivo, se proporcionan funciones genéricas que reciben como entrada, al menos, el puerto y el pin que quieren configurar. Para ver las funciones sitúate en el fichero <code>stm32f4_system.c</code>, bajo el comentario <code>// GPIO RELATED FUNCTIONS</code>. La lista de funciones que se proporcionan y que vamos a ver es:</p>
<ul>
<li>
<p><a href="#par:gpio_config"><code>stm32f4_system_gpio_config()</code></a></p>
</li>
<li>
<p><a href="#par:gpio_config_alternate"><code>stm32f4_system_gpio_config_alternate()</code></a></p>
</li>
<li>
<p><a href="#par:gpio_config_exti"><code>stm32f4_system_gpio_config_exti()</code></a></p>
</li>
<li>
<p><a href="#par:gpio_config_exti_enable"><code>stm32f4_system_gpio_config_exti_enable()</code></a></p>
</li>
<li>
<p><a href="#par:gpio_config_exti_disable"><code>stm32f4_system_gpio_config_exti_disable()</code></a></p>
</li>
</ul>
<p>Además, por otro lado <strong>vas a tener que implementar</strong> las funciones de lectura, escritura y toggle de las GPIOs**. Son:</p>
<ul>
<li>
<p><a href="#par:gpio_read"><code>stm32f4_system_gpio_read()</code></a></p>
</li>
<li>
<p><a href="#par:gpio_write"><code>stm32f4_system_gpio_write()</code></a></p>
</li>
<li>
<p><a href="#par:gpio_toggle"><code>stm32f4_system_gpio_toggle()</code></a></p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>¿Por qué las funciones ahora se llaman <code>stm32f4_system_gpio_...</code> y no <code>port_system_gpio_...</code>? Porque estas funciones reciben y devuelven tipos de datos (estructuras, punteros, …) que son específicas del microcontrolador <span style="color: RoyalBlue; font-weight: bold;">STM32F446RE</span>, y no son portables a otros microcontroladores. Por eso, están declaradas en el fichero <code>stm32f4/include/stm32f4_system.h</code> y no en <code>port/include/port_system.h</code>. Si tuviésemos otro microcontrolador, tendríamos que incluirla en su carpeta correspondiente y adaptar el prototipo de la función.</p>
</div>
<h3 id="par:gpio_config"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4.1</span> Función <code>stm32f4_system_gpio_config</code><a class="headerlink" href="#par:gpio_config" title="Permanent link">¶</a></h3>
<p>Esta función configura el modo de la GPIO: <strong>entrada, salida o función alternativa</strong>, y el tipo de conexión a la que está el pin (conectada a resistencias de <em>pull-up</em>, o de <em>pull-down</em>). Sirva este primer punto para establecer las bases de cómo se codifican las funciones. Tengamos a mano la entrada de la API. La <a href="#fig:gpio_api">figura</a> muestra la descripción de la anatomía de una entrada de la API.</p>
<figure><img alt="Vista de la API para la función &lt;code&gt;stm32f4_system_gpio_config&lt;/code&gt;." id="fig:gpio_api" src="../assets/notebook_imgs/pr_chapters/version_0/api_gpio_config.png" style="width:85.0%"/><figcaption aria-hidden="true">Vista de la API para la función <code>stm32f4_system_gpio_config</code>.</figcaption></figure>
<p>Como dice el punto <code>1</code> de la API, lo primero que se hace es habilitar el reloj de las GPIO. Esto se indica en los ejemplos del capítulo <strong>“Configuración de GPIOs”</strong> del libro como:</p>
<div class="highlight"><pre><span></span><code><span class="n">RCC</span><span class="o">-&gt;</span><span class="n">AHB1ENR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">RCC_AHB1ENR_GPIOAEN</span><span class="p">;</span><span class="w"> </span><span class="cm">/* GPIOA clock enable */</span>
</code></pre></div>
<p>Esta línea de código activa el bit <code>RCC_AHB1ENR_GPIOAEN</code> (GPIOA) del registro <code>RCC_AHB1ENR</code>. Vamos por partes:</p>
<ul>
<li>
<p>El <a href="acronimos.html#acro:RCC"><strong>RCC</strong></a> es el controlador de relojes. En el fichero <code>stm32f4xx.h</code><sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup>, <a href="acronimos.html#acro:CMSIS"><strong>CMSIS</strong></a> lo define como un puntero a una estructura de tipo <code>RCC_TypeDef</code>: <img alt="image" class="inline-img" src="../assets/notebook_imgs/pr_chapters/version_0/rcc_define.png"/>. Esta estructura también la define <a href="acronimos.html#acro:CMSIS"><strong>CMSIS</strong></a> en el mismo fichero. Tiene muchos campos. Cada campo es un registro del controlador. Bien, pues uno de esos registros es el <code>RCC_AHB1ENR</code>.</p>
</li>
<li>
<p>Recuerda de los <a href="https://youtu.be/X33jHui_l0k">vídeos de SDG1</a> que para acceder a los campos de una estructura tenemos el punto (<code>.</code>), y la flecha (<code>-&gt;</code>). Usamos punto (<code>.</code>) cuando tenemos acceso directo a la estructura, y usamos flecha (<code>-&gt;</code>) cuando lo que tenemos es un acceso indirecto, un puntero. Esta es nuestra situación, porque <code>RCC</code> está definido como puntero, y por eso, para acceder al campo que representa al registro hacemos: <code>RCC-&gt;AHB1ENR</code>.</p>
<p><strong>Aplica toda esta lógica para cualquier registro. Todos están definidos por <a href="acronimos.html#acro:CMSIS">CMSIS</a> en el fichero <code>stm32f4xx.h</code>, y todos son punteros, por lo que siempre accederemos a los registros de los periféricos con <code>-&gt;</code> (flecha).</strong></p>
</li>
<li>
<p><strong>El fabricante nos indica en el manual de referencia que el acceso a los registros se hace, generalmente, de 32 en 32 bits por lo que no se pueden seleccionar bits particulares de un registro</strong> —como indica el libro en un ejemplo—, por eso usamos <strong>máscaras</strong>, en este caso con el operador <code>|</code> (<code>OR</code>) sobre todo el registro para activar el/los bit/s deseado/s.</p>
</li>
<li>
<p>El <code>RCC_AHB1ENR_GPIOAEN</code> es una máscara que está definida en <code>stm32f4xx.h</code>, y vale <code>0x01</code>. Gran parte de los bits de los registros, si no todos, están definidos en este fichero. Para cualquier registro, tú puedes decidir usarlos, o definirte tus propias máscaras si te es más cómodo.</p>
</li>
</ul>
<p>Ya estamos preparados para ver qué hacen las funciones. Conviene que prestes atención al código y a las explicaciones aquí dadas, pues te ayudará en las próximas versiones del proyecto. De igual modo, no dejes de leer el capítulo <strong>“Configuración de GPIOs”</strong> del libro de <em>“Fundamentos teóricos”</em> <sup id="fnref4:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">4</a></sup>, ni de ver el vídeo <a href="https://youtu.be/CcbgLVfCXrw?si=75H_FF_3tDnzOcMb">[MatrixMCU - examples] Blink LED y manejo de proyecto</a>.</p>
<ol>
<li>
<p>En el fichero <code>stm32f4_system.h</code> encontramos el prototipo de la función. En el fichero <code>stm32f4_system.c</code> encontramos su implementación.</p>
</li>
<li>
<p>Dentro de la función vemos que el código activa el bit <code>RCC_AHB1ENR_GPIOAEN</code>, <code>RCC_AHB1ENR_GPIOBEN</code>, o <code>RCC_AHB1ENR_GPIOCEN</code>, en función de si el valor de <code>port</code> es <code>GPIOA</code>, <code>GPIOB</code>, o <code>GPIOC</code>, respectivamente. Esto completa el primer punto de la API.</p>
<p>El <em>pinout</em> de Arduino no da acceso a ningún pin que no sea de estos tres puertos. El <em>pinout</em> de Morpho sí da acceso a algunos del <code>GPIOH</code>, y uno del <code>GPIOD</code>. Si en tus implementaciones de la Versión 5 vas a utilizar alguno de estos pines, necesitarás incluirlos en esta función de configuración. Mira la sección <em>“Conectores y zócalos de la placa”</em> para confirmarlo.</p>
</li>
<li>
<p>Se configura el modo del puerto (registro <code>MODER</code>) <strong>como se hace en la sección <em>“GPIO port mode register (GPIOx_ MODER)”</em> del libro</strong>.</p>
<ul>
<li>
<p>Limpia lo que hubiese escrito en las posiciones del registro <code>MODER</code> con la máscara creada.</p>
<p>Se usa la máscara base <code>GPIO_MODER_MODER0</code> definida por <a href="acronimos.html#acro:CMSIS"><strong>CMSIS</strong></a> en el fichero <code>stm32f446xx.h</code>. Esta máscara vale <code>0x03UL</code>, <em>i.e.</em>, <code>0b11</code> en binario, <em>unsigned</em> (<code>U</code>, no tiene signo), <em>long</em> (<code>L</code>, de 32 bits). Es muy útil usar estas máscaras <em>base</em> para limpiar los bits de los registros.</p>
<p><strong>Para limpiar los bits de un registro o variable, se hace una <code>AND</code> (&amp;) con la máscara negada</strong>.</p>
</li>
<li>
<p>Escribe en el registro de modo el valor de la variable <code>mode</code> —que es el argumento recibido y podrá tomar valores <code>STM32F4_GPIO_MODE_IN</code>— <code>STM32F4_GPIO_MODE_OUT</code>, <code>STM32F4_GPIO_MODE_AF</code>, o <code>STM32F4_GPIO_MODE_AN</code>. Estos son los valores que se han definido en el fichero <code>stm32f4_system.h</code>, y que valen <code>0x00</code>, <code>0x01</code>, <code>0x02</code>, y <code>0x03</code>, respectivamente.</p>
<p>Para escribir en las posiciones correctas del registro, se usa el desplazamiento con la variable <code>pin</code>. La variable <code>pin</code> se multiplica por <code>2U</code> para asegurar que el desplazamiento es de 2 en 2 bits.</p>
<p><strong>Para poner a 1 los bits de un registro o variable, se hace una <code>OR</code> (<code>|</code>) con el valor deseado</strong>.</p>
</li>
</ul>
<p>Ya se ha hecho el segundo punto de la API de esta función.</p>
</li>
<li>
<p>De la misma forma, se configura el tipo de conexión <em>pull-up/ down</em> del pin. El código es más genérico que el que se explica <strong>en la sección <em>“GPIO port pull-up/pull-down register (GPIOx_PUPDR)”</em> del libro</strong>. Simplemente, se repite los pasos anteriores pero esta vez sobre el registro <code>PUPDR</code>: crea la máscara, limpia y escribe en el registro.</p>
<p>Ya se ha hecho el último punto de la API de esta función.</p>
</li>
</ol>
<h3 id="par:gpio_config_alternate"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4.2</span> Función <code>stm32f4_system_gpio_config_alternate</code><a class="headerlink" href="#par:gpio_config_alternate" title="Permanent link">¶</a></h3>
<p>Esta función configura el modo de la GPIO como función alternativa. Para ello sigue las indicaciones de la API. A saber, lo que hace es:</p>
<ul>
<li>
<p>Define una máscara base de 4 bits (<code>0x0F</code>) para seleccionar los bits del registro <code>AFR</code> que se van a modificar.</p>
<p>Esta máscara se desplaza <em>4 por el valor de la variable <code>pin</code> </em>módulo<em> 8</em>. 4 es el ancho de cada campo del registro <code>AFR</code>. El <em>módulo 8</em> hace que el valor de <code>pin</code> se mantenga entre 0 y 7, y así, no nos salgamos del ancho del registro, que tiene 32 bits.</p>
</li>
<li>
<p>Se limpian los bits del registro <code>AFR</code> con la máscara creada.</p>
<p>Se selecciona el registro <code>AFRL</code> (<em>low</em>) o <code>AFRH</code> (<em>high</em>) en función de: <em>el valor de la variable <code>pin</code> </em>dividido<em> entre 8</em>. Como <code>pin</code> solo puede tomar valores entre 0 y 15, la división entre 8 nos da 0 o 1. Esto hace que el valor resultante seleccione el registro <code>AFRL</code> o <code>AFRH</code>, respectivamente.</p>
</li>
<li>
<p>Se escribe en el registro <code>AFR</code> el valor de la variable <code>alternate</code>.</p>
</li>
</ul>
<h3 id="par:gpio_config_exti"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4.3</span> Función <code>stm32f4_system_gpio_config_exti</code><a class="headerlink" href="#par:gpio_config_exti" title="Permanent link">¶</a></h3>
<p>Vamos a ver ahora esta función que configura el pin dado para generar interrupciones externas. Lee y ten a mano <strong>el capítulo <em>“Interrupciones”</em> del libro</strong>. El ejemplo te servirá de mucho. Esta función nos servirá para enterarnos cuando pulsemos el botón y realizar alguna acción en nuestro sistema.</p>
<p>Vamos a seguir los cuatro puntos de la API de esta función.</p>
<ol>
<li>
<p>Lo primero que hace es habilitar el controlador de configuración del sistema que, como nos indica la API, sirve para controlar la línea de interrupciones externas hacia las GPIO. Para ello, se activa el bit <code>SYSCFGEN</code> del registro <code>APB2ENR</code> del <a href="acronimos.html#acro:RCC"><strong>RCC</strong></a>. De nuevo, podemos definir nuestra propia máscara para dicho bit mirando el registro, o usar la <code>RCC_APB2ENR_SYSCFGEN</code> de <a href="acronimos.html#acro:CMSIS"><strong>CMSIS</strong></a> que nos indica la API.</p>
</li>
<li>
<p>Lo siguiente que hace es asociar la interrupción externa al puerto. Este código puede hacerse de muchas maneras, unas más eficientes que otras, aunque no nos preocupamos de eso ahora.</p>
<p>Como se indica en el libro, dependiendo del pin y el puerto, tendremos que elegir un registro u otro para realizar la asociación. Como se trata de una función genérica y no sabemos qué valores nos van a llegar, se hace la implementación para cada pin y puerto según sea el valor de la variable <code>pin</code> y <code>port</code>. Así pues:</p>
<ul>
<li>
<p>si el valor de <code>pin</code> está entre <code>0</code> y <code>3</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR1</code> (<code>SYSCFG-&gt;EXTICR[0]</code>),</p>
</li>
<li>
<p>si el valor de <code>pin</code> está entre <code>4</code> y <code>7</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR2</code> (<code>SYSCFG-&gt;EXTICR[1]</code>),</p>
</li>
<li>
<p>si el valor de <code>pin</code> está entre <code>8</code> y <code>11</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR3</code> (<code>SYSCFG-&gt;EXTICR[2]</code>), y</p>
</li>
<li>
<p>si el valor de <code>pin</code> está entre <code>12</code> y <code>15</code>, se trabaja sobre el registro <code>SYSCFG_EXTICR4</code> (<code>SYSCFG-&gt;EXTICR[3]</code>).</p>
</li>
</ul>
<p>Se define una máscara base de 4 bits (<code>0x0F</code>) para seleccionar los bits del registro <code>EXTICRx</code> que se van a modificar.</p>
<p>Esta máscara se desplaza <em>4 por el valor de la variable <code>pin</code> </em>módulo<em> 4</em>. 4 es el ancho de cada campo del registro <code>EXTICRx</code>. El <em>módulo 4</em> hace que el valor de <code>pin</code> se mantenga entre 0 y 3 y, así, no nos salgamos del ancho del registro, del que se usan 16 bits.</p>
<p>Se limpian los bits del registro <code>EXTICRx</code> con la máscara creada.</p>
<p>Se selecciona el registro <code>EXTICR1</code>, <code>EXTICR2</code>, <code>EXTICR3</code>, o <code>EXTICR4</code> en función de <em>el valor de la variable <code>pin</code> </em>dividido<em> entre 4</em>. Como <code>pin</code> solo puede tomar valores entre 0 y 15, la división entre 4 nos da 0, 1, 2 o 3. Esto hace que el valor resultante seleccione el registro <code>EXTICR1</code>, <code>EXTICR2</code>, <code>EXTICR3</code> o <code>EXTICR4</code>, respectivamente.</p>
<p>Se escribe en el registro <code>EXTICRx</code> el valor que corresponda para cada puerto. Si <code>port</code> es <code>GPIOA</code>, escribimos el valor <code>0</code>, si es <code>GPIOB</code>, escribimos el valor <code>1</code>…, como indica la <em>“Figura”</em> del libro.</p>
</li>
<li>
<p>A continuación se selecciona la dirección de disparo de la interrupción: en flanco de subida, de bajada, o ambos.</p>
<ul>
<li>
<p>Se activa el bit del pin correspondiente en el registro <code>RTSR</code> (<em>rising</em>) si el valor de la variable <code>mode</code> es <code>0x01</code>, indicando que la interrupción ha de notificarse cuando ocurra un flanco de subida.</p>
<p>El número del pin, <code>pin</code>, actúa como índice de una máscara de 1 solo bit, para lo que se usa la macro dada <code>BIT_POS_TO_MASK(pin)</code> para actuar sobre los registros.</p>
</li>
<li>
<p>Se hace lo propio con el registro <code>FTSR</code> (<em>falling</em>) si el valor de la variable <code>mode</code> es <code>0x02</code>, indicando que la interrupción ha de notificarse cuando ocurra un flanco de bajada.</p>
</li>
<li>
<p>Si el valor es <code>0x03</code> escribe en ambos registros: subida y bajada.</p>
<p>¿Por qué estos valores? Porque así lo hemos decidido, podrían ser otros cualquiera. ¿Y cómo sabemos que son dichos valores? Porque la API nos dice los valores que podemos darle a la variable <code>mode</code>:</p>
<p><figure><img alt="Distintos valores que podemos darle a la variable \&lt;code&gt;mode\&lt;/code&gt;." src="../assets/notebook_imgs/pr_chapters/version_0/exti_mode.png" style="width:100.0%"/><figcaption aria-hidden="true">Distintos valores que podemos darle a la variable <code>mode</code>.</figcaption></figure></p>
<p>Es un consenso con nosotros mismos. Se ha añadido en <code>stm32f4_system.h</code> un conjunto de <code>#define</code> para estos valores a fin de que el código sea más inteligible y no haya valores <em>“a pincho”</em>. Se usan nombres representativos como:</p>
<ul>
<li>
<p><code>#define STM32F4_TRIGGER_RISING_EDGE</code></p>
</li>
<li>
<p><code>#define STM32F4_TRIGGER_FALLING_EDGE</code></p>
</li>
<li>
<p><code>#define STM32F4_TRIGGER_BOTH_EDGE</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Por último, de nuevo codificado en el valor de <code>mode</code>, se actúa sobre los registros <code>EXTI_EMR</code> o <code>EXTI_IMR</code> activando el bit correspondiente según si el valor de <code>mode</code> es <code>0x04</code> o <code>0x08</code>, respectivamente. También puede darse el caso de que se quieran activar ambos a la vez. No son excluyentes. En este caso, como en el anterior, activaríamos ambos (se puede añadir un tercer <code>#define</code> híbrido, o realizar dos llamadas a la función).</p>
<p>Se añade en <code>stm32f4_system.h</code> un conjunto de <code>#define</code> con nombres representativos como:</p>
<ul>
<li>
<p><code>#define STM32F4_TRIGGER_ENABLE_EVENT_REQ</code></p>
</li>
<li>
<p><code>#define STM32F4_TRIGGER_ENABLE_INTERR_REQ</code></p>
</li>
</ul>
</li>
</ol>
<p>Ya hemos visto cómo está programada la función. Esta ha sido más compleja, pero esperemos que ya vaya cogiendo soltura con los registros.</p>
<h3 id="par:gpio_config_exti_enable"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4.4</span> Función <code>stm32f4_system_gpio_config_exti_enable</code><a class="headerlink" href="#par:gpio_config_exti_enable" title="Permanent link">¶</a></h3>
<p>El objetivo de esta función es <strong>establecer el nivel de prioridad y subprioridad, y a la vez habilitar la interrupción de una línea externa dada</strong>. La llamaremos cuando queramos configurar un pin como entrada y que genere interrupciones. Internamente llama a una macro de <a href="acronimos.html#acro:CMSIS"><strong>CMSIS</strong></a> que controla los registros de interrupción. Estos registros no aparecen en el <em>reference manual</em> porque son del <em>core</em> de Cortex-M4. <span style="color: Red"><strong>Es muy importante habilitar la interrupción o nunca saltará la ISR.</strong></span></p>
<h3 id="par:gpio_config_exti_disable"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4.5</span> Función <code>stm32f4_system_gpio_config_exti_disable</code><a class="headerlink" href="#par:gpio_config_exti_disable" title="Permanent link">¶</a></h3>
<p>El objetivo de esta función es <strong>deshabilitar la interrupción de una línea externa dada</strong>. La usaremos cuando no queramos que nos interrumpa un pin/ línea configurado como entrada y previamente habilitado. <strong>Mientras está desactivada, no saltará la ISR asociada a dicha línea.</strong></p>
<h3 id="par:gpio_read"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4.6</span> Función <code>stm32f4_system_gpio_read</code><a class="headerlink" href="#par:gpio_read" title="Permanent link">¶</a></h3>
<p>Esta función será llamada cuando queramos leer el valor digital de un pin. Leeremos un <code>‘1’</code> o un <code>‘0’</code> lógico, por eso, la función devuelve <code>bool</code>. Vamos a seguir los dos puntos de la API de esta función para que la implementes tú mismo/a.</p>
<ol>
<li>
<p>En <code>stm32f4_system.h</code> declara el prototipo de la función según indica la API. De esta forma la función se hace pública y podrá ser llamada desde cualquier otro fichero.</p>
</li>
<li>
<p>En <code>stm32f4_system.c</code> escribe el prototipo de la función y abre llaves. Vamos a seguir los pasos que se indican en la API.</p>
</li>
<li>
<p>Lee el valor del registro <code>IDR</code> de la GPIO como se muestra en la sección <em>“GPIO port input data register (GPIOx_IDR)”</em> del libro.</p>
<ul>
<li>
<p>El puerto es el <code>port</code> dado.</p>
</li>
<li>
<p>Usa la macro <code>BIT_POS_TO_MASK(pin)</code> para crear la máscara según el pin dado.</p>
</li>
<li>
<p>Tenemos que devolver una variable de tipo <code>bool</code>, por lo que tendremos que hacer un <em>cast</em> del resultado leído del registro, ya que el registro es una variable de 32 bits. Puedes utilizar una variable intermedia para cargar el valor del registro, o hacerlo como en el ejemplo.</p>
<p><strong>Para leer el valor de un bit en un registro hacemos el producto bit a bit (<code>&amp;</code>).</strong></p>
</li>
</ul>
</li>
<li>
<p>Devuelve el valor leído.</p>
</li>
<li>
<p>En <code>stm32f4_system.h</code> documenta la función con <code>Doxygen</code> ayudándose con la API. Recuerda que tienes el vídeo <a href="https://youtu.be/VC7fExJJQSY?si=YIY22n5yiqzfZuQd">"[MatrixMCU] Documentación de código con Doxygen”</a> con las bases para documentar y generar tu propia API.</p>
</li>
</ol>
<p>Ya tenemos la función que nos permite leer valores digitales del exterior dado un puerto y un pin. Comprueba que compila sin errores: Menú <code>Terminal→ Run Task... → Build → stm32f446re (Default) → Release (Default) → main</code>.</p>
<h3 id="par:gpio_write"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4.7</span> Función <code>stm32f4_system_gpio_write</code><a class="headerlink" href="#par:gpio_write" title="Permanent link">¶</a></h3>
<p>A continuación vamos a desarrollar la función que será llamada cuando queramos escribir un valor digital en un pin. Escribiremos <code>‘1’</code> o <code>‘0’</code> lógicos. Vamos a seguir los dos puntos de la API de esta función.</p>
<ol>
<li>
<p>En <code>stm32f4_system.h</code> declara el prototipo de la función según indica la API.</p>
</li>
<li>
<p>En <code>stm32f4_system.c</code> escribe el prototipo de la función y abre llaves.</p>
</li>
<li>
<p>Escribe el valor correspondiente en el registro <code>BSRR</code> de la GPIO como se muestra en la sección <em>“GPIO port bit set/reset register (GPIOx_BSRR)”</em> del libro.</p>
<ul>
<li>
<p>El puerto es el <code>port</code> dado.</p>
</li>
<li>
<p>Si el valor de la variable <code>value</code> es <code>true</code> activamos el bit correspondiente. Puedes usar la macro <code>BIT_POS_TO_MASK(pin)</code> para crear la máscara según el pin dado. <strong>Para evitar posibles condiciones de carrera, utilizamos el registro <code>GPIOx_BSRR</code> y no el <code>GPIOx_ODR</code></strong>.</p>
</li>
<li>
<p>Si el valor de la variable <code>value</code> es <code>false</code> limpiamos el bit correspondiente. Lo limpiamos poniendo a uno el bit correspondiente en el registro <code>GPIOx_BSRR</code>; así funciona este registro .</p>
</li>
</ul>
</li>
<li>
<p>En <code>stm32f4_system.h</code> documenta la función con <code>Doxygen</code> ayudándote con la API.</p>
</li>
</ol>
<p>Ya tenemos la función que nos permite escribir valores digitales dado un puerto y un pin. Comprueba que compila sin errores.</p>
<h3 id="par:gpio_toggle"><span class="enumerate-headings-plugin enumerate-heading-plugin">3.4.8</span> Función <code>stm32f4_system_gpio_toggle</code><a class="headerlink" href="#par:gpio_toggle" title="Permanent link">¶</a></h3>
<p>Esta función es muy cómoda cuando queremos invertir el valor de un pin. Si estaba en alto (<code>‘1’</code> lógico), que pase a bajo (<code>‘0’</code> lógico), y viceversa. Esta función usa las dos anteriores; lee el valor del pin y escribe el opuesto. Seguimos la API.</p>
<ol>
<li>
<p>En <code>stm32f4_system.h</code> declara el prototipo de la función según indica la API.</p>
</li>
<li>
<p>En <code>stm32f4_system.c</code> escribe el prototipo de la función y abre llaves.</p>
</li>
<li>
<p>Lee el valor del pin y el puerto. Puedes servirte de la función anteriormente implementada.</p>
</li>
<li>
<p>Escribe en el pin y el puerto el valor contrario al leído. Puedes servirte de la función anteriormente implementada.</p>
<p>Puedes definir utilizar las macros <code>HIGH</code> y <code>LOW</code> si te resulta más cómodo de interpretar que <code>true</code> y <code>false</code>.</p>
</li>
<li>
<p>En <code>stm32f4_system.h</code> documenta la función con <code>Doxygen</code> ayudándote con la API.</p>
</li>
</ol>
<p>Ya hemos tenemos la función que nos permite alternar el valor de un pin. Comprueba que compila sin errores. <strong>Podrás probar estas funciones junto con el <a href="../version_1#sec:test_port_v1">test unitario del PORT de la versión 1</a></strong>.</p>
<p>También hemos acabado con las funciones básicas del sistema. Estas funciones se usarán en las distintas versiones del proyecto, por eso es tan importante que las hiciésemos lo primero y que las entienda. Además, nos ha servido para calentar en esto de la programación de bajo nivel (<em>baremetal</em>). A continuación seguiremos con la implementación HW del botón y su máquina de estados.</p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:1">
<p>Aunque tú mismo puedes re-generar dicha API localmente como se explica en la guía <sup id="fnref:stm322025guiainstalacion"><a class="footnote-ref" href="#fn:stm322025guiainstalacion">7</a></sup>. <a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:2">
<p>La función <code>port_system_delay_ms()</code> sí podría acceder a la variable <code>msTicks</code> directamente, aunque con llamada a <code>port_system_get_millis()</code> es más ortodoxo y así es como lo harían, inevitablemente, funciones de otros ficheros. <a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:3">
<p>El fichero <code>stm32f4xx.h</code> se encuentra en el árbol de directorios de la <strong><em>toolkit</em> MatrixMCU</strong> en: <em>MatrixMCU/drivers/stm32f4xx/CMSIS/Device/ST/STM32F4xx/Include/stm32f446xx.h</em> <a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:stm322025fundamentos">
<p>Josué Pagán Ortiz. <em>Fundamentos teóricos de sistemas basados en microcontrolador STM32</em>. Universidad Politécnica de Madrid, 2024. <a class="footnote-backref" href="#fnref:stm322025fundamentos" title="Jump back to footnote 4 in the text">↩</a><a class="footnote-backref" href="#fnref2:stm322025fundamentos" title="Jump back to footnote 4 in the text">↩</a><a class="footnote-backref" href="#fnref3:stm322025fundamentos" title="Jump back to footnote 4 in the text">↩</a><a class="footnote-backref" href="#fnref4:stm322025fundamentos" title="Jump back to footnote 4 in the text">↩</a><a class="footnote-backref" href="#fnref5:stm322025fundamentos" title="Jump back to footnote 4 in the text">↩</a><a class="footnote-backref" href="#fnref6:stm322025fundamentos" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn:st2021datasheet">
<p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: <a href="https://www.st.com/resource/en/datasheet/stm32f446re.pdf">https://www.st.com/resource/en/datasheet/stm32f446re.pdf</a>. <a class="footnote-backref" href="#fnref:st2021datasheet" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
<li id="fn:st2021reference">
<p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: <a href="https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf</a>. <a class="footnote-backref" href="#fnref:st2021reference" title="Jump back to footnote 6 in the text">↩</a></p>
</li>
<li id="fn:stm322025guiainstalacion">
<p>Josué Pagán Ortiz, Pedro José Malagón Marzo, Daniel Capellán Martín, Román Cárdenas Rodríguez, and Amadeo de Gracia Herranz. <em>Guía de instalación de herramientas para compilación multiplataforma en C</em>. Universidad Politécnica de Madrid, 2024. <a class="footnote-backref" href="#fnref:stm322025guiainstalacion" title="Jump back to footnote 7 in the text">↩</a><a class="footnote-backref" href="#fnref2:stm322025guiainstalacion" title="Jump back to footnote 7 in the text">↩</a></p>
</li>
<li id="fn:barr2009embedded">
<p>Michael Barr. <em>Embedded C Coding Standard</em>. Netrino, 2009. <a class="footnote-backref" href="#fnref:barr2009embedded" title="Jump back to footnote 8 in the text">↩</a></p>
</li>
</ol>
</div>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
<button class="md-top md-icon" data-md-component="top" hidden="" type="button">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"></path></svg>
  Volver al principio
</button>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "..", "features": ["navigation.sections", "navigation.expand", "navigation.top", "content.code.copy"], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version": "Seleccionar versi\u00f3n"}, "version": null}</script>
<script src="../assets/javascripts/bundle.13a4f30d.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
</body>
</html>