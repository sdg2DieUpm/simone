
<!DOCTYPE html>

<html class="no-js" lang="es">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<link href="https://sdg2dieupm.github.io/simone/notebook/version_2.html" rel="canonical"/>
<link href="version_1.html" rel="prev"/>
<link href="version_3.html" rel="next"/>
<link href="../assets/general/favicon.ico" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.14" name="generator"/>
<title>Versión 2 - Laboratorio de Sistemas Digitales II</title>
<link href="../assets/stylesheets/main.342714a4.min.css" rel="stylesheet"/>
<link href="../assets/stylesheets/palette.06af60db.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
<link href="../stylesheets/notebook-extra.css" rel="stylesheet"/>
<script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
</head>
<body data-md-color-accent="deep_orange" data-md-color-primary="blue_grey" data-md-color-scheme="default" dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#cha:version2">
          Saltar a contenido
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header md-header--shadow" data-md-component="header">
<nav aria-label="Cabecera" class="md-header__inner md-grid">
<a aria-label="Laboratorio de Sistemas Digitales II" class="md-header__button md-logo" data-md-component="logo" href="../index.html" title="Laboratorio de Sistemas Digitales II">
<img alt="logo" src="../assets/notebook_imgs/general/etsit.png"/>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            Laboratorio de Sistemas Digitales II
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Versión 2
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Cambiar a modo oscuro" class="md-option" data-md-color-accent="deep_orange" data-md-color-media="" data-md-color-primary="blue_grey" data-md-color-scheme="default" id="__palette_0" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Cambiar a modo oscuro">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg>
</label>
<input aria-label="Cambiar a modo claro" class="md-option" data-md-color-accent="deep_orange" data-md-color-media="" data-md-color-primary="blue_grey" data-md-color-scheme="slate" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_0" hidden="" title="Cambiar a modo claro">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg>
</label>
</form>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="Búsqueda" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="Búsqueda" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path></svg>
</label>
<nav aria-label="Buscar" class="md-search__options">
<button aria-label="Limpiar" class="md-search__icon md-icon" tabindex="-1" title="Limpiar" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            Inicializando búsqueda
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navegación" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="Laboratorio de Sistemas Digitales II" class="md-nav__button md-logo" data-md-component="logo" href="../index.html" title="Laboratorio de Sistemas Digitales II">
<img alt="logo" src="../assets/notebook_imgs/general/etsit.png"/>
</a>
    Laboratorio de Sistemas Digitales II
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../index.html">
<span class="md-ellipsis">
    Portada
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--section md-nav__item--nested">
<input class="md-nav__toggle md-toggle md-toggle--indeterminate" id="__nav_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
<span class="md-ellipsis">
    Introducción general
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_2_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
            Introducción general
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="intro.html">
<span class="md-ellipsis">
    Introducción a SDG2
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="sesion_introduccion.html">
<span class="md-ellipsis">
    Sesión de introducción
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
<span class="md-ellipsis">
    Proyecto
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="true" aria-labelledby="__nav_3_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
            Proyecto
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="version_0.html">
<span class="md-ellipsis">
    Versión 0
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_1.html">
<span class="md-ellipsis">
    Versión 1
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
<span class="md-ellipsis">
    Versión 2
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="version_2.html">
<span class="md-ellipsis">
    Versión 2
    
  </span>
</a>
<nav aria-label="Tabla de contenidos" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#caracteristicas-del-teclado-matricial-en-version-2">
<span class="md-ellipsis">
      Características del teclado matricial en Versión 2
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:layouts_keyboards">
<span class="md-ellipsis">
      Layouts de teclados matriciales
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:headers_keyboard">
<span class="md-ellipsis">
      PORT: cabeceras de la librería del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:port_keyboard">
<span class="md-ellipsis">
      PORT: fuente de la librería del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:test_port_keyboard">
<span class="md-ellipsis">
      PORT: Test unitario del teclado matricial
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#common-cabecera-de-la-fsm-del-teclado">
<span class="md-ellipsis">
      COMMON: cabecera de la FSM del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:fsm_keyboard">
<span class="md-ellipsis">
      COMMON: fuente de la FSM del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:test_fsm_v2">
<span class="md-ellipsis">
      COMMON Test unitario de la FSM del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ejemplo-de-uso-de-la-version-2">
<span class="md-ellipsis">
      Ejemplo de uso de la Versión 2
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_3.html">
<span class="md-ellipsis">
    Versión 3
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_4.html">
<span class="md-ellipsis">
    Versión 4
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="version_5.html">
<span class="md-ellipsis">
    Versión 5
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--section md-nav__item--nested">
<input class="md-nav__toggle md-toggle md-toggle--indeterminate" id="__nav_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="">
<span class="md-ellipsis">
    API
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_4_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
            API
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../api/index.html">
<span class="md-ellipsis">
    Documentación API
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--section md-nav__item--nested">
<input class="md-nav__toggle md-toggle md-toggle--indeterminate" id="__nav_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="">
<span class="md-ellipsis">
    Apéndices
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_5_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
            Apéndices
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="bom.html">
<span class="md-ellipsis">
    BOM
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--section md-nav__item--nested">
<input class="md-nav__toggle md-toggle md-toggle--indeterminate" id="__nav_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="">
<span class="md-ellipsis">
    Acrónimos
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_6_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
            Acrónimos
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="acronimos.html">
<span class="md-ellipsis">
    Acrónimos
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Tabla de contenidos" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#caracteristicas-del-teclado-matricial-en-version-2">
<span class="md-ellipsis">
      Características del teclado matricial en Versión 2
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:layouts_keyboards">
<span class="md-ellipsis">
      Layouts de teclados matriciales
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:headers_keyboard">
<span class="md-ellipsis">
      PORT: cabeceras de la librería del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:port_keyboard">
<span class="md-ellipsis">
      PORT: fuente de la librería del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:test_port_keyboard">
<span class="md-ellipsis">
      PORT: Test unitario del teclado matricial
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#common-cabecera-de-la-fsm-del-teclado">
<span class="md-ellipsis">
      COMMON: cabecera de la FSM del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:fsm_keyboard">
<span class="md-ellipsis">
      COMMON: fuente de la FSM del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sec:test_fsm_v2">
<span class="md-ellipsis">
      COMMON Test unitario de la FSM del teclado
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ejemplo-de-uso-de-la-version-2">
<span class="md-ellipsis">
      Ejemplo de uso de la Versión 2
    </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1 id="cha:version2"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.</span> Versión 2: teclado matricial<a class="headerlink" href="#cha:version2" title="Permanent link">¶</a></h1>
<p>En la Versión 1 aprendimos a gestionar un único botón mediante interrupciones. Sin embargo, ¿qué ocurre si nuestro sistema necesita 12, 16 o más botones? Si utilizáramos la estrategia anterior, necesitaríamos una línea de interrupción y un pin GPIO por cada botón, agotando rápidamente los recursos del microcontrolador.</p>
<p>Para solucionar esto, utilizamos la técnica del <strong>barrido</strong> o <em>scanning</em> en un teclado matricial. Esta técnica aprovecha la persistencia temporal para leer muchos pulsadores utilizando pocos pines, organizándolos en filas y columnas.</p>
<div class="admonition example">
<p class="admonition-title">Bibliografía</p>
<ol>
<li>
<p><em>“Fundamentos teóricos de sistemas basados en microcontrolador STM32”</em> <sup id="fnref4:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">3</a></sup></p>
</li>
<li>
<p><em>Datasheet “STM32F446xC/E”</em> <sup id="fnref2:st2021datasheet"><a class="footnote-ref" href="#fn:st2021datasheet">4</a></sup></p>
</li>
<li>
<p><em>Reference manual “RM0390. STM32F446xx advanced Arm-based 32-bit MCUs’</em> <sup id="fnref:st2021reference"><a class="footnote-ref" href="#fn:st2021reference">5</a></sup></p>
</li>
</ol>
</div>
<div class="admonition info">
<p class="admonition-title"><a href="https://www.youtube.com/channel/UCYIw_gl745WMJ1n0MamDzQw/">Vídeos del canal de SDGII</a></p>
<ul>
<li>
<p><a href="#TODO">Demostración Simone</a></p>
</li>
<li>
<p><a href="https://youtu.be/CcbgLVfCXrw?si=A8DP1rescxJNBEb9">Blink LED y manejo de proyecto</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/playlist?list=PLTFFovUxjNnn19myGVw1kwh6GPbRxwIcC">Conceptos básicos de C (canal SDG1)</a></p>
</li>
<li>
<p><a href="https://youtu.be/VC7fExJJQSY?si=YIY22n5yiqzfZuQd">[MatrixMCU] Documentación de código con Doxygen</a></p>
</li>
</ul>
</div>
<p>En este capítulo vamos a crear una librería que nos permita gestionar un teclado matricial 4x4 (16 teclas) <a href="#fig:keyboard">como el de la figura</a>. A diferencia del botón, que funcionaba solo teníamos una interrupción, aquí <strong>utilizaremos un temporizador que nos interrumpe para realizar una excitación periódica de las filas y esperaremos interrupciones de las columnas.</strong></p>
<figure><img alt="Teclado matricial de membrana 4x4 usado en el proyecto Simone." id="fig:keyboard" src="../assets/notebook_imgs/pr_chapters/version_2/keyboard.png" style="width:65.0%"><figcaption aria-hidden="true">Teclado matricial de membrana 4x4 usado en el proyecto Simone.</figcaption></img></figure>
<p>Como ya hicimos en las versiones anteriores, (i) vamos a implementar la parte <em>portable</em> <code>PORT</code> dependiente del <strong><a href="acronimos.html#acro:HW">HW</a></strong> para gestionar los niveles lógicos de las filas y la lectura de las columnas, y lo probaremos con un test unitario. (ii) Después, vamos a crear la lógica de la <strong><a href="acronimos.html#acro:FSM">FSM</a></strong> para gestionar el barrido y el <em>anti-rebotes</em> (la parte <code>COMMON</code>), y lo probaremos con un test unitario. (iii) Por último, montaremos el <strong><a href="acronimos.html#acro:HW">HW</a></strong> y probaremos el funcionamiento con un programa de ejemplo.</p>
<p>El teclado matricial es un array de pulsadores conectados en intersecciones de filas y columnas. Cuando no se pulsa ninguna tecla, no hay conexión entre filas y columnas. Al pulsar una tecla, se cortocircuita una fila con una columna específica. Las características a destacar del sistema de la Versión 2 se muestran en la <a href="#tbl:version2_keypad">siguiente tabla</a>.</p>
<div id="tbl:version2_keypad"></div>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>Parámetro</strong></th>
<th style="text-align: center;"><strong>Valor</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Pin fila 1</td>
<td style="text-align: center;"><code>PA0</code></td>
</tr>
<tr>
<td style="text-align: left;">Pin fila 2</td>
<td style="text-align: center;"><code>PA1</code></td>
</tr>
<tr>
<td style="text-align: left;">Pin fila 3</td>
<td style="text-align: center;"><code>PA4</code></td>
</tr>
<tr>
<td style="text-align: left;">Pin fila 4</td>
<td style="text-align: center;"><code>PB0</code></td>
</tr>
<tr>
<td style="text-align: left;">Modo filas</td>
<td style="text-align: center;">Salida</td>
</tr>
<tr>
<td style="text-align: left;">Pull up/ down filas</td>
<td style="text-align: center;">No push, no pull</td>
</tr>
<tr>
<td style="text-align: left;">Timeout de excitación de filas</td>
<td style="text-align: center;"><span class="arithmatex">\(25 ms\)</span></td>
</tr>
<tr>
<td style="text-align: left;">Pin/ EXTI/ ISR columna 1</td>
<td style="text-align: center;"><code>PA8</code>/ <code>EXTI8</code>/ <code>EXTI9_5_IRQHandler</code></td>
</tr>
<tr>
<td style="text-align: left;">Pin/ EXTI/ ISR columna 2</td>
<td style="text-align: center;"><code>PB10</code>/ <code>EXTI10</code>/ <code>EXTI15_10_IRQHandler</code></td>
</tr>
<tr>
<td style="text-align: left;">Pin/ EXTI/ ISR columna 3</td>
<td style="text-align: center;"><code>PB4</code>/ <code>EXTI4</code>/ <code>EXTI4_IRQHandler</code></td>
</tr>
<tr>
<td style="text-align: left;">Pin/ EXTI/ ISR columna 4</td>
<td style="text-align: center;"><code>PB5</code>/ <code>EXTI5</code>/ <code>EXTI9_5_IRQHandler</code></td>
</tr>
<tr>
<td style="text-align: left;">Modo columnas</td>
<td style="text-align: center;">Entrada</td>
</tr>
<tr>
<td style="text-align: left;">Pull up/ down columnas</td>
<td style="text-align: center;">Pull down</td>
</tr>
<tr>
<td style="text-align: left;">Prioridad todas las columnas</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">Subprioridad todas las columnas</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">Tiempo anti-rebotes todas las columnas</td>
<td style="text-align: center;"><span class="arithmatex">\(100-200 ms\)</span></td>
</tr>
</tbody>
</table>
<h2 id="caracteristicas-del-teclado-matricial-en-version-2"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.1</span> Características del teclado matricial en Versión 2<a class="headerlink" href="#caracteristicas-del-teclado-matricial-en-version-2" title="Permanent link">¶</a></h2>
<figure style="text-align:center;"> <div style="display: flex; justify-content: center; align-items: center; gap: 10px;"> <img alt="Circuitería teclado" id="fig:keypad" src="../assets/notebook_imgs/pr_chapters/version_2/keypad.jpeg" style="width:40%;"/> <img alt="Esquema matricial" id="fig:keypad_matrix" src="../assets/notebook_imgs/pr_chapters/version_2/keypad_matrix.png" style="width:50%;"/> </div> <figcaption>(a) Circuio de un teclado matricial de membrana, (b) Esquema de conexiones.</figcaption> </figure>
<p>Si tiene la oportunidad de abrir en casa cualquier sistema que tenga un teclado o botonera<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>, seguramente encuentre una circuitería como la de la <a href="#fig:keypad">figura (a)</a>. La goma gris es la cara interna de los botones, que está sobre la PCB verde. Las almohadillas negras que ve son contactos metálicos que, cuando se pulsa el botón, se cortocircuitan con el metal de la PCB y cierran el circuito<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>.</p>
<p>La idea de colocar los botones así, haciendo una rejilla, es muy inteligente. Haciendo un enrejillado no es necesario tener un cable para cada botón, porque un cable por cada botón implicaría tener un pin de entrada en nuestro microcontrolador por cada uno (si no se usan multiplexores, claro), y los pines no es algo que sobre, generalmente, en los encapsulados de los chips. Por ejemplo, en el <a href="#fig:keypad">reclado de la figura (a)</a> se usan 10 cables para 24 botones (ahorro del <span class="arithmatex">\(58.3\%\)</span> de conexiones/pines), y en el del teclado del laboratorio se usarán 8 conexiones para 16 botones (ahorro del <span class="arithmatex">\(50.0\%\)</span>).</p>
<p>Pero esta idea no sale gratis. A cambio de reducir el hardware necesario, tenemos que complicar el software un poquito. Debemos ir excitando —poniendo tensión— las filas o columnas de forma cíclica para poder detectar qué botón se ha pulsado (lo hacemos leyendo las columnas o filas respectivamente). Si alguna columna detecta esa tensión, sabemos qué tecla exacta (intersección fila-columna) se ha pulsado. Este proceso se repite para todas las filas rápidamente. <strong>En nuestro caso excitaremos filas</strong>. Fíjate que solo podemos tener una fila con tensión a la vez porque, de otro modo, no seríamos capaces de distinguir entre los botones de una misma columna. Si haces un dibujo, lo verás fácilmente.</p>
<p>No te preocupes, la gestión de filas y columnas tiene fácil solución si trabajamos con las máquinas de estado; pues para controlar la excitación de las filas del teclado matricial tendremos la <a href="#fig:fsm_keyboard">FSM del teclado</a>.</p>
<figure><img alt="Ejemplo de excitación de fila R1, pulsando tecla 3, generando interrupción en pin conectado a columna C3." id="fig:keyboard_connections" src="../assets/notebook_imgs/pr_chapters/version_2/keyboard_connections.svg" style="width:100.0%"><figcaption aria-hidden="true">Ejemplo de excitación de fila R1, pulsando tecla 3, generando interrupción en pin conectado a columna C3.</figcaption></img></figure>
<p>La <a href="#fig:keyboard_connections">figura</a> muestra un ejemplo de cómo funcionará el sistema. En este caso, la FSM del teclado está excitando la fila R1 poniendo un nivel lógico alto en el pin correspondiente (cada <span class="arithmatex">\(25 ms\)</span> excita una fila). Cuando se pulsa la tecla '3', se cierra el circuito entre la fila R1 y la columna C3, lo que hace que el pin conectado a C3 detecte un nivel lógico alto (<span class="arithmatex">\(3.3 V\)</span>).</p>
<p><strong>En este circuito vamos a activar las resistencias de pull-down ¡internas! de los pines del microcontrolador conectados a las columnas</strong>, por lo que cuando no se pulsa ninguna tecla, las columnas estarán a nivel lógico bajo (<span class="arithmatex">\(0 V\)</span>). Al pulsar la tecla '3', la columna C3 pasa a nivel lógico alto debido a la conexión con la fila R1 que está excitada. <strong>Pasa lo contrario que con el circuito del botón, que tenía una resistencia de pull-up ¡externa!</strong> Esto genera una interrupción en el microcontrolador, que puede entonces identificar qué tecla se ha pulsado basándose en la fila actualmente excitada y la columna que ha generado la interrupción.</p>
<p>Recuerda que, como hicimos con el botón, <strong>estamos desarrollando una librería.</strong> El teclado matricial no tiene por qué saber nada de las acciones que hace el sistema cuando se pulsa una tecla. Es por eso que en nuestro proyecto, el teclado se encargará solo de guardar la tecla pulsada y de avisar de que ha habido una pulsación. El sistema que use esta librería —sea en este proyecto u otro— deberá comprobar dicho valor guardado con un <em>get</em>. La idea es exactamente la misma que la que implementó en el botón. Así, cada vez que se quiera añadir un teclado, le asociaremos una <strong><a href="acronimos.html#acro:FSM">FSM</a></strong>. Las particularidades de dónde están conectadas las filas y columnas son cosas específicas del HW, por lo que estarán en <code>PORT</code>.</p>
<figure style="text-align:center;"> <div style="display: flex; justify-content: center; align-items: center; gap: 10px;"> <img alt="Estructura HW teclado" id="fig:stm32f4_keyboard_hw_t" src="../assets/notebook_imgs/pr_chapters/version_2/stm32f4_keyboard_hw_t.svg" style="width:50%;"/> <img alt="Estructura FSM teclado" id="fig:fsm_keyboard_t" src="../assets/notebook_imgs/pr_chapters/version_2/fsm_keyboard_t.svg" style="width:50%;"/> </div> <figcaption>(a) Estructura del HW del teeclado en PORT, (b) Estructura de la FSM del teclado en COMMON.</figcaption> </figure>
<p>Las <a href="#stm32f4_keyboard_hw_t">figuras de estructuras HW</a> <a href="#fms_keyboard_t">y SW</a> muestran las estructuras que vamos a necesitar para el teclado. La estructura del HW del teclado en <code>PORT</code>. El <code>PORT</code> de otro microcontrolador podría implementar internamente una estructura diferente, por eso está dentro de la carpeta <code>stm32f4</code>. Por ejemplo, al <em>portar</em> el código para PC no tendría sentido definir la estructura de una GPIO. La estructura de la <a href="acronimos.html#acro:FSM"><strong>FSM</strong></a> del teclado en <code>COMMON</code> se muestra en la <a href="#fsm_keyboard_t">figura de la FSM</a>.</p>
<p>Como en el caso del botón aquí, aunque no hay muelles, puede haber igualmente inestabilidades en la pulsación, <strong>rebotes</strong>, por lo e vamos a implementar, igualmente, un mecanismo antirebotes. Dejaremos unos tiempos de guarda de antirebotes también entre <span class="arithmatex">\(100-200 ms\)</span>.</p>
<p>En el caso del teclado matricial no tenemos circuito preestablecido, por lo que podemos elegir libremente si queremos usar resistencias de <em>pull-up</em> o <em>pull-down</em> en las columnas. <strong>En este caso, usaremos resistencias de <em>pull-down</em> en las columnas y excitaremos las filas poniendo un nivel lógico alto. Así, cuando se pulsa una tecla, la columna correspondiente pasa a nivel alto.</strong> Esto es al revés de como pasaba en el botón.</p>
<p>Ahora sí, comencemos. Preparemos el proyecto para poder añadir el <em>teclado matricial</em>:</p>
<ol>
<li>Descarga del repositorio de la asignatura los ficheros correspondientes <strong>a la parte PORT</strong> de la librería del <em>keyboard</em> correspondientes a la versión <code>V2</code>: <a href="https://github.com/sdg2DieUpm/simone/tree/simone_v2">https://github.com/sdg2DieUpm/simone/tree/simone_v2</a>. Solo descarga por ahora: <code>port_keyboard.h</code>, <code>stm32f4_keyboard.h</code>, y <code>stm32f4_keyboard.c</code> y colócalos en las carpetas correspondientes. <strong>De la parte COMMON descarga solo <code>keyboards.h</code>, y <code>keyboards.c</code></strong>, que incluyen los <em>layouts</em> de los teclados matriciales.</li>
<li>Coloca cada uno donde corresponde: <code>PORT</code> o <code>COMMON</code>, en <code>include</code>, o <code>src</code>. <strong>Ten en cuenta que algunos ficheros de <code>PORT</code> están en la carpeta <code>stm32f4</code> porque sus funciones reciben o devuelven estructuras específicas de la <span style="color: RoyalBlue; font-weight: bold;">Nucleo-STM32F446RE</span>.</strong></li>
</ol>
<p>Verás que no compila, y es que solo se te proporciona cierta parte del código. Los prototipos de gran parte de las funciones públicas no están definidos.</p>
<h2 id="sec:layouts_keyboards"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.2</span> Layouts de teclados matriciales<a class="headerlink" href="#sec:layouts_keyboards" title="Permanent link">¶</a></h2>
<p>Antes de ponernos a programar, conviene explicar qué son los ficheros <code>keyboards.h</code> y <code>keyboards.c</code>. Estos ficheros se han de colocar en la carpeta <code>common/include</code> y <code>common/src</code> respectivamente. Estos ficheros contienen los <em>layouts</em> de los teclados matriciales que queramos usar en nuestro proyecto. Un <em>layout</em> es una matriz que define qué carácter representa cada tecla del teclado. Por ejemplo, en un teclado 4x4 típico, la primera fila podría representar los caracteres '1', '2', '3', 'A'; la segunda fila '4', '5', '6', 'B'; y así sucesivamente, pero otro de 4x4 también podría tener una distribución diferente (solo letras, o solo números), ¡o tener otro de 1x3 de colores!...</p>
<p>Estos ficheros permiten definir múltiples <em>layouts</em> para diferentes teclados matriciales, facilitando su uso en la librería del teclado. En la <a href="#cha:version5">Versión 5</a> podrías querer añadir un nuevo <em>layout</em> de algún teclado extra, o modificar el existente.</p>
<p>La estructura <code>keyboard_t</code> definida en <code>keyboards.h</code> contiene:</p>
<ul>
<li>Un puntero a una matriz de caracteres (<code>const char *keys</code>), que representa el <em>layout</em> del teclado.</li>
<li>El número de filas (<code>uint8_t rows</code>) y columnas (<code>uint8_t cols</code>) del teclado.</li>
<li>Un caracter especial (<code>char null_key</code>) que indica que no se ha pulsado ninguna tecla. Por ejemplo el caracter <a href="acronimos.html#acro:ASCII">ASCII</a> nulo <code>'\0'</code>.</li>
</ul>
<p>En el mismo fichero se declara <code>standard_keyboard</code> como un ejemplo de <em>layout</em> para un teclado matricial 4x4. El nombre es algo genérico y representativo. Este <em>layout</em> se define en <code>keyboards.c</code> como una matriz de caracteres que representa las teclas del teclado. Aquí se hace público para que pueda ser usado en otras partes del código; sus particularidades se definen en el <code>.c</code>.</p>
<h2 id="sec:headers_keyboard"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.3</span> <code>PORT</code>: cabeceras de la librería del teclado<a class="headerlink" href="#sec:headers_keyboard" title="Permanent link">¶</a></h2>
<p>Vamos a implementar el <em>contrato con el usuario</em> de la parte dependiente del HW de librería del teclado. Esta interfaz permitirá configurar las filas y columnas de nuestro teclado y realizar el barrido de excitación de filas y lectura de columnas para identificar la tecla pulsada.</p>
<p>El montaje de nuestro módulo teclado matricial tendrá un aspecto como el mostrado en la <a href="#fig:fritzing_keyboard">figura</a>.</p>
<figure><img alt="Montaje del teclado matricial con la Nucleo-STM32F446RE." id="fig:fritzing_keyboard" src="../assets/notebook_imgs/pr_chapters/version_2/fritzing_keyboard.png" style="width:100.0%"><figcaption aria-hidden="true">Montaje del teclado matricial con la <span style="color: RoyalBlue; font-weight: bold;">Nucleo-STM32F446RE</span></figcaption></img></figure>
<p>Más adelante lo implementaremos.</p>
<h3 id="cabecera-port_keyboardh"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.3.1</span> Cabecera port_keyboard.h<a class="headerlink" href="#cabecera-port_keyboardh" title="Permanent link">¶</a></h3>
<p>Esta cabecera depende del HW pero no de las particularidades del microcontrolador <span style="color: RoyalBlue; font-weight: bold;">STM32F446RE</span>. Vamos a seguir los siguientes pasos:</p>
<ul>
<li>Incluye todas las cabeceras necesarias según indica la API.</li>
<li>
<p>Incluye los (<code>#define</code>) necesarios para el teclado: el identificador <code>PORT_KEYBOARD_MAIN_ID</code> que usaremos en el proyecto Simone, el <em>timeout</em> de excitación de filas, y el tiempo de antirebotes de las teclas (<strong>mismo tiempo para todas</strong>).</p>
<p>Hemos decidido darle el nombre <code>PORT_KEYBOARD_MAIN_ID</code> al teclado que usaremos en el juego. En la <a href="#cha:version5">Versión 5</a> podríamos querer añadir más teclados, y entonces habría que definir más identificadores con otros nombres representativos.
- Define el enumerado que identifica los índices de las columnas del teclado, y que será de utilidad para hacer el código más legible en el manejo de las interrupciones.
- Escribe los prototipos de las funciones públicas que aparecen en la API del fichero <code>port_keyboard.h</code>.
- Puede ser buen momento ahora para documentar con Doxygen.</p>
</li>
</ul>
<h3 id="cabecera-stm32f4_keyboardh"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.3.2</span> Cabecera stm32f4_keyboard.h<a class="headerlink" href="#cabecera-stm32f4_keyboardh" title="Permanent link">¶</a></h3>
<p>Esta cabecera define los pines físicos a los que están conectadas las filas y columnas de los teclados que usemos con nuestra placa <span style="color: RoyalBlue; font-weight: bold;">Nucleo-STM32F446RE</span>.</p>
<ol>
<li>Incluye todas las cabeceras necesarias.</li>
<li>
<p>Define (<code>#define</code>) los valores de las GPIO y pines para las 4 filas y las 4 columnas según indica la <a href="#tbl:version2_keypad">tabla de características del teclado matricial</a>.</p>
</li>
<li>
<p>Declara la estructura <code>stm32f4_keyboard_hw_t</code> que contendrá la configuración física del teclado.</p>
<p>Presta atención a la documentación que explica en cada campo qué deberá contener. Recuerda que las filas son salidas y las columnas entradas.</p>
<p>Especial mención merecen los campos <code>p_row_ports</code> y <code>p_col_ports</code>, que <strong>son dobles punteros: punteros a arrays de punteros a estructuras</strong> <code>GPIO_TypeDef</code>. Estos campos permiten almacenar las referencias a los puertos GPIO de cada fila y columna del teclado. Esta es la forma de poder definir una estructura genérica sin saber el tamaño del teclado que va a gestionar. Nos da lo mismo que definamos un teclado de 2x2, 4x4 o 5x3; por eso estos campos son punteros que apuntarán a arrays de elementos de tipo <code>GPIO_TypeDef*</code> (por ejemplo, <code>GPIOA</code>, <code>GPIOB</code>, etc.). Así, podemos tener una lista dinámica de puertos para las filas y columnas del teclado, adaptándonos a cualquier configuración física que necesitemos.</p>
<p>El campo <code>p_layout</code> es un <strong>puntero a una estructura <code>keyboard_t</code>, que contiene el <a href="#sec:layouts_keyboards"><em>layout</em> del teclado</a></strong>. Esto nos permite asociar el diseño lógico del teclado con su configuración física. Se declara <code>const</code> porque el <em>layout</em> no debe modificarse en tiempo de ejecución.</p>
<p>Fíjate también que <strong>la estructura NO guarda la tecla pulsada</strong>, sino que guarda el índice de la fila que se está excitando y la columna que genera la interrupción. La gestión de la tecla pulsada se hará en la FSM del teclado, que es independiente del HW.</p>
</li>
<li>
<p>Declarar el array de estructuras de tipo <code>stm32f4_keyboard_hw_t</code> como se hizo con el botón. Este array contendrá las características de todos los teclados que tengamos en el sistema.</p>
</li>
<li>
<p>Documenta los <code>#define</code> con Doxygen.</p>
</li>
</ol>
<p>Ya hemos acabado con el encabezado (<em>header</em>) que interactúa con el HW. Todavía dará errores al compilar. Vamos ahora a implementar todas las funciones prototipadas en <code>port_keyboard.h</code>.</p>
<h2 id="sec:port_keyboard"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.4</span> <code>PORT</code>: fuente de la librería del teclado<a class="headerlink" href="#sec:port_keyboard" title="Permanent link">¶</a></h2>
<p>Vamos a <em>portar</em> las funciones necesarias para controlar los pines del teclado. Programaremos los ficheros fuente de la parte <code>PORT</code>, que <strong>todos estarán en el fichero <code>stm32f4_keyboard.c</code></strong>.</p>
<h3 id="fuentes-stm32f4_keyboardc"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.4.1</span> Fuentes stm32f4_keyboard.c<a class="headerlink" href="#fuentes-stm32f4_keyboardc" title="Permanent link">¶</a></h3>
<p>La complejidad aquí reside en la gestión de múltiples pines y en la lógica de configuración de entrada/salida.</p>
<ol>
<li>Incluye las librerías necesarias.</li>
<li>Verás que en la plantilla proporcionada se han definido 4 arrays que corresponden con laos puertos y pines de las filas y columnas del teclado. Estos arrays se usan para inicializar la estructura del teclado. Estos son los arrays de elementos <code>GPIO_TypeDef*</code> (y <code>uint8_t</code>) de los que hablabamos anteriormente y alos que apuntará la estructura <code>stm32f4_keyboard_hw_t</code> del teclado principal <code>KEYBOARD_MAIN</code>.</li>
<li>
<p>Define la <strong>variable global privada</strong> <code>stm32f4_keyboard_hw_t keyboards_arr</code> con la configuración física de nuestro teclado tal y como hicimos con el botón. Los campos <code>p_row_ports</code>, <code>p_row_pins</code>, <code>p_col_ports</code>, y <code>p_col_pins</code> deben apuntar a los arrays definidos en el paso anterior. El campo <code>p_layout</code> <strong>debe apuntar a la dirección de memoria</strong> del <em>layout</em> del teclado estándar definido en <code>keyboards.c</code>. El resto de campos se inicializan en la función <code>port_keyboard_init()</code>.</p>
</li>
<li>
<p>Codifica la función <code>_stm32f4_keyboard_get()</code> para recuperar la configuración del hardware, de modo análogo a como se hizo para el botón.</p>
</li>
<li>
<p>Codifica la función <code>port_keyboard_init()</code> como se indica en la API.</p>
<p><span style="color: Red">Recuerda que es muy importante indicar en el modo de las interrupciones de las columnas del teclado que, <strong>además de detectar ambos flancos (subida y bajada), debe habilitar la petición de interrupción (registro <code>EXTI_IMR</code>)</strong></span>.</p>
<p>Se recomienda usar bucles para configurar las filas y columnas, y evitar el <em>spaghetti code</em>. Esto hace que el código sea más compacto y fácil de leer y mantener.</p>
</li>
<li>
<p>Codifica la función <code>port_keyboard_excite_row()</code> como se indica en la API. Esta función debe <strong>activar la fila indicada y ¡desactivar las restantes!</strong></p>
</li>
<li>
<p>Codifica la función <code>port_keyboard_get_cols()</code> como se indica en la API. Esta función llama a la anterior pero antes actualiza <code>current_excited_row</code>, que es el índice de la fila a ser excitada.</p>
</li>
<li>
<p>Codifica todos los <em>getters</em> y <em>setters</em> que aparecen en el <code>.h</code> como indica la API. Especial atención a la función <code>port_keyboard_get_key_value()</code>, que debe devolver el carácter ASCII correspondiente a la tecla pulsada, usando el <em>layout</em> del teclado.</p>
<p>Como en nuestra estructura <strong>no tenemos definida de manera fija el array del <em>layout</em> del teclado</strong>, sino que tenemos un puntero a una estructura <code>keyboard_t</code>, no podemos acceder directamente al array de teclas tratado como matriz bidimensional con los índices de la fila y columna. En su lugar, <strong>debemos tratar el array como unidimensional</strong> -que es, por otro lado, como está almacenado en memoria- y calcular la posición del caracter de la tecla pulsada usando la fórmula:</p>
<div class="highlight"><pre><span></span><code><span class="n">key</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">excited</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="n">columns</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">column</span><span class="w"> </span><span class="n">interrupting</span>
</code></pre></div>
<p>Vamos a codificar ahora las funciones que gestionan el temporizador que controla la excitación de las filas.</p>
<p><div id="tbl:version2_timer"></div></p>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>Parámetro</strong></th>
<th style="text-align: center;"><strong>Valor</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Temporizador</td>
<td style="text-align: center;"><code>TIM5</code></td>
</tr>
<tr>
<td style="text-align: left;">Prescaler</td>
<td style="text-align: center;">(a calcular para <code>PORT_KEYBOARDS_TIMEOUT_MS</code>)</td>
</tr>
<tr>
<td style="text-align: left;">Periodo</td>
<td style="text-align: center;">(a calcular para <code>PORT_KEYBOARDS_TIMEOUT_MS</code>)</td>
</tr>
<tr>
<td style="text-align: left;">ISR</td>
<td style="text-align: center;"><code>TIM5_IRQHandler</code></td>
</tr>
<tr>
<td style="text-align: left;">Prioridad</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">Subrioridad</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Codifica la función <code>_timer_trigger_setup()</code> como indica la API. Esta función configura el <em><em>temporizador que controla el tiempo de excitación de las filas de cualquier teclado que se monte en el juego; si hubiese más de uno, todos se excitarían a la vez. Para ello, apóyate en el ejemplo </em>"timer para interrupción periódica"</em> del libro de fundamentos teóricos <sup id="fnref2:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">3</a></sup>.</p>
<p>Esta función configura un temporizador para que genere una interrupción de <code>PORT_KEYBOARDS_TIMEOUT_MS</code> milisegundos desde que se habilita el mismo. El temporizador elegido se muestra en la <a href="#tbl:version2_timer">tabla de características del teclado</a>.</p>
<p>Lo vamos a usar para que genere interrupciones periódicas. Lo activaremos cuando durante el juego sea turno del jugador que use el teclado matricial, y lo desactivaremos cuando se esté reproduciendo la secuencia de colores.</p>
<p>Para saber qué fuente de reloj habilitar para el temporizador, consulta la tabla <em>"Figure 3. STM32F446xC/E block diagram"</em> del <em>datasheet "STM32F446xC/E"</em> <sup id="fnref:st2021datasheet"><a class="footnote-ref" href="#fn:st2021datasheet">4</a></sup>. Allí podrás ver si nuestro temporizador está conectado al <strong>APB1</strong> o al <strong>APB2</strong>, y tenemos que habilitar el reloj en el registro <code>RCC-&gt;APB1ENR</code> o <code>RCC-&gt;APB2ENR</code> respectivamente.</p>
<p>Es importante que no pongas los valores de los registros de configuración del temporizador a mano, sino que uses las ecuaciones que se proporcionan en el libro de fundamentos teóricos <sup id="fnref3:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">3</a></sup> para calcular los valores de los registros <code>TIMx-&gt;PSC</code> y <code>TIMx-&gt;ARR</code>. En cualquier momento podríamos querer cambiar el periodo de excitación de filas y, si lo hacemos a mano, podríamos cometer errores, además de que es menos legible.</p>
<p>**Es muy importante que la función <code>_timer_scan_column_config()</code> se llame desde la función <code>port_keyboard_init()</code>. Si no, no se podrán generar interrupciones para excitar filas y leer columnas.</p>
</li>
<li>
<p>Codifica la función <code>port_keyboard_start_scan()</code> que se encarga de habilitar las interrupciones del temporizador y activar la cuenta (reseteando el contador). En esta función se resetea el flag <code>flag_row_timeout</code>, y se excita la primera fila del teclado.</p>
</li>
<li>Codifica la función <code>port_keyboard_stop_scan()</code> que deshabilita las interrupciones del temporizador y detiene la cuenta. Del mismo modo, apaga todas las filas del teclado.</li>
</ol>
<p>**¡Ya hemos acabado con la implementación de la parte HW <code>stm32f\_keyboard.c</code> del teclado. Ahora solo queda la ISR asociada a dicho temporizador en el fichero `interr.c``. Vamos a ello.</p>
<h3 id="interrc"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.4.2</span> interr.c<a class="headerlink" href="#interrc" title="Permanent link">¶</a></h3>
<p>Abre el fichero <code>interr.c</code>. Tenemos que codificar las <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> para gestionar las interrupciones de cada una de las columnas y del temporizador de excitación de filas.</p>
<p>Es muy importante que notes que algunas  están compartidas <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> por distintas líneas. Esto ya lo vimos en la <a href="#sec:interr_button">Versión 1 con el botón</a>. Por ejemplo la ISR <code>EXTI15_10_IRQHandler()</code> gestiona las interrupciones de las líneas 10 a la 15 <strong>de cualquier <a href="acronimos.html#acro:GPIO">GPIO</a></strong>, y es por ello que habíamos puesto un <code>if</code> para identificar la fuente. Es ahora cuando le vas a encontrar más sentido a ese bloque condicional.</p>
<p>Fíjate en las <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a> de las interrupciones de las columnas del teclado matricial en la <a href="#tbl:version2_keypad">tabla de características del teclado</a>: 2 de las columnas comparten <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a>, y otra de ellas la comparte con el botón. Vamos a codificar dichas <a href="acronimos.html#acro:ISR"><strong>ISR</strong></a>:</p>
<ol>
<li>
<p>Completa la ISR <code>EXTI15_10_IRQHandler</code> para gestionar la interrupción de la columna <code>PORT_KEYBOARD_COL_1</code> (la segunda) del teclado matricial. Recuerda que esta ISR también gestiona la interrupción del botón, por lo que debes mantener el bloque condicional <code>if</code> que ya estaba implementado.</p>
<p>Fíjate, en la API, en el <em>TODO</em> para Versión 2.</p>
<div class="admonition note función auxiliar">
<p class="admonition-title">Note</p>
<p>Tanto esta ISR como las siguientes hacen llamadas la función privada <code>_check_column_interrupt()</code>, que se encargará de gestionar el flag de pulsación de tecla y guardar el índice de la columna que ha generado la interrupción. <strong>Esta función auxiliar es opcional implementarla, pero hace el código más legible y evita repetir código.</strong> Si no quieres implementarla, asegúrate de hacer en cada ISR de cada columna lo que la API indica para esta función.</p>
<p>Si quieres implementar <code>_check_column_interrupt()</code>, hazlo ahora. Debes colocarla antes de cualquier función que la use.</p>
</div>
<p>Esta ISR, cuando salta, se encarga de llamar a la función correspondiente para <em>settear</em> el estado del flag de pulsación de tecla y guardar el índice de la columna que ha generado la interrupción.</p>
</li>
<li>
<p>Codifica la ISR <code>EXTI9_5_IRQHandler</code> para gestionar las interrupciones de las columnas <code>PORT_KEYBOARD_COL_0</code> (la primera) y <code>PORT_KEYBOARD_COL_3</code> (la cuarta) del teclado matricial. Esta ISR gestiona las interrupciones de dos líneas del teclado matricial, por lo que debes mantener un bloque condicional <code>if</code> como en de la ISR anterior.</p>
</li>
<li>
<p>Codifica la ISR <code>EXTI4_IRQHandler</code> para gestionar la interrupción de la columna <code>PORT_KEYBOARD_COL_2</code> (la tercera) del teclado matricial. Como esta ISR no está compartida entre líneas del <code>EXTI</code>, no es necesario un bloque condicional.</p>
</li>
<li>
<p>Por último, codifica la ISR <code>TIM5_IRQHandler</code> como se indica en la API. Recuerda que las ISR no reciben ni devuelven nada.</p>
<p>Esta ISR, cuando salta, se encarga de llamar a la función correspondiente para <em>settear</em> el estado del flag de <em>timeout</em> que permitirá excitar la siguiente fila del teclado.</p>
</li>
<li>
<p>Si queda algo por documentar puede ser buen momento ahora.</p>
</li>
</ol>
<p>Si ahora compilas, el código no debería tener ningún error. <strong>¡Ya hemos acabado con la implementación de <em>portado</em> de excitación de filas para lectura de teclas en un teclado matricial!</strong>. Vamos a probarlo con el <em>test</em> unitario de la parte <code>PORT</code> para esta parte.</p>
<h2 id="sec:test_port_keyboard"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.5</span> <code>PORT</code>: Test unitario del teclado matricial<a class="headerlink" href="#sec:test_port_keyboard" title="Permanent link">¶</a></h2>
<p>Vamos a comprobar que la parte <code>PORT</code> funciona correctamente pasando los test HW del código que hemos desarrollado antes de continuar.</p>
<p><span style="color: Red"><strong>¡Importante! Los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente.</strong></span> <img alt="image" class="inline-img" src="../assets/notebook_imgs/general/gen_book_icon.png"> Ten a mano y revisa el capítulo <em>“Test unitarios y ejemplos de integración”</em> del libro de fundamentos teóricos <sup id="fnref:stm322025fundamentos"><a class="footnote-ref" href="#fn:stm322025fundamentos">3</a></sup>.</img></p>
<p>Descarga el fichero de test HW del teclado <code>test_port_keyboard.c</code> de <a href="https://github.com/sdg2DieUpm/simone/tree/simone_v2_test">https://github.com/sdg2DieUpm/simone/tree/simone_v2_test</a>. Ponlo en la carpeta <code>test/stm32f4</code> de tu proyecto.</p>
<ol>
<li>
<p>Conecta la placa <span style="color: RoyalBlue; font-weight: bold;">Nucleo-STM32</span> al ordenador.</p>
</li>
<li>
<p>Pulsa sobre el <strong>icono de depuración <img alt="image" class="inline-img" src="../assets/notebook_imgs/general/icon_debug.png"> y selecciona <img alt="image" class="inline-img" src="../assets/notebook_imgs/general/icon_run.png"> Clean and Debug</img></img></strong> sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p>
</li>
<li>
<p>En el desplegable que se abre, selecciona el test <code>test_port_keyboard</code>. Se compilará y se cargará en la placa.</p>
</li>
<li>
<p>Comprueba que todos los test pasan correctamente en el texto mostrado en la terminal de depuración. Si no es así, lee los mensajes de error y corrige tu código hasta que pase todas las pruebas. <strong>Si no pasa las pruebas, no continúes programando, corrigelas.</strong></p>
</li>
<li>
<p>Termina la depuración pulsando (<img alt="image" class="inline-img" src="../assets/notebook_imgs/general/icon_stop.png"/>) y repite el proceso hasta que pase todos los test.</p>
</li>
</ol>
<p><strong>¡Ya hemos acabado con la parte <code>PORT</code> del teclado!</strong> Vamos ahora a implementar la parte <code>COMMON</code> de la librería del teclado.</p>
<h2 id="common-cabecera-de-la-fsm-del-teclado"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.6</span> <code>COMMON</code>: cabecera de la FSM del teclado<a class="headerlink" href="#common-cabecera-de-la-fsm-del-teclado" title="Permanent link">¶</a></h2>
<h3 id="consideraciones-de-la-fsm-del-teclado"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.6.1</span> Consideraciones de la FSM del teclado<a class="headerlink" href="#consideraciones-de-la-fsm-del-teclado" title="Permanent link">¶</a></h3>
<p>Antes de ponernos a programar, conviene explicar algunos aspectos importantes de la FSM del teclado matricial.</p>
<ul>
<li>
<p>La FSM <strong>almacena el caracter <code>char</code> de la última  tecla pulsada</strong>.</p>
</li>
<li>
<p>El usuario debe solicitar/ comprobar el caracter mediante la función <code>fsm_keyboard_get_key_value()</code>.</p>
</li>
<li>
<p>El valor de inicio del caracter al arrancar la FSM, y el valor de reinicio, debe ser le valor de tecla inválida que haya definido el <em>layout</em> del teclado. En nuestro caso, el valor de tecla inválida es el caracter nulo <code>'\0'</code>, que está definido en la estructura <code>keyboard_t</code> del <em>layout</em> del teclado. En otro teclado podría ser otro, por lo que no hay que poner este valor <em>a pincho</em>, sino el que nos devuelva <code>port_keyboard_get_invalid_key_value()</code>.</p>
<p>¡Ojo! 👁 <strong>¡Al inicializar la FSM, hay que inicializar el <code>port_keyboard_init()</code>, porque de lo contrario, no podremos leer qué tecla es inválida según el <em>layout</em>!</strong></p>
</li>
<li>
<p><strong>Un valor de <code>invalid_key</code> significa que no ha habido una nueva pulsación del teclado.</strong></p>
</li>
<li>
<p><strong>El usuario debe reiniciar el valor de tecla pulsada una vez leído</strong>, de lo contrario, este valor puede ser malinterpretado por el usuario si se realizan sucesivas comprobaciones sin haber pulsado el teclado. Es análogo a lo que hacíamos con el botón.  Para reiniciar el valor se debe llamar a la función <code>fsm_keyboard_reset_key_value()</code>.</p>
</li>
<li>
<p>La FSM contiene información del identificador (<code>ID</code>) del teclado que maneja. Este <code>ID</code> es único y gestionado por el usuario en el <code>PORT</code>. Ahí es donde el usuario proporciona identificadores e información HW (GPIOs a la que está conectado y tiempo de anti-rebotes) para todos los teclados de su sistema.</p>
</li>
</ul>
<figure><embed id="fig:fsm_keyboard" src="../assets/notebook_imgs/pr_chapters/version_2/fsm_keyboard.svg" style="width:100.0%"/><figcaption aria-hidden="true">Máquina de estados del teclado matricial.</figcaption></figure>
<p>Nuestra librería implementa la lógica de la <a href="acronimos.html#acro:FSM"><strong>FSM</strong></a> mostrada en el <a href="#fig:fsm_keyboard">diagrama de la figura</a> y que llamaremos <code>fsm_keyboard</code> (en los ficheros <code>.c</code> y <code>.h</code>). Es análoga a la del botón, salvo por una <strong>autotransición</strong> en el primer estado. Tiene 4 estados porque <strong>implementa también un mecanismo anti-rebotes SW</strong>. Nos centramos en la descripción de ese primer estado y su autotransición, para el resto, vaya la descripción hecha en <a href="#sec:consideraciones_fsm_button">las consideraciones de la FSM del botón</a>:</p>
<ul>
<li>
<p><code>KEYBOARD_RELEASED_WAIT_ROW</code>: es el estado inicial de la máquina de estados, y es al estado al que vuelve cuando se pulsa ¡y se suelta! una tecla. En este estado, además, se comprueba si ha pasado el <em>timeout</em> de excitación de filas (flag <code>flag_row_timeout</code>), y si es así, se excita la siguiente fila del teclado, <strong>permaneciendo en este estado (autotransición)</strong>. Esta excitación se hace llamando a la función <code>port_keyboard_get_cols()</code>, que devuelve el índice de la fila que se está excitando. Si, durante la excitación de una fila, se detecta una interrupción en alguna columna en <code>do_set_key_value()</code> se guardará dicho valor tras pedírselo al <code>PORT</code>.</p>
<p><strong>Será el usuario en su programa principal quien deba reiniciar el valor de tecla pulsada una vez leído, llamando a la función <code>fsm_keyboard_reset_key_value()</code></strong>, como se hacía con el botón.</p>
</li>
</ul>
<p>La parte <code>COMMON</code> de nuestra librería trabaja con la estructura (<code>struct</code>) <strong>pública</strong> que se muestra en la <a href="#fig:fsm_common_t">figura (b) de estructuras</a>.</p>
<ol>
<li>
<p>Descarga del repositorio los ficheros correspondientes <strong>a la parte COMMON</strong> de la librería del <em>teclado</em> correspondientes a la versión <code>V2</code>: <a href="https://github.com/sdg2DieUpm/simone/tree/simone_v2">https://github.com/sdg2DieUpm/simone/tree/simone_v2</a>. Solo descarga lo que faltaba por implementar, es decir, los ficheros <code>fsm_keyboard.h</code> y <code>fsm_keyboard.c</code> y ponlos en las carpetas correspondientes de tu proyecto.</p>
<p>Ahora, vamos a completar la cabecera de la <a href="acronimos.html#acro:FSM"><strong>FSM</strong></a> del teclado, <code>fsm_keyboard.h</code>.</p>
</li>
<li>
<p>Incluye las librerías necesarias, si falta alguna, según indique la API.</p>
</li>
<li>
<p>Escribe el <code>enum</code> <code>FSM_KEYBOARD</code> con los nombres de los estados del diagrama de la separados por <code>,</code>. <strong>No olvides poner un <code>;</code> al final del <code>enum</code>.</strong></p>
</li>
<li>
<p><strong>Declara</strong> la estructura <code>fsm_keyboard_t</code> para hacerla pública como indica la <a href="#fig:fsm_keyboard_t">figura de la estructura de la FSM</a>, y documenta cada campo con Doxygen.</p>
<p>Continuamos con las declaraciones de funciones públicas de la librería. <strong>Procedamos</strong>:</p>
</li>
<li>
<p>Escribe los prototipos de las <strong>funciones públicas</strong> que aparecen en la API del fichero <code>fsm_keyboard.h</code> y documenta cada función con Doxygen. Recuerda que la documentación va encima del nombre de cada función.</p>
</li>
</ol>
<p>Ya hemos acabado con el encabezado. Quizás de errores al compilar. Vamos ahora a programar el fichero fuente <code>fsm_keyboard.c</code>.</p>
<h2 id="sec:fsm_keyboard"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.7</span> <code>COMMON</code>: fuente de la FSM del teclado<a class="headerlink" href="#sec:fsm_keyboard" title="Permanent link">¶</a></h2>
<p>Vamos a proceder con la implementación de las funciones del <em>teclado</em>. Deberás implementar todas las <strong>funciones públicas</strong> de las que ya has declarado el prototipo en el encabezado, y el resto de <strong>funciones privadas</strong> que aparecen en la API del fichero <code>fsm_keyboard.c</code>. También definiremos las variables globales y estructuras que sean necesarias. <strong>¡Recuerda que las funciones privadas no se declaran en el <code>.h</code>!</strong></p>
<ol>
<li>
<p>Incluye las cabeceras que indica la API.</p>
<p>Ahora empezamos a codificar las <strong>funciones privadas de entrada o comprobación de la FSM <code>check_</code></strong>.</p>
</li>
<li>
<p>Codifica las funciones <code>check_row_timeout()</code>, <code>check_keyboard_pressed()</code>, <code>check_keyboard_released()</code>, y <code>check_timeout()</code> como se indica en la API.</p>
<p>Puede ser buen momento ahora para documentar las funciones con Doxygen. En este caso, como las funciones no están declaradas en el encabezado, la documentación irá en el <code>.c</code>, encima del nombre de cada función.</p>
</li>
<li>
<p>Codifica las funciones <code>do_excite_next_row()</code>, <code>do_store_tick_pressed()</code>, <code>do_clear_key_value()</code>, y <code>do_set_key_value()</code> como se indica en la API.</p>
<p>Documenta las funciones con Doxygen igual que antes.</p>
</li>
<li>
<p>Definimos <code>static fsm_trans_t fsm_trans_keyboard\[\] = ...</code> justo después de la función <code>do_set_key_value()</code> siguiendo el <a href="#fig:fsm_keyboard">diagrama de la FSM</a>.</p>
<p>Recuerda que debe haber una fila en la tabla por cada flecha de transición entre estados de la forma: <code>EstadoIni, FuncCompruebaCondicion, EstadoSig, FuncAccionesSiTransicion</code>. No olvides añadir la fila <code>-1, NULL, -1, NULL</code>. No olvides que el <code>EstadoIni</code> de la primera transición es el estado inicial de la FSM.</p>
</li>
<li>
<p>Codifica las funciones <code>fsm_keyboard_start_scan()</code>, <code>fsm_keyboard_stop_scan()</code>, <code>fsm_keyboard_get_key_value()</code>, y <code>fsm_keyboard_get_is_valid_key()</code> como se indica en la API. Con esta última función, el usuario podrá comprobar si la última tecla pulsada es válida o no.</p>
<p>Codifica también la función <code>fsm_keyboard_reset_key_value()</code> con la que el usuario podrá reiniciar el valor de la tecla pulsada a <code>invalid_key</code> tras leerla.</p>
</li>
<li>
<p>Completa la función <code>fsm_keyboard_init()</code> como se indica en la API.</p>
</li>
<li>
<p>Codifica las funciones <code>fsm_keyboard_fire()</code>, <code>fsm_keyboard_get_inner_fsm()</code>, y <code>fsm_keyboard_get_state()</code> de manera análoga a <a href="version_1.html#sec:fsm_button_c">como se hizo en la FSM del botón</a>.</p>
</li>
<li>
<p>Documenta el código que esté sin comentar.</p>
</li>
</ol>
<p><strong>Ya hemos acabado con la programación de la librería del teclado.</strong> Toda esta lógica <code>COMMON</code> <strong>puede ser usada en cualquier sistema</strong>. Hemos hecho una librería de un teclado que tiene un anti-rebotes y nos devuelve el valor de la última tecla pulsada. Así pues, si compilas, no deberían aparecer errores.</p>
<h2 id="sec:test_fsm_v2"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.8</span> <code>COMMON</code> Test unitario de la FSM del teclado<a class="headerlink" href="#sec:test_fsm_v2" title="Permanent link">¶</a></h2>
<p>Vamos a probar el test del código que hemos desarrollado de la librería de la máquina de estados del teclado y probar que funciona antes de continuar con la siguiente versión.
<span style="color: Red"><strong>¡Importante! Recuerda que los test que se proporcionan comprueban solo algunos aspectos esenciales, pero no son exhaustivos. Es responsabilidad del alumno comprobar que el sistema final funciona correctamente.</strong></span></p>
<p>Descarga el fichero de test de la FSM del teclado <code>test_fsm_keyboard.c</code> de <a href="https://github.com/sdg2DieUpm/simone/tree/simone_v2_test">https://github.com/sdg2DieUpm/simone/tree/simone_v2_test</a>. Ponlo en la carpeta <code>test/</code> de tu proyecto. <strong>¡No lo metas en stm32f4/, pues no es un test específico del microcontrolador!</strong></p>
<ol>
<li>
<p>Con la placa <span style="color: RoyalBlue; font-weight: bold;">Nucleo-STM32</span> conectada al ordenador.</p>
</li>
<li>
<p>Pulsa sobre el <strong>icono Clean and Debug</strong> sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p>
</li>
<li>
<p>En el desplegable que se abre, selecciona el test <code>test_fsm_keyboard</code>. Se compilará y se cargará en la placa.</p>
</li>
<li>
<p>Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso.</p>
</li>
<li>
<p>Se habrá impreso por la terminal del <code>gdb-server</code> el resultado de las pruebas de los tests. Debería haber pasado todos los tests. Si no, lee el mensaje de error y corrige tu código hasta que pasen todas las pruebas. <strong>Si no pasan las pruebas, no continúes.</strong></p>
</li>
<li>
<p>Termina la depuración pulsando (<img alt="image" class="inline-img" src="../assets/notebook_imgs/general/icon_stop.png"/>) y repite el proceso hasta que pasen todos los test.</p>
</li>
</ol>
<h2 id="ejemplo-de-uso-de-la-version-2"><span class="enumerate-headings-plugin enumerate-heading-plugin">5.9</span> Ejemplo de uso de la Versión 2<a class="headerlink" href="#ejemplo-de-uso-de-la-version-2" title="Permanent link">¶</a></h2>
<p>El test de integración no hace uso de la librería <code>unity</code>, sino que es como un pequeño programa de prueba sobre las funciones que hemos implementado y tiene su propio <code>main</code>.</p>
<p>En los test de integración es responsabilidad del alumno comprobar que la funcionalidad es la esperada, porque aquí no hay test unitarios que nos ayuden.</p>
<p>Nuestra librería de teclado devuelve el valor de la última tecla pulsada. Así pues, algunas de las comprobaciones que podemos hacer son: que todas las teclas de todas las columnas aparecen impresas por pantalla, que se reinicia adecuadamente el valor tras leerlo, que funciona el anti-rebotes…</p>
<p>Descarga el fichero de ejemplo <code>example_v2.c</code> de <a href="https://github.com/sdg2DieUpm/simone/tree/simone_v2_test">https://github.com/sdg2DieUpm/simone/tree/simone_v2_test</a>. Ponlo en la carpeta <code>example/</code> de tu proyecto.</p>
<p><strong>Procedamos</strong>:</p>
<p>Para poder hacer el ejemplo del teclado matricial, necesitamos conectarlo como se muestra en el montaje de la <a href="#fig:fritzing_keyboard">figura</a>. <strong>Fíjate que las filas son los pines  de la izquierda si miramos el teclado de frente</strong>. </p>
<ol>
<li>
<p>Monta el circuito del teclado matricial como se muestra en la <a href="#fig:fritzing_keyboard">figura</a>.</p>
</li>
<li>
<p>Pulsa sobre el <strong>icono de depuración <img alt="image" class="inline-img" src="../assets/notebook_imgs/general/icon_debug.png"/> y selecciona <img alt="image" class="inline-img" src="../assets/notebook_imgs/general/icon_run.png"/> Clean and Debug</strong> sobre la plataforma que queramos depurar (<code>stm32f446re</code>).</p>
</li>
<li>
<p>En el desplegable que se abre, selecciona el test <code>example_v2</code>. Se compilará y se cargará en la placa.</p>
</li>
<li>
<p>Se parará en la primera línea del <code>main()</code>. Ejecuta el test por completo, o pon puntos de parada si deseas ir paso a paso. Este código no termina, pues es un bucle <code>while</code> infinito.</p>
</li>
<li>
<p>Abre la terminal del <code>gdb-server</code> para ver los mensajes que se van imprimiendo.</p>
</li>
<li>
<p>Pulsa una a una todas las teclas del teclado.Deberías ver que se imprime por pantalla el caracter de la pulsación. Si no es así, revisa tu código.</p>
</li>
<li>
<p>Haz distintas pruebas y asegúrate de que el comportamiento es el adecuado.</p>
</li>
</ol>
<p>¡Hemos creado nuestra primera librería! Fíjate que es <em>portable</em> a cualquier plataforma solo con adaptar las funciones del <code>PORT</code>.</p>
<p>No dejes de documentar el código. <strong>Comprueba que la documentación del código se ha generado correctamente como se explica en la <em>“Guía de instalación de herramientas para compilación multiplataforma en C”</em> <sup id="fnref:stm322025guiainstalacion"><a class="footnote-ref" href="#fn:stm322025guiainstalacion">6</a></sup>.</strong>, o en el vídeo <a href="https://youtu.be/VC7fExJJQSY?si=YIY22n5yiqzfZuQd">"[MatrixMCU] Documentación de código con Doxygen”</a>.</p>
<p>Guarda una copia de su proyecto como <code>simone_v2</code> para tener un punto de partida para la siguiente versión, y una copia de seguridad por si algo falla.</p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:1">
<p>Por ejemplo, un teclado de ordenador, una calculadora, un cajero automático, etc. No nos hacemos responsables de posibles daños que pueda ocasionar 😅. <a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:2">
<p>Para un mejor contacto, el circuito de la imagen son dos pistas de cobre en zig-zag que se cortocircuitan al pulsar el botón. Lo más simple sería una cruz que no se toca, pero su contacto es menos fiable. En teclados más avanzados, puede haber circuitos adicionales para mejorar la durabilidad o la respuesta táctil. <a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:stm322025fundamentos">
<p>Josué Pagán Ortiz. <em>Fundamentos teóricos de sistemas basados en microcontrolador STM32</em>. Universidad Politécnica de Madrid, 2024. <a class="footnote-backref" href="#fnref:stm322025fundamentos" title="Jump back to footnote 3 in the text">↩</a><a class="footnote-backref" href="#fnref2:stm322025fundamentos" title="Jump back to footnote 3 in the text">↩</a><a class="footnote-backref" href="#fnref3:stm322025fundamentos" title="Jump back to footnote 3 in the text">↩</a><a class="footnote-backref" href="#fnref4:stm322025fundamentos" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:st2021datasheet">
<p>STMicroelectronics. Stm32f446xc/e. Technical Report, STMicroelectronics, 2021. URL: <a href="https://www.st.com/resource/en/datasheet/stm32f446re.pdf">https://www.st.com/resource/en/datasheet/stm32f446re.pdf</a>. <a class="footnote-backref" href="#fnref:st2021datasheet" title="Jump back to footnote 4 in the text">↩</a><a class="footnote-backref" href="#fnref2:st2021datasheet" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn:st2021reference">
<p>STMicroelectronics. Rm0390 reference manual. stm32f446xx advanced arm-based 32-bit mcus. Technical Report, STMicroelectronics, 2021. URL: <a href="https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">https://www.st.com/resource/en/reference_manual/rm0390-stm32f446xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf</a>. <a class="footnote-backref" href="#fnref:st2021reference" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
<li id="fn:stm322025guiainstalacion">
<p>Josué Pagán Ortiz, Pedro José Malagón Marzo, Daniel Capellán Martín, Román Cárdenas Rodríguez, and Amadeo de Gracia Herranz. <em>Guía de instalación de herramientas para compilación multiplataforma en C</em>. Universidad Politécnica de Madrid, 2024. <a class="footnote-backref" href="#fnref:stm322025guiainstalacion" title="Jump back to footnote 6 in the text">↩</a></p>
</li>
</ol>
</div>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
<button class="md-top md-icon" data-md-component="top" hidden="" type="button">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"></path></svg>
  Volver al principio
</button>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "..", "features": ["navigation.sections", "navigation.expand", "navigation.top", "content.code.copy"], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version": "Seleccionar versi\u00f3n"}, "version": null}</script>
<script src="../assets/javascripts/bundle.13a4f30d.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
</body>
</html>